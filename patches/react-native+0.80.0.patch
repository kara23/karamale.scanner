diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAccessibilityInfoSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAccessibilityInfoSpec.java
new file mode 100644
index 0000000..5992d87
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAccessibilityInfoSpec.java
@@ -0,0 +1,70 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeAccessibilityInfoSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "AccessibilityInfo";
+
+  public NativeAccessibilityInfoSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void isReduceMotionEnabled(Callback onSuccess);
+
+  @ReactMethod
+  @DoNotStrip
+  public void isInvertColorsEnabled(Callback onSuccess) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public void isHighTextContrastEnabled(Callback onSuccess) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void isTouchExplorationEnabled(Callback onSuccess);
+
+  @ReactMethod
+  @DoNotStrip
+  public void isAccessibilityServiceEnabled(Callback onSuccess) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setAccessibilityFocus(double reactTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void announceForAccessibility(String announcement);
+
+  @ReactMethod
+  @DoNotStrip
+  public void getRecommendedTimeoutMillis(double mSec, Callback onSuccess) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public void isGrayscaleEnabled(Callback onSuccess) {}
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAccessibilityManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAccessibilityManagerSpec.java
new file mode 100644
index 0000000..ec66eb2
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAccessibilityManagerSpec.java
@@ -0,0 +1,83 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeAccessibilityManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "AccessibilityManager";
+
+  public NativeAccessibilityManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCurrentBoldTextState(Callback onSuccess, Callback onError);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCurrentGrayscaleState(Callback onSuccess, Callback onError);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCurrentInvertColorsState(Callback onSuccess, Callback onError);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCurrentReduceMotionState(Callback onSuccess, Callback onError);
+
+  @ReactMethod
+  @DoNotStrip
+  public void getCurrentDarkerSystemColorsState(Callback onSuccess, Callback onError) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public void getCurrentPrefersCrossFadeTransitionsState(Callback onSuccess, Callback onError) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCurrentReduceTransparencyState(Callback onSuccess, Callback onError);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCurrentVoiceOverState(Callback onSuccess, Callback onError);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setAccessibilityContentSizeMultipliers(ReadableMap JSMultipliers);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setAccessibilityFocus(double reactTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void announceForAccessibility(String announcement);
+
+  @ReactMethod
+  @DoNotStrip
+  public void announceForAccessibilityWithOptions(String announcement, ReadableMap options) {}
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeActionSheetManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeActionSheetManagerSpec.java
new file mode 100644
index 0000000..6367658
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeActionSheetManagerSpec.java
@@ -0,0 +1,47 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeActionSheetManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ActionSheetManager";
+
+  public NativeActionSheetManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void showActionSheetWithOptions(ReadableMap options, Callback callback);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void showShareActionSheetWithOptions(ReadableMap options, Callback failureCallback, Callback successCallback);
+
+  @ReactMethod
+  @DoNotStrip
+  public void dismissActionSheet() {}
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAlertManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAlertManagerSpec.java
new file mode 100644
index 0000000..70228d0
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAlertManagerSpec.java
@@ -0,0 +1,39 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeAlertManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "AlertManager";
+
+  public NativeAlertManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void alertWithArgs(ReadableMap args, Callback callback);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAnimatedModuleSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAnimatedModuleSpec.java
new file mode 100644
index 0000000..a3eb0a6
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAnimatedModuleSpec.java
@@ -0,0 +1,132 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeAnimatedModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "NativeAnimatedModule";
+
+  public NativeAnimatedModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void startOperationBatch();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void finishOperationBatch();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void createAnimatedNode(double tag, ReadableMap config);
+
+  @ReactMethod
+  @DoNotStrip
+  public void updateAnimatedNodeConfig(double tag, ReadableMap config) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getValue(double tag, Callback saveValueCallback);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void startListeningToAnimatedNodeValue(double tag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void stopListeningToAnimatedNodeValue(double tag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void connectAnimatedNodes(double parentTag, double childTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void disconnectAnimatedNodes(double parentTag, double childTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void startAnimatingNode(double animationId, double nodeTag, ReadableMap config, Callback endCallback);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void stopAnimation(double animationId);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setAnimatedNodeValue(double nodeTag, double value);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setAnimatedNodeOffset(double nodeTag, double offset);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void flattenAnimatedNodeOffset(double nodeTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void extractAnimatedNodeOffset(double nodeTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void connectAnimatedNodeToView(double nodeTag, double viewTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void disconnectAnimatedNodeFromView(double nodeTag, double viewTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void restoreDefaultValues(double nodeTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void dropAnimatedNode(double tag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addAnimatedEventToView(double viewTag, String eventName, ReadableMap eventMapping);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeAnimatedEventFromView(double viewTag, String eventName, double animatedNodeTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+
+  @ReactMethod
+  @DoNotStrip
+  public void queueAndExecuteBatchedOperations(ReadableArray operationsAndArgs) {}
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAnimatedTurboModuleSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAnimatedTurboModuleSpec.java
new file mode 100644
index 0000000..237115a
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAnimatedTurboModuleSpec.java
@@ -0,0 +1,132 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeAnimatedTurboModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "NativeAnimatedTurboModule";
+
+  public NativeAnimatedTurboModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void startOperationBatch();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void finishOperationBatch();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void createAnimatedNode(double tag, ReadableMap config);
+
+  @ReactMethod
+  @DoNotStrip
+  public void updateAnimatedNodeConfig(double tag, ReadableMap config) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getValue(double tag, Callback saveValueCallback);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void startListeningToAnimatedNodeValue(double tag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void stopListeningToAnimatedNodeValue(double tag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void connectAnimatedNodes(double parentTag, double childTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void disconnectAnimatedNodes(double parentTag, double childTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void startAnimatingNode(double animationId, double nodeTag, ReadableMap config, Callback endCallback);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void stopAnimation(double animationId);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setAnimatedNodeValue(double nodeTag, double value);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setAnimatedNodeOffset(double nodeTag, double offset);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void flattenAnimatedNodeOffset(double nodeTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void extractAnimatedNodeOffset(double nodeTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void connectAnimatedNodeToView(double nodeTag, double viewTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void disconnectAnimatedNodeFromView(double nodeTag, double viewTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void restoreDefaultValues(double nodeTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void dropAnimatedNode(double tag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addAnimatedEventToView(double viewTag, String eventName, ReadableMap eventMapping);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeAnimatedEventFromView(double viewTag, String eventName, double animatedNodeTag);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+
+  @ReactMethod
+  @DoNotStrip
+  public void queueAndExecuteBatchedOperations(ReadableArray operationsAndArgs) {}
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAppStateSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAppStateSpec.java
new file mode 100644
index 0000000..e0e0371
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAppStateSpec.java
@@ -0,0 +1,78 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeAppStateSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "AppState";
+
+  public NativeAppStateSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "initialAppState"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>();
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getCurrentAppState(Callback success, Callback error);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAppearanceSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAppearanceSpec.java
new file mode 100644
index 0000000..bc19323
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeAppearanceSpec.java
@@ -0,0 +1,50 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeAppearanceSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "Appearance";
+
+  public NativeAppearanceSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod(isBlockingSynchronousMethod = true)
+  @DoNotStrip
+  public abstract @Nullable String getColorScheme();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setColorScheme(String colorScheme);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeBlobModuleSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeBlobModuleSpec.java
new file mode 100644
index 0000000..6c3494c
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeBlobModuleSpec.java
@@ -0,0 +1,92 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeBlobModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "BlobModule";
+
+  public NativeBlobModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>();
+      Set<String> optionalFlowConstants = new HashSet<>(Arrays.asList(
+          "BLOB_URI_HOST",
+          "BLOB_URI_SCHEME"
+      ));
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addNetworkingHandler();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addWebSocketHandler(double id);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeWebSocketHandler(double id);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void sendOverSocket(ReadableMap blob, double socketID);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void createFromParts(ReadableArray parts, String withId);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void release(String blobId);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeBugReportingSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeBugReportingSpec.java
new file mode 100644
index 0000000..304b6c7
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeBugReportingSpec.java
@@ -0,0 +1,42 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeBugReportingSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "BugReporting";
+
+  public NativeBugReportingSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void startReportAProblemFlow();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setExtraData(ReadableMap extraData, ReadableMap extraFiles);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeClipboardSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeClipboardSpec.java
new file mode 100644
index 0000000..30348e4
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeClipboardSpec.java
@@ -0,0 +1,42 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeClipboardSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "Clipboard";
+
+  public NativeClipboardSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getString(Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setString(String content);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevLoadingViewSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevLoadingViewSpec.java
new file mode 100644
index 0000000..f957c39
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevLoadingViewSpec.java
@@ -0,0 +1,42 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeDevLoadingViewSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "DevLoadingView";
+
+  public NativeDevLoadingViewSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void showMessage(String message, @Nullable Double withColor, @Nullable Double withBackgroundColor);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void hide();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevMenuSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevMenuSpec.java
new file mode 100644
index 0000000..28e94a6
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevMenuSpec.java
@@ -0,0 +1,49 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeDevMenuSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "DevMenu";
+
+  public NativeDevMenuSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void show();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void reload();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setProfilingEnabled(boolean enabled);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setHotLoadingEnabled(boolean enabled);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevSettingsSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevSettingsSpec.java
new file mode 100644
index 0000000..b6f9b9a
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDevSettingsSpec.java
@@ -0,0 +1,77 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeDevSettingsSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "DevSettings";
+
+  public NativeDevSettingsSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void reload();
+
+  @ReactMethod
+  @DoNotStrip
+  public void reloadWithReason(String reason) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public void onFastRefresh() {}
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setHotLoadingEnabled(boolean isHotLoadingEnabled);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setProfilingEnabled(boolean isProfilingEnabled);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void toggleElementInspector();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addMenuItem(String title);
+
+  @ReactMethod
+  @DoNotStrip
+  public void openDebugger() {}
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setIsShakeToShowDevMenuEnabled(boolean enabled);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDeviceEventManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDeviceEventManagerSpec.java
new file mode 100644
index 0000000..09e1096
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDeviceEventManagerSpec.java
@@ -0,0 +1,37 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeDeviceEventManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "DeviceEventManager";
+
+  public NativeDeviceEventManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void invokeDefaultBackPressHandler();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDeviceInfoSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDeviceInfoSpec.java
new file mode 100644
index 0000000..59ecae3
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDeviceInfoSpec.java
@@ -0,0 +1,67 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeDeviceInfoSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "DeviceInfo";
+
+  public NativeDeviceInfoSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "Dimensions"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>(Arrays.asList(
+          "isIPhoneX_deprecated"
+      ));
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDialogManagerAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDialogManagerAndroidSpec.java
new file mode 100644
index 0000000..88c3e44
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeDialogManagerAndroidSpec.java
@@ -0,0 +1,75 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeDialogManagerAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "DialogManagerAndroid";
+
+  public NativeDialogManagerAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "buttonClicked",
+          "buttonNegative",
+          "buttonNeutral",
+          "buttonPositive",
+          "dismissed"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>();
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void showAlert(ReadableMap config, Callback onError, Callback onAction);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeExceptionsManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeExceptionsManagerSpec.java
new file mode 100644
index 0000000..5008089
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeExceptionsManagerSpec.java
@@ -0,0 +1,51 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeExceptionsManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ExceptionsManager";
+
+  public NativeExceptionsManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void reportFatalException(String message, ReadableArray stack, double exceptionId);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void reportSoftException(String message, ReadableArray stack, double exceptionId);
+
+  @ReactMethod
+  @DoNotStrip
+  public void reportException(ReadableMap data) {}
+
+  @ReactMethod
+  @DoNotStrip
+  public void dismissRedbox() {}
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeFileReaderModuleSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeFileReaderModuleSpec.java
new file mode 100644
index 0000000..3c9b385
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeFileReaderModuleSpec.java
@@ -0,0 +1,43 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeFileReaderModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "FileReaderModule";
+
+  public NativeFileReaderModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void readAsDataURL(ReadableMap data, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void readAsText(ReadableMap data, String encoding, Promise promise);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeFrameRateLoggerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeFrameRateLoggerSpec.java
new file mode 100644
index 0000000..4e658c7
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeFrameRateLoggerSpec.java
@@ -0,0 +1,50 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeFrameRateLoggerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "FrameRateLogger";
+
+  public NativeFrameRateLoggerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setGlobalOptions(ReadableMap options);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setContext(String context);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void beginScroll();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void endScroll();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeHeadlessJsTaskSupportSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeHeadlessJsTaskSupportSpec.java
new file mode 100644
index 0000000..d4c2631
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeHeadlessJsTaskSupportSpec.java
@@ -0,0 +1,42 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeHeadlessJsTaskSupportSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "HeadlessJsTaskSupport";
+
+  public NativeHeadlessJsTaskSupportSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void notifyTaskFinished(double taskId);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void notifyTaskRetry(double taskId, Promise promise);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeI18nManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeI18nManagerSpec.java
new file mode 100644
index 0000000..7d514f5
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeI18nManagerSpec.java
@@ -0,0 +1,80 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeI18nManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "I18nManager";
+
+  public NativeI18nManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "doLeftAndRightSwapInRTL",
+          "isRTL"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>(Arrays.asList(
+          "localeIdentifier"
+      ));
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void allowRTL(boolean allowRTL);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void forceRTL(boolean forceRTL);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void swapLeftAndRightInRTL(boolean flipStyles);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageEditorSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageEditorSpec.java
new file mode 100644
index 0000000..9d3c1f3
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageEditorSpec.java
@@ -0,0 +1,39 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeImageEditorSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ImageEditingManager";
+
+  public NativeImageEditorSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void cropImage(String uri, ReadableMap cropData, Callback successCallback, Callback errorCallback);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageLoaderAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageLoaderAndroidSpec.java
new file mode 100644
index 0000000..dc106ef
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageLoaderAndroidSpec.java
@@ -0,0 +1,56 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeImageLoaderAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ImageLoader";
+
+  public NativeImageLoaderAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void abortRequest(double requestId);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getSize(String uri, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getSizeWithHeaders(String uri, ReadableMap headers, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void prefetchImage(String uri, double requestId, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void queryCache(ReadableArray uris, Promise promise);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageStoreAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageStoreAndroidSpec.java
new file mode 100644
index 0000000..26ef36a
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeImageStoreAndroidSpec.java
@@ -0,0 +1,38 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeImageStoreAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ImageStoreManager";
+
+  public NativeImageStoreAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getBase64ForTag(String uri, Callback successCallback, Callback errorCallback);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeIntentAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeIntentAndroidSpec.java
new file mode 100644
index 0000000..2d8cdbc
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeIntentAndroidSpec.java
@@ -0,0 +1,56 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeIntentAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "IntentAndroid";
+
+  public NativeIntentAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getInitialURL(Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void canOpenURL(String url, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void openURL(String url, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void openSettings(Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void sendIntent(String action, @Nullable ReadableArray extras, Promise promise);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeJSCHeapCaptureSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeJSCHeapCaptureSpec.java
new file mode 100644
index 0000000..43cd22e
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeJSCHeapCaptureSpec.java
@@ -0,0 +1,38 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeJSCHeapCaptureSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "JSCHeapCapture";
+
+  public NativeJSCHeapCaptureSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void captureComplete(String path, @Nullable String error);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeKeyboardObserverSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeKeyboardObserverSpec.java
new file mode 100644
index 0000000..f310007
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeKeyboardObserverSpec.java
@@ -0,0 +1,41 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeKeyboardObserverSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "KeyboardObserver";
+
+  public NativeKeyboardObserverSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeLinkingManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeLinkingManagerSpec.java
new file mode 100644
index 0000000..011c3cc
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeLinkingManagerSpec.java
@@ -0,0 +1,58 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeLinkingManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "LinkingManager";
+
+  public NativeLinkingManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void getInitialURL(Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void canOpenURL(String url, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void openURL(String url, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void openSettings(Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeLogBoxSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeLogBoxSpec.java
new file mode 100644
index 0000000..553641b
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeLogBoxSpec.java
@@ -0,0 +1,41 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeLogBoxSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "LogBox";
+
+  public NativeLogBoxSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void show();
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void hide();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeModalManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeModalManagerSpec.java
new file mode 100644
index 0000000..a857ba7
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeModalManagerSpec.java
@@ -0,0 +1,41 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeModalManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ModalManager";
+
+  public NativeModalManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeNetworkingAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeNetworkingAndroidSpec.java
new file mode 100644
index 0000000..ffaaeb1
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeNetworkingAndroidSpec.java
@@ -0,0 +1,56 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeNetworkingAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "Networking";
+
+  public NativeNetworkingAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void sendRequest(String method, String url, double requestId, ReadableArray headers, ReadableMap data, String responseType, boolean useIncrementalUpdates, double timeout, boolean withCredentials);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void abortRequest(double requestId);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void clearCookies(Callback callback);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativePermissionsAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativePermissionsAndroidSpec.java
new file mode 100644
index 0000000..c9c75bc
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativePermissionsAndroidSpec.java
@@ -0,0 +1,51 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativePermissionsAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "PermissionsAndroid";
+
+  public NativePermissionsAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void checkPermission(String permission, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void requestPermission(String permission, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void shouldShowRequestPermissionRationale(String permission, Promise promise);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void requestMultiplePermissions(ReadableArray permissions, Promise promise);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativePlatformConstantsAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativePlatformConstantsAndroidSpec.java
new file mode 100644
index 0000000..f189daf
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativePlatformConstantsAndroidSpec.java
@@ -0,0 +1,81 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativePlatformConstantsAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "PlatformConstants";
+
+  public NativePlatformConstantsAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "Brand",
+          "Fingerprint",
+          "Manufacturer",
+          "Model",
+          "Release",
+          "Serial",
+          "Version",
+          "isTesting",
+          "reactNativeVersion",
+          "uiMode"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>(Arrays.asList(
+          "ServerHost",
+          "isDisableAnimations"
+      ));
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+
+  @ReactMethod(isBlockingSynchronousMethod = true)
+  @DoNotStrip
+  public abstract String getAndroidID();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeReactDevToolsRuntimeSettingsModuleSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeReactDevToolsRuntimeSettingsModuleSpec.java
new file mode 100644
index 0000000..ca6fb85
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeReactDevToolsRuntimeSettingsModuleSpec.java
@@ -0,0 +1,43 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.bridge.WritableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeReactDevToolsRuntimeSettingsModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ReactDevToolsRuntimeSettingsModule";
+
+  public NativeReactDevToolsRuntimeSettingsModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setReloadAndProfileConfig(ReadableMap config);
+
+  @ReactMethod(isBlockingSynchronousMethod = true)
+  @DoNotStrip
+  public abstract WritableMap getReloadAndProfileConfig();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeReactDevToolsSettingsManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeReactDevToolsSettingsManagerSpec.java
new file mode 100644
index 0000000..9a238dd
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeReactDevToolsSettingsManagerSpec.java
@@ -0,0 +1,42 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeReactDevToolsSettingsManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ReactDevToolsSettingsManager";
+
+  public NativeReactDevToolsSettingsManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setGlobalHookSettings(String settings);
+
+  @ReactMethod(isBlockingSynchronousMethod = true)
+  @DoNotStrip
+  public abstract @Nullable String getGlobalHookSettings();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeRedBoxSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeRedBoxSpec.java
new file mode 100644
index 0000000..f1f9c72
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeRedBoxSpec.java
@@ -0,0 +1,42 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeRedBoxSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "RedBox";
+
+  public NativeRedBoxSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setExtraData(ReadableMap extraData, String forIdentifier);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void dismiss();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSegmentFetcherSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSegmentFetcherSpec.java
new file mode 100644
index 0000000..dcbe969
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSegmentFetcherSpec.java
@@ -0,0 +1,43 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Callback;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeSegmentFetcherSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "SegmentFetcher";
+
+  public NativeSegmentFetcherSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void fetchSegment(double segmentId, ReadableMap options, Callback callback);
+
+  @ReactMethod
+  @DoNotStrip
+  public void getSegment(double segmentId, ReadableMap options, Callback callback) {}
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSettingsManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSettingsManagerSpec.java
new file mode 100644
index 0000000..800e1bb
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSettingsManagerSpec.java
@@ -0,0 +1,75 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeSettingsManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "SettingsManager";
+
+  public NativeSettingsManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "settings"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>();
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setValues(ReadableMap values);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void deleteValues(ReadableArray values);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeShareModuleSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeShareModuleSpec.java
new file mode 100644
index 0000000..1a0bcdc
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeShareModuleSpec.java
@@ -0,0 +1,40 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeShareModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ShareModule";
+
+  public NativeShareModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void share(ReadableMap content, @Nullable String dialogTitle, Promise promise);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSoundManagerSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSoundManagerSpec.java
new file mode 100644
index 0000000..32719ea
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSoundManagerSpec.java
@@ -0,0 +1,37 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeSoundManagerSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "SoundManager";
+
+  public NativeSoundManagerSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void playTouchSound();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSourceCodeSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSourceCodeSpec.java
new file mode 100644
index 0000000..d66b9e7
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeSourceCodeSpec.java
@@ -0,0 +1,65 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeSourceCodeSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "SourceCode";
+
+  public NativeSourceCodeSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "scriptURL"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>();
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeStatusBarManagerAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeStatusBarManagerAndroidSpec.java
new file mode 100644
index 0000000..d9b92cb
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeStatusBarManagerAndroidSpec.java
@@ -0,0 +1,82 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeStatusBarManagerAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "StatusBarManager";
+
+  public NativeStatusBarManagerAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "DEFAULT_BACKGROUND_COLOR",
+          "HEIGHT"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>();
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setColor(double color, boolean animated);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setTranslucent(boolean translucent);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setStyle(@Nullable String statusBarStyle);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setHidden(boolean hidden);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeTimingSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeTimingSpec.java
new file mode 100644
index 0000000..33ea75e
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeTimingSpec.java
@@ -0,0 +1,45 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeTimingSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "Timing";
+
+  public NativeTimingSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void createTimer(double callbackID, double duration, double jsSchedulingTime, boolean repeats);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void deleteTimer(double timerID);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void setSendIdleEvents(boolean sendIdleEvents);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeToastAndroidSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeToastAndroidSpec.java
new file mode 100644
index 0000000..38591b3
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeToastAndroidSpec.java
@@ -0,0 +1,81 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.common.build.ReactBuildConfig;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeToastAndroidSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "ToastAndroid";
+
+  public NativeToastAndroidSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  protected abstract Map<String, Object> getTypedExportedConstants();
+
+  @Override
+  @DoNotStrip
+  public final @Nullable Map<String, Object> getConstants() {
+    Map<String, Object> constants = getTypedExportedConstants();
+    if (ReactBuildConfig.DEBUG || ReactBuildConfig.IS_INTERNAL_BUILD) {
+      Set<String> obligatoryFlowConstants = new HashSet<>(Arrays.asList(
+          "BOTTOM",
+          "CENTER",
+          "LONG",
+          "SHORT",
+          "TOP"
+      ));
+      Set<String> optionalFlowConstants = new HashSet<>();
+      Set<String> undeclaredConstants = new HashSet<>(constants.keySet());
+      undeclaredConstants.removeAll(obligatoryFlowConstants);
+      undeclaredConstants.removeAll(optionalFlowConstants);
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module Flow doesn't declare constants: %s", undeclaredConstants));
+      }
+      undeclaredConstants = obligatoryFlowConstants;
+      undeclaredConstants.removeAll(constants.keySet());
+      if (!undeclaredConstants.isEmpty()) {
+        throw new IllegalStateException(String.format("Native Module doesn't fill in constants: %s", undeclaredConstants));
+      }
+    }
+    return constants;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void show(String message, double duration);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void showWithGravity(String message, double duration, double gravity);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void showWithGravityAndOffset(String message, double duration, double gravity, double xOffset, double yOffset);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeVibrationSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeVibrationSpec.java
new file mode 100644
index 0000000..5070d07
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeVibrationSpec.java
@@ -0,0 +1,46 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+
+public abstract class NativeVibrationSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "Vibration";
+
+  public NativeVibrationSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void vibrate(double pattern);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void vibrateByPattern(ReadableArray pattern, double repeat);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void cancel();
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeWebSocketModuleSpec.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeWebSocketModuleSpec.java
new file mode 100644
index 0000000..ca0af9c
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/fbreact/specs/NativeWebSocketModuleSpec.java
@@ -0,0 +1,64 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJavaSpec.js
+ *
+ * @nolint
+ */
+
+package com.facebook.fbreact.specs;
+
+import com.facebook.proguard.annotations.DoNotStrip;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.turbomodule.core.interfaces.TurboModule;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+public abstract class NativeWebSocketModuleSpec extends ReactContextBaseJavaModule implements TurboModule {
+  public static final String NAME = "WebSocketModule";
+
+  public NativeWebSocketModuleSpec(ReactApplicationContext reactContext) {
+    super(reactContext);
+  }
+
+  @Override
+  public @Nonnull String getName() {
+    return NAME;
+  }
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void connect(String url, @Nullable ReadableArray protocols, ReadableMap options, double socketID);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void send(String message, double forSocketID);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void sendBinary(String base64String, double forSocketID);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void ping(double socketID);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void close(double code, String reason, double socketID);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void addListener(String eventName);
+
+  @ReactMethod
+  @DoNotStrip
+  public abstract void removeListeners(double count);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ActivityIndicatorViewManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ActivityIndicatorViewManagerDelegate.java
new file mode 100644
index 0000000..000c059
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ActivityIndicatorViewManagerDelegate.java
@@ -0,0 +1,42 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ColorPropConverter;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class ActivityIndicatorViewManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & ActivityIndicatorViewManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public ActivityIndicatorViewManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "hidesWhenStopped":
+        mViewManager.setHidesWhenStopped(view, value == null ? true : (boolean) value);
+        break;
+      case "animating":
+        mViewManager.setAnimating(view, value == null ? true : (boolean) value);
+        break;
+      case "color":
+        mViewManager.setColor(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      case "size":
+        mViewManager.setSize(view, (String) value);
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ActivityIndicatorViewManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ActivityIndicatorViewManagerInterface.java
new file mode 100644
index 0000000..860fae8
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ActivityIndicatorViewManagerInterface.java
@@ -0,0 +1,21 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface ActivityIndicatorViewManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setHidesWhenStopped(T view, boolean value);
+  void setAnimating(T view, boolean value);
+  void setColor(T view, @Nullable Integer value);
+  void setSize(T view, @Nullable String value);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidDrawerLayoutManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidDrawerLayoutManagerDelegate.java
new file mode 100644
index 0000000..986e329
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidDrawerLayoutManagerDelegate.java
@@ -0,0 +1,61 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ColorPropConverter;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class AndroidDrawerLayoutManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & AndroidDrawerLayoutManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public AndroidDrawerLayoutManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "keyboardDismissMode":
+        mViewManager.setKeyboardDismissMode(view, (String) value);
+        break;
+      case "drawerBackgroundColor":
+        mViewManager.setDrawerBackgroundColor(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      case "drawerPosition":
+        mViewManager.setDrawerPosition(view, (String) value);
+        break;
+      case "drawerWidth":
+        mViewManager.setDrawerWidth(view, value == null ? null : ((Double) value).floatValue());
+        break;
+      case "drawerLockMode":
+        mViewManager.setDrawerLockMode(view, (String) value);
+        break;
+      case "statusBarBackgroundColor":
+        mViewManager.setStatusBarBackgroundColor(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+
+  @Override
+  public void receiveCommand(T view, String commandName, @Nullable ReadableArray args) {
+    switch (commandName) {
+      case "openDrawer":
+        mViewManager.openDrawer(view);
+        break;
+      case "closeDrawer":
+        mViewManager.closeDrawer(view);
+        break;
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidDrawerLayoutManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidDrawerLayoutManagerInterface.java
new file mode 100644
index 0000000..84dc326
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidDrawerLayoutManagerInterface.java
@@ -0,0 +1,25 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface AndroidDrawerLayoutManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setKeyboardDismissMode(T view, @Nullable String value);
+  void setDrawerBackgroundColor(T view, @Nullable Integer value);
+  void setDrawerPosition(T view, @Nullable String value);
+  void setDrawerWidth(T view, @Nullable Float value);
+  void setDrawerLockMode(T view, @Nullable String value);
+  void setStatusBarBackgroundColor(T view, @Nullable Integer value);
+  void openDrawer(T view);
+  void closeDrawer(T view);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidHorizontalScrollContentViewManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidHorizontalScrollContentViewManagerDelegate.java
new file mode 100644
index 0000000..53b28fd
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidHorizontalScrollContentViewManagerDelegate.java
@@ -0,0 +1,32 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class AndroidHorizontalScrollContentViewManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & AndroidHorizontalScrollContentViewManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public AndroidHorizontalScrollContentViewManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "removeClippedSubviews":
+        mViewManager.setRemoveClippedSubviews(view, value == null ? false : (boolean) value);
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidHorizontalScrollContentViewManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidHorizontalScrollContentViewManagerInterface.java
new file mode 100644
index 0000000..9fe7a34
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidHorizontalScrollContentViewManagerInterface.java
@@ -0,0 +1,17 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface AndroidHorizontalScrollContentViewManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setRemoveClippedSubviews(T view, boolean value);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidProgressBarManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidProgressBarManagerDelegate.java
new file mode 100644
index 0000000..426152d
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidProgressBarManagerDelegate.java
@@ -0,0 +1,51 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ColorPropConverter;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class AndroidProgressBarManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & AndroidProgressBarManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public AndroidProgressBarManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "styleAttr":
+        mViewManager.setStyleAttr(view, value == null ? null : (String) value);
+        break;
+      case "typeAttr":
+        mViewManager.setTypeAttr(view, value == null ? null : (String) value);
+        break;
+      case "indeterminate":
+        mViewManager.setIndeterminate(view, value == null ? false : (boolean) value);
+        break;
+      case "progress":
+        mViewManager.setProgress(view, value == null ? 0f : ((Double) value).doubleValue());
+        break;
+      case "animating":
+        mViewManager.setAnimating(view, value == null ? true : (boolean) value);
+        break;
+      case "color":
+        mViewManager.setColor(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      case "testID":
+        mViewManager.setTestID(view, value == null ? "" : (String) value);
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidProgressBarManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidProgressBarManagerInterface.java
new file mode 100644
index 0000000..f168d13
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidProgressBarManagerInterface.java
@@ -0,0 +1,24 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface AndroidProgressBarManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setStyleAttr(T view, @Nullable String value);
+  void setTypeAttr(T view, @Nullable String value);
+  void setIndeterminate(T view, boolean value);
+  void setProgress(T view, double value);
+  void setAnimating(T view, boolean value);
+  void setColor(T view, @Nullable Integer value);
+  void setTestID(T view, @Nullable String value);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwipeRefreshLayoutManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwipeRefreshLayoutManagerDelegate.java
new file mode 100644
index 0000000..25b8e0f
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwipeRefreshLayoutManagerDelegate.java
@@ -0,0 +1,58 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ColorPropConverter;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class AndroidSwipeRefreshLayoutManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & AndroidSwipeRefreshLayoutManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public AndroidSwipeRefreshLayoutManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "enabled":
+        mViewManager.setEnabled(view, value == null ? true : (boolean) value);
+        break;
+      case "colors":
+        mViewManager.setColors(view, (ReadableArray) value);
+        break;
+      case "progressBackgroundColor":
+        mViewManager.setProgressBackgroundColor(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      case "size":
+        mViewManager.setSize(view, (String) value);
+        break;
+      case "progressViewOffset":
+        mViewManager.setProgressViewOffset(view, value == null ? 0f : ((Double) value).floatValue());
+        break;
+      case "refreshing":
+        mViewManager.setRefreshing(view, value == null ? false : (boolean) value);
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+
+  @Override
+  public void receiveCommand(T view, String commandName, @Nullable ReadableArray args) {
+    switch (commandName) {
+      case "setNativeRefreshing":
+        mViewManager.setNativeRefreshing(view, args.getBoolean(0));
+        break;
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwipeRefreshLayoutManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwipeRefreshLayoutManagerInterface.java
new file mode 100644
index 0000000..ac06ba3
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwipeRefreshLayoutManagerInterface.java
@@ -0,0 +1,25 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface AndroidSwipeRefreshLayoutManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setEnabled(T view, boolean value);
+  void setColors(T view, @Nullable ReadableArray value);
+  void setProgressBackgroundColor(T view, @Nullable Integer value);
+  void setSize(T view, @Nullable String value);
+  void setProgressViewOffset(T view, float value);
+  void setRefreshing(T view, boolean value);
+  void setNativeRefreshing(T view, boolean value);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwitchManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwitchManagerDelegate.java
new file mode 100644
index 0000000..07cdecd
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwitchManagerDelegate.java
@@ -0,0 +1,67 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ColorPropConverter;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class AndroidSwitchManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & AndroidSwitchManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public AndroidSwitchManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "disabled":
+        mViewManager.setDisabled(view, value == null ? false : (boolean) value);
+        break;
+      case "enabled":
+        mViewManager.setEnabled(view, value == null ? true : (boolean) value);
+        break;
+      case "thumbColor":
+        mViewManager.setThumbColor(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      case "trackColorForFalse":
+        mViewManager.setTrackColorForFalse(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      case "trackColorForTrue":
+        mViewManager.setTrackColorForTrue(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      case "value":
+        mViewManager.setValue(view, value == null ? false : (boolean) value);
+        break;
+      case "on":
+        mViewManager.setOn(view, value == null ? false : (boolean) value);
+        break;
+      case "thumbTintColor":
+        mViewManager.setThumbTintColor(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      case "trackTintColor":
+        mViewManager.setTrackTintColor(view, ColorPropConverter.getColor(value, view.getContext()));
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+
+  @Override
+  public void receiveCommand(T view, String commandName, @Nullable ReadableArray args) {
+    switch (commandName) {
+      case "setNativeValue":
+        mViewManager.setNativeValue(view, args.getBoolean(0));
+        break;
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwitchManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwitchManagerInterface.java
new file mode 100644
index 0000000..0c390d7
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/AndroidSwitchManagerInterface.java
@@ -0,0 +1,27 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface AndroidSwitchManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setDisabled(T view, boolean value);
+  void setEnabled(T view, boolean value);
+  void setThumbColor(T view, @Nullable Integer value);
+  void setTrackColorForFalse(T view, @Nullable Integer value);
+  void setTrackColorForTrue(T view, @Nullable Integer value);
+  void setValue(T view, boolean value);
+  void setOn(T view, boolean value);
+  void setThumbTintColor(T view, @Nullable Integer value);
+  void setTrackTintColor(T view, @Nullable Integer value);
+  void setNativeValue(T view, boolean value);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/DebuggingOverlayManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/DebuggingOverlayManagerDelegate.java
new file mode 100644
index 0000000..e3f23a9
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/DebuggingOverlayManagerDelegate.java
@@ -0,0 +1,42 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class DebuggingOverlayManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & DebuggingOverlayManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public DebuggingOverlayManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    super.setProperty(view, propName, value);
+  }
+
+  @Override
+  public void receiveCommand(T view, String commandName, @Nullable ReadableArray args) {
+    switch (commandName) {
+      case "highlightTraceUpdates":
+        mViewManager.highlightTraceUpdates(view, args.getArray(0));
+        break;
+      case "highlightElements":
+        mViewManager.highlightElements(view, args.getArray(0));
+        break;
+      case "clearElementsHighlights":
+        mViewManager.clearElementsHighlights(view);
+        break;
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/DebuggingOverlayManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/DebuggingOverlayManagerInterface.java
new file mode 100644
index 0000000..ae25116
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/DebuggingOverlayManagerInterface.java
@@ -0,0 +1,21 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface DebuggingOverlayManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  // No props
+  void highlightTraceUpdates(T view, ReadableArray updates);
+  void highlightElements(T view, ReadableArray elements);
+  void clearElementsHighlights(T view);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ModalHostViewManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ModalHostViewManagerDelegate.java
new file mode 100644
index 0000000..8375f23
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ModalHostViewManagerDelegate.java
@@ -0,0 +1,60 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class ModalHostViewManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & ModalHostViewManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public ModalHostViewManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "animationType":
+        mViewManager.setAnimationType(view, (String) value);
+        break;
+      case "presentationStyle":
+        mViewManager.setPresentationStyle(view, (String) value);
+        break;
+      case "transparent":
+        mViewManager.setTransparent(view, value == null ? false : (boolean) value);
+        break;
+      case "statusBarTranslucent":
+        mViewManager.setStatusBarTranslucent(view, value == null ? false : (boolean) value);
+        break;
+      case "navigationBarTranslucent":
+        mViewManager.setNavigationBarTranslucent(view, value == null ? false : (boolean) value);
+        break;
+      case "hardwareAccelerated":
+        mViewManager.setHardwareAccelerated(view, value == null ? false : (boolean) value);
+        break;
+      case "visible":
+        mViewManager.setVisible(view, value == null ? false : (boolean) value);
+        break;
+      case "animated":
+        mViewManager.setAnimated(view, value == null ? false : (boolean) value);
+        break;
+      case "supportedOrientations":
+        mViewManager.setSupportedOrientations(view, (ReadableArray) value);
+        break;
+      case "identifier":
+        mViewManager.setIdentifier(view, value == null ? 0 : ((Double) value).intValue());
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ModalHostViewManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ModalHostViewManagerInterface.java
new file mode 100644
index 0000000..4b524fb
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/ModalHostViewManagerInterface.java
@@ -0,0 +1,28 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface ModalHostViewManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setAnimationType(T view, @Nullable String value);
+  void setPresentationStyle(T view, @Nullable String value);
+  void setTransparent(T view, boolean value);
+  void setStatusBarTranslucent(T view, boolean value);
+  void setNavigationBarTranslucent(T view, boolean value);
+  void setHardwareAccelerated(T view, boolean value);
+  void setVisible(T view, boolean value);
+  void setAnimated(T view, boolean value);
+  void setSupportedOrientations(T view, @Nullable ReadableArray value);
+  void setIdentifier(T view, int value);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/SafeAreaViewManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/SafeAreaViewManagerDelegate.java
new file mode 100644
index 0000000..cb33744
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/SafeAreaViewManagerDelegate.java
@@ -0,0 +1,26 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class SafeAreaViewManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & SafeAreaViewManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public SafeAreaViewManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    super.setProperty(view, propName, value);
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/SafeAreaViewManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/SafeAreaViewManagerInterface.java
new file mode 100644
index 0000000..848d59f
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/SafeAreaViewManagerInterface.java
@@ -0,0 +1,17 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface SafeAreaViewManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  // No props
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/UnimplementedNativeViewManagerDelegate.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/UnimplementedNativeViewManagerDelegate.java
new file mode 100644
index 0000000..d4b99d1
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/UnimplementedNativeViewManagerDelegate.java
@@ -0,0 +1,32 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaDelegate.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.BaseViewManager;
+import com.facebook.react.uimanager.BaseViewManagerDelegate;
+import com.facebook.react.uimanager.LayoutShadowNode;
+
+public class UnimplementedNativeViewManagerDelegate<T extends View, U extends BaseViewManager<T, ? extends LayoutShadowNode> & UnimplementedNativeViewManagerInterface<T>> extends BaseViewManagerDelegate<T, U> {
+  public UnimplementedNativeViewManagerDelegate(U viewManager) {
+    super(viewManager);
+  }
+  @Override
+  public void setProperty(T view, String propName, @Nullable Object value) {
+    switch (propName) {
+      case "name":
+        mViewManager.setName(view, value == null ? "" : (String) value);
+        break;
+      default:
+        super.setProperty(view, propName, value);
+    }
+  }
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/UnimplementedNativeViewManagerInterface.java b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/UnimplementedNativeViewManagerInterface.java
new file mode 100644
index 0000000..c866563
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/java/com/facebook/react/viewmanagers/UnimplementedNativeViewManagerInterface.java
@@ -0,0 +1,18 @@
+/**
+* This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+*
+* Do not edit this file as changes may cause incorrect behavior and will be lost
+* once the code is regenerated.
+*
+* @generated by codegen project: GeneratePropsJavaInterface.js
+*/
+
+package com.facebook.react.viewmanagers;
+
+import android.view.View;
+import androidx.annotation.Nullable;
+import com.facebook.react.uimanager.ViewManagerWithGeneratedInterface;
+
+public interface UnimplementedNativeViewManagerInterface<T extends View> extends ViewManagerWithGeneratedInterface {
+  void setName(T view, @Nullable String value);
+}
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/CMakeLists.txt b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/CMakeLists.txt
new file mode 100644
index 0000000..68c3019
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/CMakeLists.txt
@@ -0,0 +1,36 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# This source code is licensed under the MIT license found in the
+# LICENSE file in the root directory of this source tree.
+
+cmake_minimum_required(VERSION 3.13)
+set(CMAKE_VERBOSE_MAKEFILE on)
+
+file(GLOB react_codegen_SRCS CONFIGURE_DEPENDS *.cpp react/renderer/components/FBReactNativeSpec/*.cpp)
+
+add_library(
+  react_codegen_FBReactNativeSpec
+  OBJECT
+  ${react_codegen_SRCS}
+)
+
+target_include_directories(react_codegen_FBReactNativeSpec PUBLIC . react/renderer/components/FBReactNativeSpec)
+
+target_link_libraries(
+  react_codegen_FBReactNativeSpec
+  fbjni
+  jsi
+  # We need to link different libraries based on whether we are building rncore or not, that's necessary
+  # because we want to break a circular dependency between react_codegen_rncore and reactnative
+  reactnative
+)
+
+target_compile_options(
+  react_codegen_FBReactNativeSpec
+  PRIVATE
+  -DLOG_TAG=\"ReactNative\"
+  -fexceptions
+  -frtti
+  -std=c++20
+  -Wall
+)
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/FBReactNativeSpec-generated.cpp b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/FBReactNativeSpec-generated.cpp
new file mode 100644
index 0000000..1894d53
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/FBReactNativeSpec-generated.cpp
@@ -0,0 +1,1522 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniCpp.js
+ */
+
+#include "FBReactNativeSpec.h"
+
+namespace facebook::react {
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_isReduceMotionEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "isReduceMotionEnabled", "(Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_isInvertColorsEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "isInvertColorsEnabled", "(Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_isHighTextContrastEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "isHighTextContrastEnabled", "(Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_isTouchExplorationEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "isTouchExplorationEnabled", "(Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_isAccessibilityServiceEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "isAccessibilityServiceEnabled", "(Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_setAccessibilityFocus(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setAccessibilityFocus", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_announceForAccessibility(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "announceForAccessibility", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_getRecommendedTimeoutMillis(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getRecommendedTimeoutMillis", "(DLcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityInfoSpecJSI_isGrayscaleEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "isGrayscaleEnabled", "(Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+NativeAccessibilityInfoSpecJSI::NativeAccessibilityInfoSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["isReduceMotionEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoSpecJSI_isReduceMotionEnabled};
+  methodMap_["isInvertColorsEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoSpecJSI_isInvertColorsEnabled};
+  methodMap_["isHighTextContrastEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoSpecJSI_isHighTextContrastEnabled};
+  methodMap_["isTouchExplorationEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoSpecJSI_isTouchExplorationEnabled};
+  methodMap_["isAccessibilityServiceEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoSpecJSI_isAccessibilityServiceEnabled};
+  methodMap_["setAccessibilityFocus"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoSpecJSI_setAccessibilityFocus};
+  methodMap_["announceForAccessibility"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoSpecJSI_announceForAccessibility};
+  methodMap_["getRecommendedTimeoutMillis"] = MethodMetadata {2, __hostFunction_NativeAccessibilityInfoSpecJSI_getRecommendedTimeoutMillis};
+  methodMap_["isGrayscaleEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoSpecJSI_isGrayscaleEnabled};
+}
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentBoldTextState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentBoldTextState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentGrayscaleState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentGrayscaleState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentInvertColorsState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentInvertColorsState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentReduceMotionState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentReduceMotionState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentDarkerSystemColorsState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentDarkerSystemColorsState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentPrefersCrossFadeTransitionsState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentPrefersCrossFadeTransitionsState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentReduceTransparencyState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentReduceTransparencyState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentVoiceOverState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentVoiceOverState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_setAccessibilityContentSizeMultipliers(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setAccessibilityContentSizeMultipliers", "(Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_setAccessibilityFocus(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setAccessibilityFocus", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_announceForAccessibility(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "announceForAccessibility", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAccessibilityManagerSpecJSI_announceForAccessibilityWithOptions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "announceForAccessibilityWithOptions", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+NativeAccessibilityManagerSpecJSI::NativeAccessibilityManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getCurrentBoldTextState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentBoldTextState};
+  methodMap_["getCurrentGrayscaleState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentGrayscaleState};
+  methodMap_["getCurrentInvertColorsState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentInvertColorsState};
+  methodMap_["getCurrentReduceMotionState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentReduceMotionState};
+  methodMap_["getCurrentDarkerSystemColorsState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentDarkerSystemColorsState};
+  methodMap_["getCurrentPrefersCrossFadeTransitionsState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentPrefersCrossFadeTransitionsState};
+  methodMap_["getCurrentReduceTransparencyState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentReduceTransparencyState};
+  methodMap_["getCurrentVoiceOverState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_getCurrentVoiceOverState};
+  methodMap_["setAccessibilityContentSizeMultipliers"] = MethodMetadata {1, __hostFunction_NativeAccessibilityManagerSpecJSI_setAccessibilityContentSizeMultipliers};
+  methodMap_["setAccessibilityFocus"] = MethodMetadata {1, __hostFunction_NativeAccessibilityManagerSpecJSI_setAccessibilityFocus};
+  methodMap_["announceForAccessibility"] = MethodMetadata {1, __hostFunction_NativeAccessibilityManagerSpecJSI_announceForAccessibility};
+  methodMap_["announceForAccessibilityWithOptions"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerSpecJSI_announceForAccessibilityWithOptions};
+}
+
+
+static facebook::jsi::Value __hostFunction_NativeActionSheetManagerSpecJSI_showActionSheetWithOptions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "showActionSheetWithOptions", "(Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeActionSheetManagerSpecJSI_showShareActionSheetWithOptions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "showShareActionSheetWithOptions", "(Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeActionSheetManagerSpecJSI_dismissActionSheet(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "dismissActionSheet", "()V", args, count, cachedMethodId);
+}
+
+NativeActionSheetManagerSpecJSI::NativeActionSheetManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["showActionSheetWithOptions"] = MethodMetadata {2, __hostFunction_NativeActionSheetManagerSpecJSI_showActionSheetWithOptions};
+  methodMap_["showShareActionSheetWithOptions"] = MethodMetadata {3, __hostFunction_NativeActionSheetManagerSpecJSI_showShareActionSheetWithOptions};
+  methodMap_["dismissActionSheet"] = MethodMetadata {0, __hostFunction_NativeActionSheetManagerSpecJSI_dismissActionSheet};
+}
+static facebook::jsi::Value __hostFunction_NativeAlertManagerSpecJSI_alertWithArgs(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "alertWithArgs", "(Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+NativeAlertManagerSpecJSI::NativeAlertManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["alertWithArgs"] = MethodMetadata {2, __hostFunction_NativeAlertManagerSpecJSI_alertWithArgs};
+}
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_startOperationBatch(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "startOperationBatch", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_finishOperationBatch(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "finishOperationBatch", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_createAnimatedNode(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "createAnimatedNode", "(DLcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_updateAnimatedNodeConfig(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "updateAnimatedNodeConfig", "(DLcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_getValue(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getValue", "(DLcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_startListeningToAnimatedNodeValue(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "startListeningToAnimatedNodeValue", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_stopListeningToAnimatedNodeValue(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "stopListeningToAnimatedNodeValue", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_connectAnimatedNodes(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "connectAnimatedNodes", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_disconnectAnimatedNodes(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "disconnectAnimatedNodes", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_startAnimatingNode(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "startAnimatingNode", "(DDLcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_stopAnimation(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "stopAnimation", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_setAnimatedNodeValue(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setAnimatedNodeValue", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_setAnimatedNodeOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setAnimatedNodeOffset", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_flattenAnimatedNodeOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "flattenAnimatedNodeOffset", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_extractAnimatedNodeOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "extractAnimatedNodeOffset", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_connectAnimatedNodeToView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "connectAnimatedNodeToView", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_disconnectAnimatedNodeFromView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "disconnectAnimatedNodeFromView", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_restoreDefaultValues(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "restoreDefaultValues", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_dropAnimatedNode(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "dropAnimatedNode", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_addAnimatedEventToView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addAnimatedEventToView", "(DLjava/lang/String;Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_removeAnimatedEventFromView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeAnimatedEventFromView", "(DLjava/lang/String;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedModuleSpecJSI_queueAndExecuteBatchedOperations(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "queueAndExecuteBatchedOperations", "(Lcom/facebook/react/bridge/ReadableArray;)V", args, count, cachedMethodId);
+}
+
+NativeAnimatedModuleSpecJSI::NativeAnimatedModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["startOperationBatch"] = MethodMetadata {0, __hostFunction_NativeAnimatedModuleSpecJSI_startOperationBatch};
+  methodMap_["finishOperationBatch"] = MethodMetadata {0, __hostFunction_NativeAnimatedModuleSpecJSI_finishOperationBatch};
+  methodMap_["createAnimatedNode"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_createAnimatedNode};
+  methodMap_["updateAnimatedNodeConfig"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_updateAnimatedNodeConfig};
+  methodMap_["getValue"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_getValue};
+  methodMap_["startListeningToAnimatedNodeValue"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_startListeningToAnimatedNodeValue};
+  methodMap_["stopListeningToAnimatedNodeValue"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_stopListeningToAnimatedNodeValue};
+  methodMap_["connectAnimatedNodes"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_connectAnimatedNodes};
+  methodMap_["disconnectAnimatedNodes"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_disconnectAnimatedNodes};
+  methodMap_["startAnimatingNode"] = MethodMetadata {4, __hostFunction_NativeAnimatedModuleSpecJSI_startAnimatingNode};
+  methodMap_["stopAnimation"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_stopAnimation};
+  methodMap_["setAnimatedNodeValue"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_setAnimatedNodeValue};
+  methodMap_["setAnimatedNodeOffset"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_setAnimatedNodeOffset};
+  methodMap_["flattenAnimatedNodeOffset"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_flattenAnimatedNodeOffset};
+  methodMap_["extractAnimatedNodeOffset"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_extractAnimatedNodeOffset};
+  methodMap_["connectAnimatedNodeToView"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_connectAnimatedNodeToView};
+  methodMap_["disconnectAnimatedNodeFromView"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleSpecJSI_disconnectAnimatedNodeFromView};
+  methodMap_["restoreDefaultValues"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_restoreDefaultValues};
+  methodMap_["dropAnimatedNode"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_dropAnimatedNode};
+  methodMap_["addAnimatedEventToView"] = MethodMetadata {3, __hostFunction_NativeAnimatedModuleSpecJSI_addAnimatedEventToView};
+  methodMap_["removeAnimatedEventFromView"] = MethodMetadata {3, __hostFunction_NativeAnimatedModuleSpecJSI_removeAnimatedEventFromView};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_removeListeners};
+  methodMap_["queueAndExecuteBatchedOperations"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleSpecJSI_queueAndExecuteBatchedOperations};
+}
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_startOperationBatch(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "startOperationBatch", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_finishOperationBatch(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "finishOperationBatch", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_createAnimatedNode(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "createAnimatedNode", "(DLcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_updateAnimatedNodeConfig(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "updateAnimatedNodeConfig", "(DLcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_getValue(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getValue", "(DLcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_startListeningToAnimatedNodeValue(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "startListeningToAnimatedNodeValue", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_stopListeningToAnimatedNodeValue(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "stopListeningToAnimatedNodeValue", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_connectAnimatedNodes(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "connectAnimatedNodes", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_disconnectAnimatedNodes(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "disconnectAnimatedNodes", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_startAnimatingNode(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "startAnimatingNode", "(DDLcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_stopAnimation(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "stopAnimation", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_setAnimatedNodeValue(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setAnimatedNodeValue", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_setAnimatedNodeOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setAnimatedNodeOffset", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_flattenAnimatedNodeOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "flattenAnimatedNodeOffset", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_extractAnimatedNodeOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "extractAnimatedNodeOffset", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_connectAnimatedNodeToView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "connectAnimatedNodeToView", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_disconnectAnimatedNodeFromView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "disconnectAnimatedNodeFromView", "(DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_restoreDefaultValues(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "restoreDefaultValues", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_dropAnimatedNode(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "dropAnimatedNode", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_addAnimatedEventToView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addAnimatedEventToView", "(DLjava/lang/String;Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_removeAnimatedEventFromView(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeAnimatedEventFromView", "(DLjava/lang/String;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAnimatedTurboModuleSpecJSI_queueAndExecuteBatchedOperations(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "queueAndExecuteBatchedOperations", "(Lcom/facebook/react/bridge/ReadableArray;)V", args, count, cachedMethodId);
+}
+
+NativeAnimatedTurboModuleSpecJSI::NativeAnimatedTurboModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["startOperationBatch"] = MethodMetadata {0, __hostFunction_NativeAnimatedTurboModuleSpecJSI_startOperationBatch};
+  methodMap_["finishOperationBatch"] = MethodMetadata {0, __hostFunction_NativeAnimatedTurboModuleSpecJSI_finishOperationBatch};
+  methodMap_["createAnimatedNode"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_createAnimatedNode};
+  methodMap_["updateAnimatedNodeConfig"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_updateAnimatedNodeConfig};
+  methodMap_["getValue"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_getValue};
+  methodMap_["startListeningToAnimatedNodeValue"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_startListeningToAnimatedNodeValue};
+  methodMap_["stopListeningToAnimatedNodeValue"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_stopListeningToAnimatedNodeValue};
+  methodMap_["connectAnimatedNodes"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_connectAnimatedNodes};
+  methodMap_["disconnectAnimatedNodes"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_disconnectAnimatedNodes};
+  methodMap_["startAnimatingNode"] = MethodMetadata {4, __hostFunction_NativeAnimatedTurboModuleSpecJSI_startAnimatingNode};
+  methodMap_["stopAnimation"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_stopAnimation};
+  methodMap_["setAnimatedNodeValue"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_setAnimatedNodeValue};
+  methodMap_["setAnimatedNodeOffset"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_setAnimatedNodeOffset};
+  methodMap_["flattenAnimatedNodeOffset"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_flattenAnimatedNodeOffset};
+  methodMap_["extractAnimatedNodeOffset"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_extractAnimatedNodeOffset};
+  methodMap_["connectAnimatedNodeToView"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_connectAnimatedNodeToView};
+  methodMap_["disconnectAnimatedNodeFromView"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleSpecJSI_disconnectAnimatedNodeFromView};
+  methodMap_["restoreDefaultValues"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_restoreDefaultValues};
+  methodMap_["dropAnimatedNode"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_dropAnimatedNode};
+  methodMap_["addAnimatedEventToView"] = MethodMetadata {3, __hostFunction_NativeAnimatedTurboModuleSpecJSI_addAnimatedEventToView};
+  methodMap_["removeAnimatedEventFromView"] = MethodMetadata {3, __hostFunction_NativeAnimatedTurboModuleSpecJSI_removeAnimatedEventFromView};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_removeListeners};
+  methodMap_["queueAndExecuteBatchedOperations"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleSpecJSI_queueAndExecuteBatchedOperations};
+}
+static facebook::jsi::Value __hostFunction_NativeAppStateSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAppStateSpecJSI_getCurrentAppState(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getCurrentAppState", "(Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAppStateSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAppStateSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+NativeAppStateSpecJSI::NativeAppStateSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeAppStateSpecJSI_getConstants};
+  methodMap_["getCurrentAppState"] = MethodMetadata {2, __hostFunction_NativeAppStateSpecJSI_getCurrentAppState};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeAppStateSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeAppStateSpecJSI_removeListeners};
+}
+static facebook::jsi::Value __hostFunction_NativeAppearanceSpecJSI_getColorScheme(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, StringKind, "getColorScheme", "()Ljava/lang/String;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAppearanceSpecJSI_setColorScheme(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setColorScheme", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAppearanceSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeAppearanceSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+NativeAppearanceSpecJSI::NativeAppearanceSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getColorScheme"] = MethodMetadata {0, __hostFunction_NativeAppearanceSpecJSI_getColorScheme};
+  methodMap_["setColorScheme"] = MethodMetadata {1, __hostFunction_NativeAppearanceSpecJSI_setColorScheme};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeAppearanceSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeAppearanceSpecJSI_removeListeners};
+}
+static facebook::jsi::Value __hostFunction_NativeBlobModuleSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeBlobModuleSpecJSI_addNetworkingHandler(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addNetworkingHandler", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeBlobModuleSpecJSI_addWebSocketHandler(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addWebSocketHandler", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeBlobModuleSpecJSI_removeWebSocketHandler(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeWebSocketHandler", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeBlobModuleSpecJSI_sendOverSocket(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "sendOverSocket", "(Lcom/facebook/react/bridge/ReadableMap;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeBlobModuleSpecJSI_createFromParts(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "createFromParts", "(Lcom/facebook/react/bridge/ReadableArray;Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeBlobModuleSpecJSI_release(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "release", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+NativeBlobModuleSpecJSI::NativeBlobModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeBlobModuleSpecJSI_getConstants};
+  methodMap_["addNetworkingHandler"] = MethodMetadata {0, __hostFunction_NativeBlobModuleSpecJSI_addNetworkingHandler};
+  methodMap_["addWebSocketHandler"] = MethodMetadata {1, __hostFunction_NativeBlobModuleSpecJSI_addWebSocketHandler};
+  methodMap_["removeWebSocketHandler"] = MethodMetadata {1, __hostFunction_NativeBlobModuleSpecJSI_removeWebSocketHandler};
+  methodMap_["sendOverSocket"] = MethodMetadata {2, __hostFunction_NativeBlobModuleSpecJSI_sendOverSocket};
+  methodMap_["createFromParts"] = MethodMetadata {2, __hostFunction_NativeBlobModuleSpecJSI_createFromParts};
+  methodMap_["release"] = MethodMetadata {1, __hostFunction_NativeBlobModuleSpecJSI_release};
+}
+static facebook::jsi::Value __hostFunction_NativeBugReportingSpecJSI_startReportAProblemFlow(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "startReportAProblemFlow", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeBugReportingSpecJSI_setExtraData(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setExtraData", "(Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+NativeBugReportingSpecJSI::NativeBugReportingSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["startReportAProblemFlow"] = MethodMetadata {0, __hostFunction_NativeBugReportingSpecJSI_startReportAProblemFlow};
+  methodMap_["setExtraData"] = MethodMetadata {2, __hostFunction_NativeBugReportingSpecJSI_setExtraData};
+}
+
+
+static facebook::jsi::Value __hostFunction_NativeClipboardSpecJSI_getString(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getString", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeClipboardSpecJSI_setString(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setString", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+NativeClipboardSpecJSI::NativeClipboardSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getString"] = MethodMetadata {0, __hostFunction_NativeClipboardSpecJSI_getString};
+  methodMap_["setString"] = MethodMetadata {1, __hostFunction_NativeClipboardSpecJSI_setString};
+}
+static facebook::jsi::Value __hostFunction_NativeDevLoadingViewSpecJSI_showMessage(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "showMessage", "(Ljava/lang/String;Ljava/lang/Double;Ljava/lang/Double;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevLoadingViewSpecJSI_hide(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "hide", "()V", args, count, cachedMethodId);
+}
+
+NativeDevLoadingViewSpecJSI::NativeDevLoadingViewSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["showMessage"] = MethodMetadata {3, __hostFunction_NativeDevLoadingViewSpecJSI_showMessage};
+  methodMap_["hide"] = MethodMetadata {0, __hostFunction_NativeDevLoadingViewSpecJSI_hide};
+}
+static facebook::jsi::Value __hostFunction_NativeDevMenuSpecJSI_show(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "show", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevMenuSpecJSI_reload(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "reload", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevMenuSpecJSI_setProfilingEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setProfilingEnabled", "(Z)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevMenuSpecJSI_setHotLoadingEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setHotLoadingEnabled", "(Z)V", args, count, cachedMethodId);
+}
+
+NativeDevMenuSpecJSI::NativeDevMenuSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["show"] = MethodMetadata {0, __hostFunction_NativeDevMenuSpecJSI_show};
+  methodMap_["reload"] = MethodMetadata {0, __hostFunction_NativeDevMenuSpecJSI_reload};
+  methodMap_["setProfilingEnabled"] = MethodMetadata {1, __hostFunction_NativeDevMenuSpecJSI_setProfilingEnabled};
+  methodMap_["setHotLoadingEnabled"] = MethodMetadata {1, __hostFunction_NativeDevMenuSpecJSI_setHotLoadingEnabled};
+}
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_reload(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "reload", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_reloadWithReason(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "reloadWithReason", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_onFastRefresh(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "onFastRefresh", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_setHotLoadingEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setHotLoadingEnabled", "(Z)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_setProfilingEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setProfilingEnabled", "(Z)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_toggleElementInspector(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "toggleElementInspector", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_addMenuItem(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addMenuItem", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_openDebugger(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "openDebugger", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDevSettingsSpecJSI_setIsShakeToShowDevMenuEnabled(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setIsShakeToShowDevMenuEnabled", "(Z)V", args, count, cachedMethodId);
+}
+
+NativeDevSettingsSpecJSI::NativeDevSettingsSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["reload"] = MethodMetadata {0, __hostFunction_NativeDevSettingsSpecJSI_reload};
+  methodMap_["reloadWithReason"] = MethodMetadata {1, __hostFunction_NativeDevSettingsSpecJSI_reloadWithReason};
+  methodMap_["onFastRefresh"] = MethodMetadata {0, __hostFunction_NativeDevSettingsSpecJSI_onFastRefresh};
+  methodMap_["setHotLoadingEnabled"] = MethodMetadata {1, __hostFunction_NativeDevSettingsSpecJSI_setHotLoadingEnabled};
+  methodMap_["setProfilingEnabled"] = MethodMetadata {1, __hostFunction_NativeDevSettingsSpecJSI_setProfilingEnabled};
+  methodMap_["toggleElementInspector"] = MethodMetadata {0, __hostFunction_NativeDevSettingsSpecJSI_toggleElementInspector};
+  methodMap_["addMenuItem"] = MethodMetadata {1, __hostFunction_NativeDevSettingsSpecJSI_addMenuItem};
+  methodMap_["openDebugger"] = MethodMetadata {0, __hostFunction_NativeDevSettingsSpecJSI_openDebugger};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeDevSettingsSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeDevSettingsSpecJSI_removeListeners};
+  methodMap_["setIsShakeToShowDevMenuEnabled"] = MethodMetadata {1, __hostFunction_NativeDevSettingsSpecJSI_setIsShakeToShowDevMenuEnabled};
+}
+static facebook::jsi::Value __hostFunction_NativeDeviceEventManagerSpecJSI_invokeDefaultBackPressHandler(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "invokeDefaultBackPressHandler", "()V", args, count, cachedMethodId);
+}
+
+NativeDeviceEventManagerSpecJSI::NativeDeviceEventManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["invokeDefaultBackPressHandler"] = MethodMetadata {0, __hostFunction_NativeDeviceEventManagerSpecJSI_invokeDefaultBackPressHandler};
+}
+static facebook::jsi::Value __hostFunction_NativeDeviceInfoSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+NativeDeviceInfoSpecJSI::NativeDeviceInfoSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeDeviceInfoSpecJSI_getConstants};
+}
+static facebook::jsi::Value __hostFunction_NativeDialogManagerAndroidSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeDialogManagerAndroidSpecJSI_showAlert(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "showAlert", "(Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+NativeDialogManagerAndroidSpecJSI::NativeDialogManagerAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeDialogManagerAndroidSpecJSI_getConstants};
+  methodMap_["showAlert"] = MethodMetadata {3, __hostFunction_NativeDialogManagerAndroidSpecJSI_showAlert};
+}
+static facebook::jsi::Value __hostFunction_NativeExceptionsManagerSpecJSI_reportFatalException(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "reportFatalException", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableArray;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeExceptionsManagerSpecJSI_reportSoftException(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "reportSoftException", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableArray;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeExceptionsManagerSpecJSI_reportException(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "reportException", "(Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeExceptionsManagerSpecJSI_dismissRedbox(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "dismissRedbox", "()V", args, count, cachedMethodId);
+}
+
+NativeExceptionsManagerSpecJSI::NativeExceptionsManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["reportFatalException"] = MethodMetadata {3, __hostFunction_NativeExceptionsManagerSpecJSI_reportFatalException};
+  methodMap_["reportSoftException"] = MethodMetadata {3, __hostFunction_NativeExceptionsManagerSpecJSI_reportSoftException};
+  methodMap_["reportException"] = MethodMetadata {1, __hostFunction_NativeExceptionsManagerSpecJSI_reportException};
+  methodMap_["dismissRedbox"] = MethodMetadata {0, __hostFunction_NativeExceptionsManagerSpecJSI_dismissRedbox};
+}
+static facebook::jsi::Value __hostFunction_NativeFileReaderModuleSpecJSI_readAsDataURL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "readAsDataURL", "(Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeFileReaderModuleSpecJSI_readAsText(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "readAsText", "(Lcom/facebook/react/bridge/ReadableMap;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeFileReaderModuleSpecJSI::NativeFileReaderModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["readAsDataURL"] = MethodMetadata {1, __hostFunction_NativeFileReaderModuleSpecJSI_readAsDataURL};
+  methodMap_["readAsText"] = MethodMetadata {2, __hostFunction_NativeFileReaderModuleSpecJSI_readAsText};
+}
+static facebook::jsi::Value __hostFunction_NativeFrameRateLoggerSpecJSI_setGlobalOptions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setGlobalOptions", "(Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeFrameRateLoggerSpecJSI_setContext(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setContext", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeFrameRateLoggerSpecJSI_beginScroll(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "beginScroll", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeFrameRateLoggerSpecJSI_endScroll(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "endScroll", "()V", args, count, cachedMethodId);
+}
+
+NativeFrameRateLoggerSpecJSI::NativeFrameRateLoggerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["setGlobalOptions"] = MethodMetadata {1, __hostFunction_NativeFrameRateLoggerSpecJSI_setGlobalOptions};
+  methodMap_["setContext"] = MethodMetadata {1, __hostFunction_NativeFrameRateLoggerSpecJSI_setContext};
+  methodMap_["beginScroll"] = MethodMetadata {0, __hostFunction_NativeFrameRateLoggerSpecJSI_beginScroll};
+  methodMap_["endScroll"] = MethodMetadata {0, __hostFunction_NativeFrameRateLoggerSpecJSI_endScroll};
+}
+static facebook::jsi::Value __hostFunction_NativeHeadlessJsTaskSupportSpecJSI_notifyTaskFinished(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "notifyTaskFinished", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeHeadlessJsTaskSupportSpecJSI_notifyTaskRetry(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "notifyTaskRetry", "(DLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeHeadlessJsTaskSupportSpecJSI::NativeHeadlessJsTaskSupportSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["notifyTaskFinished"] = MethodMetadata {1, __hostFunction_NativeHeadlessJsTaskSupportSpecJSI_notifyTaskFinished};
+  methodMap_["notifyTaskRetry"] = MethodMetadata {1, __hostFunction_NativeHeadlessJsTaskSupportSpecJSI_notifyTaskRetry};
+}
+static facebook::jsi::Value __hostFunction_NativeI18nManagerSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeI18nManagerSpecJSI_allowRTL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "allowRTL", "(Z)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeI18nManagerSpecJSI_forceRTL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "forceRTL", "(Z)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeI18nManagerSpecJSI_swapLeftAndRightInRTL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "swapLeftAndRightInRTL", "(Z)V", args, count, cachedMethodId);
+}
+
+NativeI18nManagerSpecJSI::NativeI18nManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeI18nManagerSpecJSI_getConstants};
+  methodMap_["allowRTL"] = MethodMetadata {1, __hostFunction_NativeI18nManagerSpecJSI_allowRTL};
+  methodMap_["forceRTL"] = MethodMetadata {1, __hostFunction_NativeI18nManagerSpecJSI_forceRTL};
+  methodMap_["swapLeftAndRightInRTL"] = MethodMetadata {1, __hostFunction_NativeI18nManagerSpecJSI_swapLeftAndRightInRTL};
+}
+
+
+static facebook::jsi::Value __hostFunction_NativeImageEditorSpecJSI_cropImage(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "cropImage", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+NativeImageEditorSpecJSI::NativeImageEditorSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["cropImage"] = MethodMetadata {4, __hostFunction_NativeImageEditorSpecJSI_cropImage};
+}
+static facebook::jsi::Value __hostFunction_NativeImageLoaderAndroidSpecJSI_abortRequest(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "abortRequest", "(D)V", args, count, cachedMethodId);
+}
+
+
+
+static facebook::jsi::Value __hostFunction_NativeImageLoaderAndroidSpecJSI_getSize(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getSize", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeImageLoaderAndroidSpecJSI_getSizeWithHeaders(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getSizeWithHeaders", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeImageLoaderAndroidSpecJSI_prefetchImage(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "prefetchImage", "(Ljava/lang/String;DLcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeImageLoaderAndroidSpecJSI_queryCache(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "queryCache", "(Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeImageLoaderAndroidSpecJSI::NativeImageLoaderAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["abortRequest"] = MethodMetadata {1, __hostFunction_NativeImageLoaderAndroidSpecJSI_abortRequest};
+  methodMap_["getSize"] = MethodMetadata {1, __hostFunction_NativeImageLoaderAndroidSpecJSI_getSize};
+  methodMap_["getSizeWithHeaders"] = MethodMetadata {2, __hostFunction_NativeImageLoaderAndroidSpecJSI_getSizeWithHeaders};
+  methodMap_["prefetchImage"] = MethodMetadata {2, __hostFunction_NativeImageLoaderAndroidSpecJSI_prefetchImage};
+  methodMap_["queryCache"] = MethodMetadata {1, __hostFunction_NativeImageLoaderAndroidSpecJSI_queryCache};
+}
+
+
+static facebook::jsi::Value __hostFunction_NativeImageStoreAndroidSpecJSI_getBase64ForTag(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getBase64ForTag", "(Ljava/lang/String;Lcom/facebook/react/bridge/Callback;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+NativeImageStoreAndroidSpecJSI::NativeImageStoreAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getBase64ForTag"] = MethodMetadata {3, __hostFunction_NativeImageStoreAndroidSpecJSI_getBase64ForTag};
+}
+static facebook::jsi::Value __hostFunction_NativeIntentAndroidSpecJSI_getInitialURL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getInitialURL", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeIntentAndroidSpecJSI_canOpenURL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "canOpenURL", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeIntentAndroidSpecJSI_openURL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "openURL", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeIntentAndroidSpecJSI_openSettings(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "openSettings", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeIntentAndroidSpecJSI_sendIntent(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "sendIntent", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeIntentAndroidSpecJSI::NativeIntentAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getInitialURL"] = MethodMetadata {0, __hostFunction_NativeIntentAndroidSpecJSI_getInitialURL};
+  methodMap_["canOpenURL"] = MethodMetadata {1, __hostFunction_NativeIntentAndroidSpecJSI_canOpenURL};
+  methodMap_["openURL"] = MethodMetadata {1, __hostFunction_NativeIntentAndroidSpecJSI_openURL};
+  methodMap_["openSettings"] = MethodMetadata {0, __hostFunction_NativeIntentAndroidSpecJSI_openSettings};
+  methodMap_["sendIntent"] = MethodMetadata {2, __hostFunction_NativeIntentAndroidSpecJSI_sendIntent};
+}
+static facebook::jsi::Value __hostFunction_NativeJSCHeapCaptureSpecJSI_captureComplete(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "captureComplete", "(Ljava/lang/String;Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+NativeJSCHeapCaptureSpecJSI::NativeJSCHeapCaptureSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["captureComplete"] = MethodMetadata {2, __hostFunction_NativeJSCHeapCaptureSpecJSI_captureComplete};
+}
+static facebook::jsi::Value __hostFunction_NativeKeyboardObserverSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeKeyboardObserverSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+NativeKeyboardObserverSpecJSI::NativeKeyboardObserverSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeKeyboardObserverSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeKeyboardObserverSpecJSI_removeListeners};
+}
+static facebook::jsi::Value __hostFunction_NativeLinkingManagerSpecJSI_getInitialURL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "getInitialURL", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeLinkingManagerSpecJSI_canOpenURL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "canOpenURL", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeLinkingManagerSpecJSI_openURL(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "openURL", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeLinkingManagerSpecJSI_openSettings(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "openSettings", "(Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeLinkingManagerSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeLinkingManagerSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+NativeLinkingManagerSpecJSI::NativeLinkingManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getInitialURL"] = MethodMetadata {0, __hostFunction_NativeLinkingManagerSpecJSI_getInitialURL};
+  methodMap_["canOpenURL"] = MethodMetadata {1, __hostFunction_NativeLinkingManagerSpecJSI_canOpenURL};
+  methodMap_["openURL"] = MethodMetadata {1, __hostFunction_NativeLinkingManagerSpecJSI_openURL};
+  methodMap_["openSettings"] = MethodMetadata {0, __hostFunction_NativeLinkingManagerSpecJSI_openSettings};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeLinkingManagerSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeLinkingManagerSpecJSI_removeListeners};
+}
+static facebook::jsi::Value __hostFunction_NativeLogBoxSpecJSI_show(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "show", "()V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeLogBoxSpecJSI_hide(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "hide", "()V", args, count, cachedMethodId);
+}
+
+NativeLogBoxSpecJSI::NativeLogBoxSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["show"] = MethodMetadata {0, __hostFunction_NativeLogBoxSpecJSI_show};
+  methodMap_["hide"] = MethodMetadata {0, __hostFunction_NativeLogBoxSpecJSI_hide};
+}
+static facebook::jsi::Value __hostFunction_NativeModalManagerSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeModalManagerSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+NativeModalManagerSpecJSI::NativeModalManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeModalManagerSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeModalManagerSpecJSI_removeListeners};
+}
+static facebook::jsi::Value __hostFunction_NativeNetworkingAndroidSpecJSI_sendRequest(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "sendRequest", "(Ljava/lang/String;Ljava/lang/String;DLcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableMap;Ljava/lang/String;ZDZ)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeNetworkingAndroidSpecJSI_abortRequest(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "abortRequest", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeNetworkingAndroidSpecJSI_clearCookies(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "clearCookies", "(Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeNetworkingAndroidSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeNetworkingAndroidSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+NativeNetworkingAndroidSpecJSI::NativeNetworkingAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["sendRequest"] = MethodMetadata {9, __hostFunction_NativeNetworkingAndroidSpecJSI_sendRequest};
+  methodMap_["abortRequest"] = MethodMetadata {1, __hostFunction_NativeNetworkingAndroidSpecJSI_abortRequest};
+  methodMap_["clearCookies"] = MethodMetadata {1, __hostFunction_NativeNetworkingAndroidSpecJSI_clearCookies};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeNetworkingAndroidSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeNetworkingAndroidSpecJSI_removeListeners};
+}
+static facebook::jsi::Value __hostFunction_NativePermissionsAndroidSpecJSI_checkPermission(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "checkPermission", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativePermissionsAndroidSpecJSI_requestPermission(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "requestPermission", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativePermissionsAndroidSpecJSI_shouldShowRequestPermissionRationale(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "shouldShowRequestPermissionRationale", "(Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativePermissionsAndroidSpecJSI_requestMultiplePermissions(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "requestMultiplePermissions", "(Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativePermissionsAndroidSpecJSI::NativePermissionsAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["checkPermission"] = MethodMetadata {1, __hostFunction_NativePermissionsAndroidSpecJSI_checkPermission};
+  methodMap_["requestPermission"] = MethodMetadata {1, __hostFunction_NativePermissionsAndroidSpecJSI_requestPermission};
+  methodMap_["shouldShowRequestPermissionRationale"] = MethodMetadata {1, __hostFunction_NativePermissionsAndroidSpecJSI_shouldShowRequestPermissionRationale};
+  methodMap_["requestMultiplePermissions"] = MethodMetadata {1, __hostFunction_NativePermissionsAndroidSpecJSI_requestMultiplePermissions};
+}
+static facebook::jsi::Value __hostFunction_NativePlatformConstantsAndroidSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativePlatformConstantsAndroidSpecJSI_getAndroidID(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, StringKind, "getAndroidID", "()Ljava/lang/String;", args, count, cachedMethodId);
+}
+
+NativePlatformConstantsAndroidSpecJSI::NativePlatformConstantsAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativePlatformConstantsAndroidSpecJSI_getConstants};
+  methodMap_["getAndroidID"] = MethodMetadata {0, __hostFunction_NativePlatformConstantsAndroidSpecJSI_getAndroidID};
+}
+static facebook::jsi::Value __hostFunction_NativeReactDevToolsRuntimeSettingsModuleSpecJSI_setReloadAndProfileConfig(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setReloadAndProfileConfig", "(Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeReactDevToolsRuntimeSettingsModuleSpecJSI_getReloadAndProfileConfig(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getReloadAndProfileConfig", "()Lcom/facebook/react/bridge/WritableMap;", args, count, cachedMethodId);
+}
+
+NativeReactDevToolsRuntimeSettingsModuleSpecJSI::NativeReactDevToolsRuntimeSettingsModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["setReloadAndProfileConfig"] = MethodMetadata {1, __hostFunction_NativeReactDevToolsRuntimeSettingsModuleSpecJSI_setReloadAndProfileConfig};
+  methodMap_["getReloadAndProfileConfig"] = MethodMetadata {0, __hostFunction_NativeReactDevToolsRuntimeSettingsModuleSpecJSI_getReloadAndProfileConfig};
+}
+static facebook::jsi::Value __hostFunction_NativeReactDevToolsSettingsManagerSpecJSI_setGlobalHookSettings(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setGlobalHookSettings", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeReactDevToolsSettingsManagerSpecJSI_getGlobalHookSettings(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, StringKind, "getGlobalHookSettings", "()Ljava/lang/String;", args, count, cachedMethodId);
+}
+
+NativeReactDevToolsSettingsManagerSpecJSI::NativeReactDevToolsSettingsManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["setGlobalHookSettings"] = MethodMetadata {1, __hostFunction_NativeReactDevToolsSettingsManagerSpecJSI_setGlobalHookSettings};
+  methodMap_["getGlobalHookSettings"] = MethodMetadata {0, __hostFunction_NativeReactDevToolsSettingsManagerSpecJSI_getGlobalHookSettings};
+}
+static facebook::jsi::Value __hostFunction_NativeRedBoxSpecJSI_setExtraData(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setExtraData", "(Lcom/facebook/react/bridge/ReadableMap;Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeRedBoxSpecJSI_dismiss(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "dismiss", "()V", args, count, cachedMethodId);
+}
+
+NativeRedBoxSpecJSI::NativeRedBoxSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["setExtraData"] = MethodMetadata {2, __hostFunction_NativeRedBoxSpecJSI_setExtraData};
+  methodMap_["dismiss"] = MethodMetadata {0, __hostFunction_NativeRedBoxSpecJSI_dismiss};
+}
+static facebook::jsi::Value __hostFunction_NativeSegmentFetcherSpecJSI_fetchSegment(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "fetchSegment", "(DLcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeSegmentFetcherSpecJSI_getSegment(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "getSegment", "(DLcom/facebook/react/bridge/ReadableMap;Lcom/facebook/react/bridge/Callback;)V", args, count, cachedMethodId);
+}
+
+NativeSegmentFetcherSpecJSI::NativeSegmentFetcherSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["fetchSegment"] = MethodMetadata {3, __hostFunction_NativeSegmentFetcherSpecJSI_fetchSegment};
+  methodMap_["getSegment"] = MethodMetadata {3, __hostFunction_NativeSegmentFetcherSpecJSI_getSegment};
+}
+static facebook::jsi::Value __hostFunction_NativeSettingsManagerSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeSettingsManagerSpecJSI_setValues(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setValues", "(Lcom/facebook/react/bridge/ReadableMap;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeSettingsManagerSpecJSI_deleteValues(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "deleteValues", "(Lcom/facebook/react/bridge/ReadableArray;)V", args, count, cachedMethodId);
+}
+
+NativeSettingsManagerSpecJSI::NativeSettingsManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeSettingsManagerSpecJSI_getConstants};
+  methodMap_["setValues"] = MethodMetadata {1, __hostFunction_NativeSettingsManagerSpecJSI_setValues};
+  methodMap_["deleteValues"] = MethodMetadata {1, __hostFunction_NativeSettingsManagerSpecJSI_deleteValues};
+}
+
+
+static facebook::jsi::Value __hostFunction_NativeShareModuleSpecJSI_share(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, PromiseKind, "share", "(Lcom/facebook/react/bridge/ReadableMap;Ljava/lang/String;Lcom/facebook/react/bridge/Promise;)V", args, count, cachedMethodId);
+}
+
+NativeShareModuleSpecJSI::NativeShareModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["share"] = MethodMetadata {2, __hostFunction_NativeShareModuleSpecJSI_share};
+}
+static facebook::jsi::Value __hostFunction_NativeSoundManagerSpecJSI_playTouchSound(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "playTouchSound", "()V", args, count, cachedMethodId);
+}
+
+NativeSoundManagerSpecJSI::NativeSoundManagerSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["playTouchSound"] = MethodMetadata {0, __hostFunction_NativeSoundManagerSpecJSI_playTouchSound};
+}
+static facebook::jsi::Value __hostFunction_NativeSourceCodeSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+NativeSourceCodeSpecJSI::NativeSourceCodeSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeSourceCodeSpecJSI_getConstants};
+}
+static facebook::jsi::Value __hostFunction_NativeStatusBarManagerAndroidSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeStatusBarManagerAndroidSpecJSI_setColor(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setColor", "(DZ)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeStatusBarManagerAndroidSpecJSI_setTranslucent(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setTranslucent", "(Z)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeStatusBarManagerAndroidSpecJSI_setStyle(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setStyle", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeStatusBarManagerAndroidSpecJSI_setHidden(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setHidden", "(Z)V", args, count, cachedMethodId);
+}
+
+NativeStatusBarManagerAndroidSpecJSI::NativeStatusBarManagerAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeStatusBarManagerAndroidSpecJSI_getConstants};
+  methodMap_["setColor"] = MethodMetadata {2, __hostFunction_NativeStatusBarManagerAndroidSpecJSI_setColor};
+  methodMap_["setTranslucent"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerAndroidSpecJSI_setTranslucent};
+  methodMap_["setStyle"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerAndroidSpecJSI_setStyle};
+  methodMap_["setHidden"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerAndroidSpecJSI_setHidden};
+}
+static facebook::jsi::Value __hostFunction_NativeTimingSpecJSI_createTimer(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "createTimer", "(DDDZ)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeTimingSpecJSI_deleteTimer(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "deleteTimer", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeTimingSpecJSI_setSendIdleEvents(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "setSendIdleEvents", "(Z)V", args, count, cachedMethodId);
+}
+
+NativeTimingSpecJSI::NativeTimingSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["createTimer"] = MethodMetadata {4, __hostFunction_NativeTimingSpecJSI_createTimer};
+  methodMap_["deleteTimer"] = MethodMetadata {1, __hostFunction_NativeTimingSpecJSI_deleteTimer};
+  methodMap_["setSendIdleEvents"] = MethodMetadata {1, __hostFunction_NativeTimingSpecJSI_setSendIdleEvents};
+}
+static facebook::jsi::Value __hostFunction_NativeToastAndroidSpecJSI_getConstants(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, ObjectKind, "getConstants", "()Ljava/util/Map;", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeToastAndroidSpecJSI_show(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "show", "(Ljava/lang/String;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeToastAndroidSpecJSI_showWithGravity(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "showWithGravity", "(Ljava/lang/String;DD)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeToastAndroidSpecJSI_showWithGravityAndOffset(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "showWithGravityAndOffset", "(Ljava/lang/String;DDDD)V", args, count, cachedMethodId);
+}
+
+NativeToastAndroidSpecJSI::NativeToastAndroidSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeToastAndroidSpecJSI_getConstants};
+  methodMap_["show"] = MethodMetadata {2, __hostFunction_NativeToastAndroidSpecJSI_show};
+  methodMap_["showWithGravity"] = MethodMetadata {3, __hostFunction_NativeToastAndroidSpecJSI_showWithGravity};
+  methodMap_["showWithGravityAndOffset"] = MethodMetadata {5, __hostFunction_NativeToastAndroidSpecJSI_showWithGravityAndOffset};
+}
+
+
+static facebook::jsi::Value __hostFunction_NativeVibrationSpecJSI_vibrate(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "vibrate", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeVibrationSpecJSI_vibrateByPattern(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "vibrateByPattern", "(Lcom/facebook/react/bridge/ReadableArray;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeVibrationSpecJSI_cancel(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "cancel", "()V", args, count, cachedMethodId);
+}
+
+NativeVibrationSpecJSI::NativeVibrationSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["vibrate"] = MethodMetadata {1, __hostFunction_NativeVibrationSpecJSI_vibrate};
+  methodMap_["vibrateByPattern"] = MethodMetadata {2, __hostFunction_NativeVibrationSpecJSI_vibrateByPattern};
+  methodMap_["cancel"] = MethodMetadata {0, __hostFunction_NativeVibrationSpecJSI_cancel};
+}
+static facebook::jsi::Value __hostFunction_NativeWebSocketModuleSpecJSI_connect(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "connect", "(Ljava/lang/String;Lcom/facebook/react/bridge/ReadableArray;Lcom/facebook/react/bridge/ReadableMap;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeWebSocketModuleSpecJSI_send(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "send", "(Ljava/lang/String;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeWebSocketModuleSpecJSI_sendBinary(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "sendBinary", "(Ljava/lang/String;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeWebSocketModuleSpecJSI_ping(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "ping", "(D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeWebSocketModuleSpecJSI_close(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "close", "(DLjava/lang/String;D)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeWebSocketModuleSpecJSI_addListener(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "addListener", "(Ljava/lang/String;)V", args, count, cachedMethodId);
+}
+
+static facebook::jsi::Value __hostFunction_NativeWebSocketModuleSpecJSI_removeListeners(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {
+  static jmethodID cachedMethodId = nullptr;
+  return static_cast<JavaTurboModule &>(turboModule).invokeJavaMethod(rt, VoidKind, "removeListeners", "(D)V", args, count, cachedMethodId);
+}
+
+NativeWebSocketModuleSpecJSI::NativeWebSocketModuleSpecJSI(const JavaTurboModule::InitParams &params)
+  : JavaTurboModule(params) {
+  methodMap_["connect"] = MethodMetadata {4, __hostFunction_NativeWebSocketModuleSpecJSI_connect};
+  methodMap_["send"] = MethodMetadata {2, __hostFunction_NativeWebSocketModuleSpecJSI_send};
+  methodMap_["sendBinary"] = MethodMetadata {2, __hostFunction_NativeWebSocketModuleSpecJSI_sendBinary};
+  methodMap_["ping"] = MethodMetadata {1, __hostFunction_NativeWebSocketModuleSpecJSI_ping};
+  methodMap_["close"] = MethodMetadata {3, __hostFunction_NativeWebSocketModuleSpecJSI_close};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeWebSocketModuleSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeWebSocketModuleSpecJSI_removeListeners};
+}
+
+std::shared_ptr<TurboModule> FBReactNativeSpec_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params) {
+  if (moduleName == "AccessibilityInfo") {
+    return std::make_shared<NativeAccessibilityInfoSpecJSI>(params);
+  }
+  if (moduleName == "AccessibilityManager") {
+    return std::make_shared<NativeAccessibilityManagerSpecJSI>(params);
+  }
+  if (moduleName == "ActionSheetManager") {
+    return std::make_shared<NativeActionSheetManagerSpecJSI>(params);
+  }
+  if (moduleName == "AlertManager") {
+    return std::make_shared<NativeAlertManagerSpecJSI>(params);
+  }
+  if (moduleName == "AppState") {
+    return std::make_shared<NativeAppStateSpecJSI>(params);
+  }
+  if (moduleName == "Appearance") {
+    return std::make_shared<NativeAppearanceSpecJSI>(params);
+  }
+  if (moduleName == "BlobModule") {
+    return std::make_shared<NativeBlobModuleSpecJSI>(params);
+  }
+  if (moduleName == "BugReporting") {
+    return std::make_shared<NativeBugReportingSpecJSI>(params);
+  }
+  if (moduleName == "Clipboard") {
+    return std::make_shared<NativeClipboardSpecJSI>(params);
+  }
+  if (moduleName == "DevLoadingView") {
+    return std::make_shared<NativeDevLoadingViewSpecJSI>(params);
+  }
+  if (moduleName == "DevMenu") {
+    return std::make_shared<NativeDevMenuSpecJSI>(params);
+  }
+  if (moduleName == "DevSettings") {
+    return std::make_shared<NativeDevSettingsSpecJSI>(params);
+  }
+  if (moduleName == "DeviceEventManager") {
+    return std::make_shared<NativeDeviceEventManagerSpecJSI>(params);
+  }
+  if (moduleName == "DeviceInfo") {
+    return std::make_shared<NativeDeviceInfoSpecJSI>(params);
+  }
+  if (moduleName == "DialogManagerAndroid") {
+    return std::make_shared<NativeDialogManagerAndroidSpecJSI>(params);
+  }
+  if (moduleName == "ExceptionsManager") {
+    return std::make_shared<NativeExceptionsManagerSpecJSI>(params);
+  }
+  if (moduleName == "FileReaderModule") {
+    return std::make_shared<NativeFileReaderModuleSpecJSI>(params);
+  }
+  if (moduleName == "FrameRateLogger") {
+    return std::make_shared<NativeFrameRateLoggerSpecJSI>(params);
+  }
+  if (moduleName == "HeadlessJsTaskSupport") {
+    return std::make_shared<NativeHeadlessJsTaskSupportSpecJSI>(params);
+  }
+  if (moduleName == "I18nManager") {
+    return std::make_shared<NativeI18nManagerSpecJSI>(params);
+  }
+  if (moduleName == "ImageEditingManager") {
+    return std::make_shared<NativeImageEditorSpecJSI>(params);
+  }
+  if (moduleName == "ImageLoader") {
+    return std::make_shared<NativeImageLoaderAndroidSpecJSI>(params);
+  }
+  if (moduleName == "ImageStoreManager") {
+    return std::make_shared<NativeImageStoreAndroidSpecJSI>(params);
+  }
+  if (moduleName == "IntentAndroid") {
+    return std::make_shared<NativeIntentAndroidSpecJSI>(params);
+  }
+  if (moduleName == "JSCHeapCapture") {
+    return std::make_shared<NativeJSCHeapCaptureSpecJSI>(params);
+  }
+  if (moduleName == "KeyboardObserver") {
+    return std::make_shared<NativeKeyboardObserverSpecJSI>(params);
+  }
+  if (moduleName == "LinkingManager") {
+    return std::make_shared<NativeLinkingManagerSpecJSI>(params);
+  }
+  if (moduleName == "LogBox") {
+    return std::make_shared<NativeLogBoxSpecJSI>(params);
+  }
+  if (moduleName == "ModalManager") {
+    return std::make_shared<NativeModalManagerSpecJSI>(params);
+  }
+  if (moduleName == "NativeAnimatedModule") {
+    return std::make_shared<NativeAnimatedModuleSpecJSI>(params);
+  }
+  if (moduleName == "NativeAnimatedTurboModule") {
+    return std::make_shared<NativeAnimatedTurboModuleSpecJSI>(params);
+  }
+  if (moduleName == "Networking") {
+    return std::make_shared<NativeNetworkingAndroidSpecJSI>(params);
+  }
+  if (moduleName == "PermissionsAndroid") {
+    return std::make_shared<NativePermissionsAndroidSpecJSI>(params);
+  }
+  if (moduleName == "PlatformConstants") {
+    return std::make_shared<NativePlatformConstantsAndroidSpecJSI>(params);
+  }
+  if (moduleName == "ReactDevToolsRuntimeSettingsModule") {
+    return std::make_shared<NativeReactDevToolsRuntimeSettingsModuleSpecJSI>(params);
+  }
+  if (moduleName == "ReactDevToolsSettingsManager") {
+    return std::make_shared<NativeReactDevToolsSettingsManagerSpecJSI>(params);
+  }
+  if (moduleName == "RedBox") {
+    return std::make_shared<NativeRedBoxSpecJSI>(params);
+  }
+  if (moduleName == "SegmentFetcher") {
+    return std::make_shared<NativeSegmentFetcherSpecJSI>(params);
+  }
+  if (moduleName == "SettingsManager") {
+    return std::make_shared<NativeSettingsManagerSpecJSI>(params);
+  }
+  if (moduleName == "ShareModule") {
+    return std::make_shared<NativeShareModuleSpecJSI>(params);
+  }
+  if (moduleName == "SoundManager") {
+    return std::make_shared<NativeSoundManagerSpecJSI>(params);
+  }
+  if (moduleName == "SourceCode") {
+    return std::make_shared<NativeSourceCodeSpecJSI>(params);
+  }
+  if (moduleName == "StatusBarManager") {
+    return std::make_shared<NativeStatusBarManagerAndroidSpecJSI>(params);
+  }
+  if (moduleName == "Timing") {
+    return std::make_shared<NativeTimingSpecJSI>(params);
+  }
+  if (moduleName == "ToastAndroid") {
+    return std::make_shared<NativeToastAndroidSpecJSI>(params);
+  }
+  if (moduleName == "Vibration") {
+    return std::make_shared<NativeVibrationSpecJSI>(params);
+  }
+  if (moduleName == "WebSocketModule") {
+    return std::make_shared<NativeWebSocketModuleSpecJSI>(params);
+  }
+  return nullptr;
+}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/FBReactNativeSpec.h b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/FBReactNativeSpec.h
new file mode 100644
index 0000000..495045e
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/FBReactNativeSpec.h
@@ -0,0 +1,399 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleJniH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/JavaTurboModule.h>
+#include <ReactCommon/TurboModule.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+/**
+ * JNI C++ class for module 'NativeAccessibilityInfo'
+ */
+class JSI_EXPORT NativeAccessibilityInfoSpecJSI : public JavaTurboModule {
+public:
+  NativeAccessibilityInfoSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeAccessibilityManager'
+ */
+class JSI_EXPORT NativeAccessibilityManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeAccessibilityManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeActionSheetManager'
+ */
+class JSI_EXPORT NativeActionSheetManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeActionSheetManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeAlertManager'
+ */
+class JSI_EXPORT NativeAlertManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeAlertManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeAnimatedModule'
+ */
+class JSI_EXPORT NativeAnimatedModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeAnimatedModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeAnimatedTurboModule'
+ */
+class JSI_EXPORT NativeAnimatedTurboModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeAnimatedTurboModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeAppState'
+ */
+class JSI_EXPORT NativeAppStateSpecJSI : public JavaTurboModule {
+public:
+  NativeAppStateSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeAppearance'
+ */
+class JSI_EXPORT NativeAppearanceSpecJSI : public JavaTurboModule {
+public:
+  NativeAppearanceSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeBlobModule'
+ */
+class JSI_EXPORT NativeBlobModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeBlobModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeBugReporting'
+ */
+class JSI_EXPORT NativeBugReportingSpecJSI : public JavaTurboModule {
+public:
+  NativeBugReportingSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeClipboard'
+ */
+class JSI_EXPORT NativeClipboardSpecJSI : public JavaTurboModule {
+public:
+  NativeClipboardSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeDevLoadingView'
+ */
+class JSI_EXPORT NativeDevLoadingViewSpecJSI : public JavaTurboModule {
+public:
+  NativeDevLoadingViewSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeDevMenu'
+ */
+class JSI_EXPORT NativeDevMenuSpecJSI : public JavaTurboModule {
+public:
+  NativeDevMenuSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeDevSettings'
+ */
+class JSI_EXPORT NativeDevSettingsSpecJSI : public JavaTurboModule {
+public:
+  NativeDevSettingsSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeDeviceEventManager'
+ */
+class JSI_EXPORT NativeDeviceEventManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeDeviceEventManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeDeviceInfo'
+ */
+class JSI_EXPORT NativeDeviceInfoSpecJSI : public JavaTurboModule {
+public:
+  NativeDeviceInfoSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeDialogManagerAndroid'
+ */
+class JSI_EXPORT NativeDialogManagerAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativeDialogManagerAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeExceptionsManager'
+ */
+class JSI_EXPORT NativeExceptionsManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeExceptionsManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeFileReaderModule'
+ */
+class JSI_EXPORT NativeFileReaderModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeFileReaderModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeFrameRateLogger'
+ */
+class JSI_EXPORT NativeFrameRateLoggerSpecJSI : public JavaTurboModule {
+public:
+  NativeFrameRateLoggerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeHeadlessJsTaskSupport'
+ */
+class JSI_EXPORT NativeHeadlessJsTaskSupportSpecJSI : public JavaTurboModule {
+public:
+  NativeHeadlessJsTaskSupportSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeI18nManager'
+ */
+class JSI_EXPORT NativeI18nManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeI18nManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeImageEditor'
+ */
+class JSI_EXPORT NativeImageEditorSpecJSI : public JavaTurboModule {
+public:
+  NativeImageEditorSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeImageLoaderAndroid'
+ */
+class JSI_EXPORT NativeImageLoaderAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativeImageLoaderAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeImageStoreAndroid'
+ */
+class JSI_EXPORT NativeImageStoreAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativeImageStoreAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeIntentAndroid'
+ */
+class JSI_EXPORT NativeIntentAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativeIntentAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeJSCHeapCapture'
+ */
+class JSI_EXPORT NativeJSCHeapCaptureSpecJSI : public JavaTurboModule {
+public:
+  NativeJSCHeapCaptureSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeKeyboardObserver'
+ */
+class JSI_EXPORT NativeKeyboardObserverSpecJSI : public JavaTurboModule {
+public:
+  NativeKeyboardObserverSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeLinkingManager'
+ */
+class JSI_EXPORT NativeLinkingManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeLinkingManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeLogBox'
+ */
+class JSI_EXPORT NativeLogBoxSpecJSI : public JavaTurboModule {
+public:
+  NativeLogBoxSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeModalManager'
+ */
+class JSI_EXPORT NativeModalManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeModalManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeNetworkingAndroid'
+ */
+class JSI_EXPORT NativeNetworkingAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativeNetworkingAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativePermissionsAndroid'
+ */
+class JSI_EXPORT NativePermissionsAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativePermissionsAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativePlatformConstantsAndroid'
+ */
+class JSI_EXPORT NativePlatformConstantsAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativePlatformConstantsAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeReactDevToolsRuntimeSettingsModule'
+ */
+class JSI_EXPORT NativeReactDevToolsRuntimeSettingsModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeReactDevToolsRuntimeSettingsModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeReactDevToolsSettingsManager'
+ */
+class JSI_EXPORT NativeReactDevToolsSettingsManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeReactDevToolsSettingsManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeRedBox'
+ */
+class JSI_EXPORT NativeRedBoxSpecJSI : public JavaTurboModule {
+public:
+  NativeRedBoxSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeSegmentFetcher'
+ */
+class JSI_EXPORT NativeSegmentFetcherSpecJSI : public JavaTurboModule {
+public:
+  NativeSegmentFetcherSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeSettingsManager'
+ */
+class JSI_EXPORT NativeSettingsManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeSettingsManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeShareModule'
+ */
+class JSI_EXPORT NativeShareModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeShareModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeSoundManager'
+ */
+class JSI_EXPORT NativeSoundManagerSpecJSI : public JavaTurboModule {
+public:
+  NativeSoundManagerSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeSourceCode'
+ */
+class JSI_EXPORT NativeSourceCodeSpecJSI : public JavaTurboModule {
+public:
+  NativeSourceCodeSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeStatusBarManagerAndroid'
+ */
+class JSI_EXPORT NativeStatusBarManagerAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativeStatusBarManagerAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeTiming'
+ */
+class JSI_EXPORT NativeTimingSpecJSI : public JavaTurboModule {
+public:
+  NativeTimingSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeToastAndroid'
+ */
+class JSI_EXPORT NativeToastAndroidSpecJSI : public JavaTurboModule {
+public:
+  NativeToastAndroidSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeVibration'
+ */
+class JSI_EXPORT NativeVibrationSpecJSI : public JavaTurboModule {
+public:
+  NativeVibrationSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+/**
+ * JNI C++ class for module 'NativeWebSocketModule'
+ */
+class JSI_EXPORT NativeWebSocketModuleSpecJSI : public JavaTurboModule {
+public:
+  NativeWebSocketModuleSpecJSI(const JavaTurboModule::InitParams &params);
+};
+
+
+JSI_EXPORT
+std::shared_ptr<TurboModule> FBReactNativeSpec_ModuleProvider(const std::string &moduleName, const JavaTurboModule::InitParams &params);
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/FBReactNativeSpec/FBReactNativeSpecJSI-generated.cpp b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/FBReactNativeSpec/FBReactNativeSpecJSI-generated.cpp
new file mode 100644
index 0000000..24f96dd
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/FBReactNativeSpec/FBReactNativeSpecJSI-generated.cpp
@@ -0,0 +1,2930 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleCpp.js
+ */
+
+#include "FBReactNativeSpecJSI.h"
+
+namespace facebook::react {
+
+static jsi::Value __hostFunction_NativeDevMenuCxxSpecJSI_show(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevMenuCxxSpecJSI *>(&turboModule)->show(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevMenuCxxSpecJSI_reload(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevMenuCxxSpecJSI *>(&turboModule)->reload(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevMenuCxxSpecJSI_setProfilingEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevMenuCxxSpecJSI *>(&turboModule)->setProfilingEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevMenuCxxSpecJSI_setHotLoadingEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevMenuCxxSpecJSI *>(&turboModule)->setHotLoadingEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeDevMenuCxxSpecJSI::NativeDevMenuCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("DevMenu", jsInvoker) {
+  methodMap_["show"] = MethodMetadata {0, __hostFunction_NativeDevMenuCxxSpecJSI_show};
+  methodMap_["reload"] = MethodMetadata {0, __hostFunction_NativeDevMenuCxxSpecJSI_reload};
+  methodMap_["setProfilingEnabled"] = MethodMetadata {1, __hostFunction_NativeDevMenuCxxSpecJSI_setProfilingEnabled};
+  methodMap_["setHotLoadingEnabled"] = MethodMetadata {1, __hostFunction_NativeDevMenuCxxSpecJSI_setHotLoadingEnabled};
+}
+static jsi::Value __hostFunction_NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI_setReloadAndProfileConfig(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI *>(&turboModule)->setReloadAndProfileConfig(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI_getReloadAndProfileConfig(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI *>(&turboModule)->getReloadAndProfileConfig(
+    rt
+  );
+}
+
+NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI::NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ReactDevToolsRuntimeSettingsModule", jsInvoker) {
+  methodMap_["setReloadAndProfileConfig"] = MethodMetadata {1, __hostFunction_NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI_setReloadAndProfileConfig};
+  methodMap_["getReloadAndProfileConfig"] = MethodMetadata {0, __hostFunction_NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI_getReloadAndProfileConfig};
+}
+static jsi::Value __hostFunction_NativeReactDevToolsSettingsManagerCxxSpecJSI_setGlobalHookSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeReactDevToolsSettingsManagerCxxSpecJSI *>(&turboModule)->setGlobalHookSettings(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeReactDevToolsSettingsManagerCxxSpecJSI_getGlobalHookSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  auto result = static_cast<NativeReactDevToolsSettingsManagerCxxSpecJSI *>(&turboModule)->getGlobalHookSettings(
+    rt
+  );
+  return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
+}
+
+NativeReactDevToolsSettingsManagerCxxSpecJSI::NativeReactDevToolsSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ReactDevToolsSettingsManager", jsInvoker) {
+  methodMap_["setGlobalHookSettings"] = MethodMetadata {1, __hostFunction_NativeReactDevToolsSettingsManagerCxxSpecJSI_setGlobalHookSettings};
+  methodMap_["getGlobalHookSettings"] = MethodMetadata {0, __hostFunction_NativeReactDevToolsSettingsManagerCxxSpecJSI_getGlobalHookSettings};
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_commonTestFlag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->commonTestFlag(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_commonTestFlagWithoutNativeImplementation(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->commonTestFlagWithoutNativeImplementation(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_animatedShouldSignalBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->animatedShouldSignalBatch(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_cxxNativeAnimatedEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->cxxNativeAnimatedEnabled(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_disableMainQueueSyncDispatchIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->disableMainQueueSyncDispatchIOS(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_disableMountItemReorderingAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->disableMountItemReorderingAndroid(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableAccessibilityOrder(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableAccessibilityOrder(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableAccumulatedUpdatesInRawPropsAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableAccumulatedUpdatesInRawPropsAndroid(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableBridgelessArchitecture(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableBridgelessArchitecture(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableCppPropsIteratorSetter(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableCppPropsIteratorSetter(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableCustomFocusSearchOnClippedElementsAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableCustomFocusSearchOnClippedElementsAndroid(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableDestroyShadowTreeRevisionAsync(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableDestroyShadowTreeRevisionAsync(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableDoubleMeasurementFixAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableDoubleMeasurementFixAndroid(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableEagerRootViewAttachment(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableEagerRootViewAttachment(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableFabricLogs(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableFabricLogs(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableFabricRenderer(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableFabricRenderer(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableFixForParentTagDuringReparenting(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableFixForParentTagDuringReparenting(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableFontScaleChangesUpdatingLayout(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableFontScaleChangesUpdatingLayout(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableIOSViewClipToPaddingBox(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableIOSViewClipToPaddingBox(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableJSRuntimeGCOnMemoryPressureOnIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableJSRuntimeGCOnMemoryPressureOnIOS(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableLayoutAnimationsOnAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableLayoutAnimationsOnAndroid(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableLayoutAnimationsOnIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableLayoutAnimationsOnIOS(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableMainQueueModulesOnIOS(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableMainQueueModulesOnIOS(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableNativeCSSParsing(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableNativeCSSParsing(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableNetworkEventReporting(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableNetworkEventReporting(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableNewBackgroundAndBorderDrawables(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableNewBackgroundAndBorderDrawables(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enablePreparedTextLayout(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enablePreparedTextLayout(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enablePropsUpdateReconciliationAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enablePropsUpdateReconciliationAndroid(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableResourceTimingAPI(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableResourceTimingAPI(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableSynchronousStateUpdates(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableSynchronousStateUpdates(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableViewCulling(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableViewCulling(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableViewRecycling(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableViewRecycling(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableViewRecyclingForText(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableViewRecyclingForText(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableViewRecyclingForView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->enableViewRecyclingForView(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_fixMappingOfEventPrioritiesBetweenFabricAndReact(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->fixMappingOfEventPrioritiesBetweenFabricAndReact(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_fuseboxEnabledRelease(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->fuseboxEnabledRelease(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_fuseboxNetworkInspectionEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->fuseboxNetworkInspectionEnabled(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_incorporateMaxLinesDuringAndroidLayout(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->incorporateMaxLinesDuringAndroidLayout(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_traceTurboModulePromiseRejectionsOnAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->traceTurboModulePromiseRejectionsOnAndroid(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_updateRuntimeShadowNodeReferencesOnCommit(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->updateRuntimeShadowNodeReferencesOnCommit(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useAlwaysAvailableJSErrorHandling(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->useAlwaysAvailableJSErrorHandling(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useFabricInterop(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->useFabricInterop(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useNativeViewConfigsInBridgelessMode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->useNativeViewConfigsInBridgelessMode(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useOptimizedEventBatchingOnAndroid(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->useOptimizedEventBatchingOnAndroid(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useRawPropsJsiValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->useRawPropsJsiValue(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useShadowNodeStateOnClone(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->useShadowNodeStateOnClone(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useTurboModuleInterop(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->useTurboModuleInterop(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useTurboModules(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeReactNativeFeatureFlagsCxxSpecJSI *>(&turboModule)->useTurboModules(
+    rt
+  );
+}
+
+NativeReactNativeFeatureFlagsCxxSpecJSI::NativeReactNativeFeatureFlagsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativeReactNativeFeatureFlagsCxx", jsInvoker) {
+  methodMap_["commonTestFlag"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_commonTestFlag};
+  methodMap_["commonTestFlagWithoutNativeImplementation"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_commonTestFlagWithoutNativeImplementation};
+  methodMap_["animatedShouldSignalBatch"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_animatedShouldSignalBatch};
+  methodMap_["cxxNativeAnimatedEnabled"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_cxxNativeAnimatedEnabled};
+  methodMap_["disableMainQueueSyncDispatchIOS"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_disableMainQueueSyncDispatchIOS};
+  methodMap_["disableMountItemReorderingAndroid"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_disableMountItemReorderingAndroid};
+  methodMap_["enableAccessibilityOrder"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableAccessibilityOrder};
+  methodMap_["enableAccumulatedUpdatesInRawPropsAndroid"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableAccumulatedUpdatesInRawPropsAndroid};
+  methodMap_["enableBridgelessArchitecture"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableBridgelessArchitecture};
+  methodMap_["enableCppPropsIteratorSetter"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableCppPropsIteratorSetter};
+  methodMap_["enableCustomFocusSearchOnClippedElementsAndroid"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableCustomFocusSearchOnClippedElementsAndroid};
+  methodMap_["enableDestroyShadowTreeRevisionAsync"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableDestroyShadowTreeRevisionAsync};
+  methodMap_["enableDoubleMeasurementFixAndroid"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableDoubleMeasurementFixAndroid};
+  methodMap_["enableEagerRootViewAttachment"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableEagerRootViewAttachment};
+  methodMap_["enableFabricLogs"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableFabricLogs};
+  methodMap_["enableFabricRenderer"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableFabricRenderer};
+  methodMap_["enableFixForParentTagDuringReparenting"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableFixForParentTagDuringReparenting};
+  methodMap_["enableFontScaleChangesUpdatingLayout"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableFontScaleChangesUpdatingLayout};
+  methodMap_["enableIOSViewClipToPaddingBox"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableIOSViewClipToPaddingBox};
+  methodMap_["enableJSRuntimeGCOnMemoryPressureOnIOS"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableJSRuntimeGCOnMemoryPressureOnIOS};
+  methodMap_["enableLayoutAnimationsOnAndroid"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableLayoutAnimationsOnAndroid};
+  methodMap_["enableLayoutAnimationsOnIOS"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableLayoutAnimationsOnIOS};
+  methodMap_["enableMainQueueModulesOnIOS"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableMainQueueModulesOnIOS};
+  methodMap_["enableNativeCSSParsing"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableNativeCSSParsing};
+  methodMap_["enableNetworkEventReporting"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableNetworkEventReporting};
+  methodMap_["enableNewBackgroundAndBorderDrawables"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableNewBackgroundAndBorderDrawables};
+  methodMap_["enablePreparedTextLayout"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enablePreparedTextLayout};
+  methodMap_["enablePropsUpdateReconciliationAndroid"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enablePropsUpdateReconciliationAndroid};
+  methodMap_["enableResourceTimingAPI"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableResourceTimingAPI};
+  methodMap_["enableSynchronousStateUpdates"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableSynchronousStateUpdates};
+  methodMap_["enableViewCulling"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableViewCulling};
+  methodMap_["enableViewRecycling"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableViewRecycling};
+  methodMap_["enableViewRecyclingForText"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableViewRecyclingForText};
+  methodMap_["enableViewRecyclingForView"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_enableViewRecyclingForView};
+  methodMap_["fixMappingOfEventPrioritiesBetweenFabricAndReact"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_fixMappingOfEventPrioritiesBetweenFabricAndReact};
+  methodMap_["fuseboxEnabledRelease"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_fuseboxEnabledRelease};
+  methodMap_["fuseboxNetworkInspectionEnabled"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_fuseboxNetworkInspectionEnabled};
+  methodMap_["incorporateMaxLinesDuringAndroidLayout"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_incorporateMaxLinesDuringAndroidLayout};
+  methodMap_["traceTurboModulePromiseRejectionsOnAndroid"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_traceTurboModulePromiseRejectionsOnAndroid};
+  methodMap_["updateRuntimeShadowNodeReferencesOnCommit"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_updateRuntimeShadowNodeReferencesOnCommit};
+  methodMap_["useAlwaysAvailableJSErrorHandling"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useAlwaysAvailableJSErrorHandling};
+  methodMap_["useFabricInterop"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useFabricInterop};
+  methodMap_["useNativeViewConfigsInBridgelessMode"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useNativeViewConfigsInBridgelessMode};
+  methodMap_["useOptimizedEventBatchingOnAndroid"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useOptimizedEventBatchingOnAndroid};
+  methodMap_["useRawPropsJsiValue"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useRawPropsJsiValue};
+  methodMap_["useShadowNodeStateOnClone"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useShadowNodeStateOnClone};
+  methodMap_["useTurboModuleInterop"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useTurboModuleInterop};
+  methodMap_["useTurboModules"] = MethodMetadata {0, __hostFunction_NativeReactNativeFeatureFlagsCxxSpecJSI_useTurboModules};
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isReduceMotionEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->isReduceMotionEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isInvertColorsEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->isInvertColorsEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isHighTextContrastEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->isHighTextContrastEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isTouchExplorationEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->isTouchExplorationEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isAccessibilityServiceEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->isAccessibilityServiceEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_setAccessibilityFocus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->setAccessibilityFocus(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_announceForAccessibility(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->announceForAccessibility(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_getRecommendedTimeoutMillis(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->getRecommendedTimeoutMillis(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isGrayscaleEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityInfoCxxSpecJSI *>(&turboModule)->isGrayscaleEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeAccessibilityInfoCxxSpecJSI::NativeAccessibilityInfoCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("AccessibilityInfo", jsInvoker) {
+  methodMap_["isReduceMotionEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isReduceMotionEnabled};
+  methodMap_["isInvertColorsEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isInvertColorsEnabled};
+  methodMap_["isHighTextContrastEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isHighTextContrastEnabled};
+  methodMap_["isTouchExplorationEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isTouchExplorationEnabled};
+  methodMap_["isAccessibilityServiceEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isAccessibilityServiceEnabled};
+  methodMap_["setAccessibilityFocus"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_setAccessibilityFocus};
+  methodMap_["announceForAccessibility"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_announceForAccessibility};
+  methodMap_["getRecommendedTimeoutMillis"] = MethodMetadata {2, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_getRecommendedTimeoutMillis};
+  methodMap_["isGrayscaleEnabled"] = MethodMetadata {1, __hostFunction_NativeAccessibilityInfoCxxSpecJSI_isGrayscaleEnabled};
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentBoldTextState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->getCurrentBoldTextState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentGrayscaleState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->getCurrentGrayscaleState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentInvertColorsState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->getCurrentInvertColorsState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentReduceMotionState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->getCurrentReduceMotionState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentDarkerSystemColorsState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->getCurrentDarkerSystemColorsState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentPrefersCrossFadeTransitionsState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->getCurrentPrefersCrossFadeTransitionsState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentReduceTransparencyState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->getCurrentReduceTransparencyState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentVoiceOverState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->getCurrentVoiceOverState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_setAccessibilityContentSizeMultipliers(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->setAccessibilityContentSizeMultipliers(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_setAccessibilityFocus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->setAccessibilityFocus(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_announceForAccessibility(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->announceForAccessibility(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAccessibilityManagerCxxSpecJSI_announceForAccessibilityWithOptions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAccessibilityManagerCxxSpecJSI *>(&turboModule)->announceForAccessibilityWithOptions(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeAccessibilityManagerCxxSpecJSI::NativeAccessibilityManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("AccessibilityManager", jsInvoker) {
+  methodMap_["getCurrentBoldTextState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentBoldTextState};
+  methodMap_["getCurrentGrayscaleState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentGrayscaleState};
+  methodMap_["getCurrentInvertColorsState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentInvertColorsState};
+  methodMap_["getCurrentReduceMotionState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentReduceMotionState};
+  methodMap_["getCurrentDarkerSystemColorsState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentDarkerSystemColorsState};
+  methodMap_["getCurrentPrefersCrossFadeTransitionsState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentPrefersCrossFadeTransitionsState};
+  methodMap_["getCurrentReduceTransparencyState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentReduceTransparencyState};
+  methodMap_["getCurrentVoiceOverState"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_getCurrentVoiceOverState};
+  methodMap_["setAccessibilityContentSizeMultipliers"] = MethodMetadata {1, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_setAccessibilityContentSizeMultipliers};
+  methodMap_["setAccessibilityFocus"] = MethodMetadata {1, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_setAccessibilityFocus};
+  methodMap_["announceForAccessibility"] = MethodMetadata {1, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_announceForAccessibility};
+  methodMap_["announceForAccessibilityWithOptions"] = MethodMetadata {2, __hostFunction_NativeAccessibilityManagerCxxSpecJSI_announceForAccessibilityWithOptions};
+}
+static jsi::Value __hostFunction_NativeActionSheetManagerCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeActionSheetManagerCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeActionSheetManagerCxxSpecJSI_showActionSheetWithOptions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeActionSheetManagerCxxSpecJSI *>(&turboModule)->showActionSheetWithOptions(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeActionSheetManagerCxxSpecJSI_showShareActionSheetWithOptions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeActionSheetManagerCxxSpecJSI *>(&turboModule)->showShareActionSheetWithOptions(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeActionSheetManagerCxxSpecJSI_dismissActionSheet(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeActionSheetManagerCxxSpecJSI *>(&turboModule)->dismissActionSheet(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeActionSheetManagerCxxSpecJSI::NativeActionSheetManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ActionSheetManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeActionSheetManagerCxxSpecJSI_getConstants};
+  methodMap_["showActionSheetWithOptions"] = MethodMetadata {2, __hostFunction_NativeActionSheetManagerCxxSpecJSI_showActionSheetWithOptions};
+  methodMap_["showShareActionSheetWithOptions"] = MethodMetadata {3, __hostFunction_NativeActionSheetManagerCxxSpecJSI_showShareActionSheetWithOptions};
+  methodMap_["dismissActionSheet"] = MethodMetadata {0, __hostFunction_NativeActionSheetManagerCxxSpecJSI_dismissActionSheet};
+}
+static jsi::Value __hostFunction_NativeAlertManagerCxxSpecJSI_alertWithArgs(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAlertManagerCxxSpecJSI *>(&turboModule)->alertWithArgs(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeAlertManagerCxxSpecJSI::NativeAlertManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("AlertManager", jsInvoker) {
+  methodMap_["alertWithArgs"] = MethodMetadata {2, __hostFunction_NativeAlertManagerCxxSpecJSI_alertWithArgs};
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_startOperationBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->startOperationBatch(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_finishOperationBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->finishOperationBatch(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_createAnimatedNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->createAnimatedNode(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_updateAnimatedNodeConfig(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->updateAnimatedNodeConfig(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->getValue(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_startListeningToAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->startListeningToAnimatedNodeValue(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_stopListeningToAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->stopListeningToAnimatedNodeValue(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_connectAnimatedNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->connectAnimatedNodes(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_disconnectAnimatedNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->disconnectAnimatedNodes(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_startAnimatingNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->startAnimatingNode(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_stopAnimation(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->stopAnimation(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_setAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->setAnimatedNodeValue(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_setAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->setAnimatedNodeOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_flattenAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->flattenAnimatedNodeOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_extractAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->extractAnimatedNodeOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_connectAnimatedNodeToView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->connectAnimatedNodeToView(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_disconnectAnimatedNodeFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->disconnectAnimatedNodeFromView(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_restoreDefaultValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->restoreDefaultValues(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_dropAnimatedNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->dropAnimatedNode(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_addAnimatedEventToView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->addAnimatedEventToView(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_removeAnimatedEventFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->removeAnimatedEventFromView(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedModuleCxxSpecJSI_queueAndExecuteBatchedOperations(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedModuleCxxSpecJSI *>(&turboModule)->queueAndExecuteBatchedOperations(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeAnimatedModuleCxxSpecJSI::NativeAnimatedModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativeAnimatedModule", jsInvoker) {
+  methodMap_["startOperationBatch"] = MethodMetadata {0, __hostFunction_NativeAnimatedModuleCxxSpecJSI_startOperationBatch};
+  methodMap_["finishOperationBatch"] = MethodMetadata {0, __hostFunction_NativeAnimatedModuleCxxSpecJSI_finishOperationBatch};
+  methodMap_["createAnimatedNode"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_createAnimatedNode};
+  methodMap_["updateAnimatedNodeConfig"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_updateAnimatedNodeConfig};
+  methodMap_["getValue"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_getValue};
+  methodMap_["startListeningToAnimatedNodeValue"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_startListeningToAnimatedNodeValue};
+  methodMap_["stopListeningToAnimatedNodeValue"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_stopListeningToAnimatedNodeValue};
+  methodMap_["connectAnimatedNodes"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_connectAnimatedNodes};
+  methodMap_["disconnectAnimatedNodes"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_disconnectAnimatedNodes};
+  methodMap_["startAnimatingNode"] = MethodMetadata {4, __hostFunction_NativeAnimatedModuleCxxSpecJSI_startAnimatingNode};
+  methodMap_["stopAnimation"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_stopAnimation};
+  methodMap_["setAnimatedNodeValue"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_setAnimatedNodeValue};
+  methodMap_["setAnimatedNodeOffset"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_setAnimatedNodeOffset};
+  methodMap_["flattenAnimatedNodeOffset"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_flattenAnimatedNodeOffset};
+  methodMap_["extractAnimatedNodeOffset"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_extractAnimatedNodeOffset};
+  methodMap_["connectAnimatedNodeToView"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_connectAnimatedNodeToView};
+  methodMap_["disconnectAnimatedNodeFromView"] = MethodMetadata {2, __hostFunction_NativeAnimatedModuleCxxSpecJSI_disconnectAnimatedNodeFromView};
+  methodMap_["restoreDefaultValues"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_restoreDefaultValues};
+  methodMap_["dropAnimatedNode"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_dropAnimatedNode};
+  methodMap_["addAnimatedEventToView"] = MethodMetadata {3, __hostFunction_NativeAnimatedModuleCxxSpecJSI_addAnimatedEventToView};
+  methodMap_["removeAnimatedEventFromView"] = MethodMetadata {3, __hostFunction_NativeAnimatedModuleCxxSpecJSI_removeAnimatedEventFromView};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_removeListeners};
+  methodMap_["queueAndExecuteBatchedOperations"] = MethodMetadata {1, __hostFunction_NativeAnimatedModuleCxxSpecJSI_queueAndExecuteBatchedOperations};
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_startOperationBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->startOperationBatch(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_finishOperationBatch(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->finishOperationBatch(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_createAnimatedNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->createAnimatedNode(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_updateAnimatedNodeConfig(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->updateAnimatedNodeConfig(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_getValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->getValue(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_startListeningToAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->startListeningToAnimatedNodeValue(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_stopListeningToAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->stopListeningToAnimatedNodeValue(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_connectAnimatedNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->connectAnimatedNodes(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_disconnectAnimatedNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->disconnectAnimatedNodes(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_startAnimatingNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->startAnimatingNode(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_stopAnimation(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->stopAnimation(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_setAnimatedNodeValue(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->setAnimatedNodeValue(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_setAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->setAnimatedNodeOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_flattenAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->flattenAnimatedNodeOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_extractAnimatedNodeOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->extractAnimatedNodeOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_connectAnimatedNodeToView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->connectAnimatedNodeToView(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_disconnectAnimatedNodeFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->disconnectAnimatedNodeFromView(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_restoreDefaultValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->restoreDefaultValues(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_dropAnimatedNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->dropAnimatedNode(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_addAnimatedEventToView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->addAnimatedEventToView(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_removeAnimatedEventFromView(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->removeAnimatedEventFromView(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_queueAndExecuteBatchedOperations(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAnimatedTurboModuleCxxSpecJSI *>(&turboModule)->queueAndExecuteBatchedOperations(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeAnimatedTurboModuleCxxSpecJSI::NativeAnimatedTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativeAnimatedTurboModule", jsInvoker) {
+  methodMap_["startOperationBatch"] = MethodMetadata {0, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_startOperationBatch};
+  methodMap_["finishOperationBatch"] = MethodMetadata {0, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_finishOperationBatch};
+  methodMap_["createAnimatedNode"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_createAnimatedNode};
+  methodMap_["updateAnimatedNodeConfig"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_updateAnimatedNodeConfig};
+  methodMap_["getValue"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_getValue};
+  methodMap_["startListeningToAnimatedNodeValue"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_startListeningToAnimatedNodeValue};
+  methodMap_["stopListeningToAnimatedNodeValue"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_stopListeningToAnimatedNodeValue};
+  methodMap_["connectAnimatedNodes"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_connectAnimatedNodes};
+  methodMap_["disconnectAnimatedNodes"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_disconnectAnimatedNodes};
+  methodMap_["startAnimatingNode"] = MethodMetadata {4, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_startAnimatingNode};
+  methodMap_["stopAnimation"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_stopAnimation};
+  methodMap_["setAnimatedNodeValue"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_setAnimatedNodeValue};
+  methodMap_["setAnimatedNodeOffset"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_setAnimatedNodeOffset};
+  methodMap_["flattenAnimatedNodeOffset"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_flattenAnimatedNodeOffset};
+  methodMap_["extractAnimatedNodeOffset"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_extractAnimatedNodeOffset};
+  methodMap_["connectAnimatedNodeToView"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_connectAnimatedNodeToView};
+  methodMap_["disconnectAnimatedNodeFromView"] = MethodMetadata {2, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_disconnectAnimatedNodeFromView};
+  methodMap_["restoreDefaultValues"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_restoreDefaultValues};
+  methodMap_["dropAnimatedNode"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_dropAnimatedNode};
+  methodMap_["addAnimatedEventToView"] = MethodMetadata {3, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_addAnimatedEventToView};
+  methodMap_["removeAnimatedEventFromView"] = MethodMetadata {3, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_removeAnimatedEventFromView};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_removeListeners};
+  methodMap_["queueAndExecuteBatchedOperations"] = MethodMetadata {1, __hostFunction_NativeAnimatedTurboModuleCxxSpecJSI_queueAndExecuteBatchedOperations};
+}
+static jsi::Value __hostFunction_NativeAppearanceCxxSpecJSI_getColorScheme(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  auto result = static_cast<NativeAppearanceCxxSpecJSI *>(&turboModule)->getColorScheme(
+    rt
+  );
+  return result ? jsi::Value(std::move(*result)) : jsi::Value::null();
+}
+static jsi::Value __hostFunction_NativeAppearanceCxxSpecJSI_setColorScheme(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAppearanceCxxSpecJSI *>(&turboModule)->setColorScheme(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAppearanceCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAppearanceCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAppearanceCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAppearanceCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeAppearanceCxxSpecJSI::NativeAppearanceCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("Appearance", jsInvoker) {
+  methodMap_["getColorScheme"] = MethodMetadata {0, __hostFunction_NativeAppearanceCxxSpecJSI_getColorScheme};
+  methodMap_["setColorScheme"] = MethodMetadata {1, __hostFunction_NativeAppearanceCxxSpecJSI_setColorScheme};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeAppearanceCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeAppearanceCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativeAppStateCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeAppStateCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeAppStateCxxSpecJSI_getCurrentAppState(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAppStateCxxSpecJSI *>(&turboModule)->getCurrentAppState(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAppStateCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAppStateCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeAppStateCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeAppStateCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeAppStateCxxSpecJSI::NativeAppStateCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("AppState", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeAppStateCxxSpecJSI_getConstants};
+  methodMap_["getCurrentAppState"] = MethodMetadata {2, __hostFunction_NativeAppStateCxxSpecJSI_getCurrentAppState};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeAppStateCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeAppStateCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativeBlobModuleCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeBlobModuleCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeBlobModuleCxxSpecJSI_addNetworkingHandler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeBlobModuleCxxSpecJSI *>(&turboModule)->addNetworkingHandler(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeBlobModuleCxxSpecJSI_addWebSocketHandler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeBlobModuleCxxSpecJSI *>(&turboModule)->addWebSocketHandler(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeBlobModuleCxxSpecJSI_removeWebSocketHandler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeBlobModuleCxxSpecJSI *>(&turboModule)->removeWebSocketHandler(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeBlobModuleCxxSpecJSI_sendOverSocket(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeBlobModuleCxxSpecJSI *>(&turboModule)->sendOverSocket(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeBlobModuleCxxSpecJSI_createFromParts(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeBlobModuleCxxSpecJSI *>(&turboModule)->createFromParts(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeBlobModuleCxxSpecJSI_release(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeBlobModuleCxxSpecJSI *>(&turboModule)->release(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeBlobModuleCxxSpecJSI::NativeBlobModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("BlobModule", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeBlobModuleCxxSpecJSI_getConstants};
+  methodMap_["addNetworkingHandler"] = MethodMetadata {0, __hostFunction_NativeBlobModuleCxxSpecJSI_addNetworkingHandler};
+  methodMap_["addWebSocketHandler"] = MethodMetadata {1, __hostFunction_NativeBlobModuleCxxSpecJSI_addWebSocketHandler};
+  methodMap_["removeWebSocketHandler"] = MethodMetadata {1, __hostFunction_NativeBlobModuleCxxSpecJSI_removeWebSocketHandler};
+  methodMap_["sendOverSocket"] = MethodMetadata {2, __hostFunction_NativeBlobModuleCxxSpecJSI_sendOverSocket};
+  methodMap_["createFromParts"] = MethodMetadata {2, __hostFunction_NativeBlobModuleCxxSpecJSI_createFromParts};
+  methodMap_["release"] = MethodMetadata {1, __hostFunction_NativeBlobModuleCxxSpecJSI_release};
+}
+static jsi::Value __hostFunction_NativeBugReportingCxxSpecJSI_startReportAProblemFlow(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeBugReportingCxxSpecJSI *>(&turboModule)->startReportAProblemFlow(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeBugReportingCxxSpecJSI_setExtraData(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeBugReportingCxxSpecJSI *>(&turboModule)->setExtraData(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeBugReportingCxxSpecJSI::NativeBugReportingCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("BugReporting", jsInvoker) {
+  methodMap_["startReportAProblemFlow"] = MethodMetadata {0, __hostFunction_NativeBugReportingCxxSpecJSI_startReportAProblemFlow};
+  methodMap_["setExtraData"] = MethodMetadata {2, __hostFunction_NativeBugReportingCxxSpecJSI_setExtraData};
+}
+static jsi::Value __hostFunction_NativeClipboardCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeClipboardCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeClipboardCxxSpecJSI_getString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeClipboardCxxSpecJSI *>(&turboModule)->getString(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeClipboardCxxSpecJSI_setString(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeClipboardCxxSpecJSI *>(&turboModule)->setString(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeClipboardCxxSpecJSI::NativeClipboardCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("Clipboard", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeClipboardCxxSpecJSI_getConstants};
+  methodMap_["getString"] = MethodMetadata {0, __hostFunction_NativeClipboardCxxSpecJSI_getString};
+  methodMap_["setString"] = MethodMetadata {1, __hostFunction_NativeClipboardCxxSpecJSI_setString};
+}
+static jsi::Value __hostFunction_NativeDeviceEventManagerCxxSpecJSI_invokeDefaultBackPressHandler(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDeviceEventManagerCxxSpecJSI *>(&turboModule)->invokeDefaultBackPressHandler(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeDeviceEventManagerCxxSpecJSI::NativeDeviceEventManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("DeviceEventManager", jsInvoker) {
+  methodMap_["invokeDefaultBackPressHandler"] = MethodMetadata {0, __hostFunction_NativeDeviceEventManagerCxxSpecJSI_invokeDefaultBackPressHandler};
+}
+static jsi::Value __hostFunction_NativeDeviceInfoCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDeviceInfoCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+
+NativeDeviceInfoCxxSpecJSI::NativeDeviceInfoCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("DeviceInfo", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeDeviceInfoCxxSpecJSI_getConstants};
+}
+static jsi::Value __hostFunction_NativeDevLoadingViewCxxSpecJSI_showMessage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevLoadingViewCxxSpecJSI *>(&turboModule)->showMessage(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asNumber()),
+    count <= 2 || args[2].isNull() || args[2].isUndefined() ? std::nullopt : std::make_optional(args[2].asNumber())
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevLoadingViewCxxSpecJSI_hide(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevLoadingViewCxxSpecJSI *>(&turboModule)->hide(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeDevLoadingViewCxxSpecJSI::NativeDevLoadingViewCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("DevLoadingView", jsInvoker) {
+  methodMap_["showMessage"] = MethodMetadata {3, __hostFunction_NativeDevLoadingViewCxxSpecJSI_showMessage};
+  methodMap_["hide"] = MethodMetadata {0, __hostFunction_NativeDevLoadingViewCxxSpecJSI_hide};
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_reload(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->reload(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_reloadWithReason(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->reloadWithReason(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_onFastRefresh(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->onFastRefresh(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_setHotLoadingEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->setHotLoadingEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_setProfilingEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->setProfilingEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_toggleElementInspector(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->toggleElementInspector(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_addMenuItem(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->addMenuItem(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_openDebugger(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->openDebugger(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDevSettingsCxxSpecJSI_setIsShakeToShowDevMenuEnabled(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDevSettingsCxxSpecJSI *>(&turboModule)->setIsShakeToShowDevMenuEnabled(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeDevSettingsCxxSpecJSI::NativeDevSettingsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("DevSettings", jsInvoker) {
+  methodMap_["reload"] = MethodMetadata {0, __hostFunction_NativeDevSettingsCxxSpecJSI_reload};
+  methodMap_["reloadWithReason"] = MethodMetadata {1, __hostFunction_NativeDevSettingsCxxSpecJSI_reloadWithReason};
+  methodMap_["onFastRefresh"] = MethodMetadata {0, __hostFunction_NativeDevSettingsCxxSpecJSI_onFastRefresh};
+  methodMap_["setHotLoadingEnabled"] = MethodMetadata {1, __hostFunction_NativeDevSettingsCxxSpecJSI_setHotLoadingEnabled};
+  methodMap_["setProfilingEnabled"] = MethodMetadata {1, __hostFunction_NativeDevSettingsCxxSpecJSI_setProfilingEnabled};
+  methodMap_["toggleElementInspector"] = MethodMetadata {0, __hostFunction_NativeDevSettingsCxxSpecJSI_toggleElementInspector};
+  methodMap_["addMenuItem"] = MethodMetadata {1, __hostFunction_NativeDevSettingsCxxSpecJSI_addMenuItem};
+  methodMap_["openDebugger"] = MethodMetadata {0, __hostFunction_NativeDevSettingsCxxSpecJSI_openDebugger};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeDevSettingsCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeDevSettingsCxxSpecJSI_removeListeners};
+  methodMap_["setIsShakeToShowDevMenuEnabled"] = MethodMetadata {1, __hostFunction_NativeDevSettingsCxxSpecJSI_setIsShakeToShowDevMenuEnabled};
+}
+static jsi::Value __hostFunction_NativeDialogManagerAndroidCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDialogManagerAndroidCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeDialogManagerAndroidCxxSpecJSI_showAlert(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDialogManagerAndroidCxxSpecJSI *>(&turboModule)->showAlert(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeDialogManagerAndroidCxxSpecJSI::NativeDialogManagerAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("DialogManagerAndroid", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeDialogManagerAndroidCxxSpecJSI_getConstants};
+  methodMap_["showAlert"] = MethodMetadata {3, __hostFunction_NativeDialogManagerAndroidCxxSpecJSI_showAlert};
+}
+static jsi::Value __hostFunction_NativeExceptionsManagerCxxSpecJSI_reportFatalException(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeExceptionsManagerCxxSpecJSI *>(&turboModule)->reportFatalException(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeExceptionsManagerCxxSpecJSI_reportSoftException(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeExceptionsManagerCxxSpecJSI *>(&turboModule)->reportSoftException(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asArray(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeExceptionsManagerCxxSpecJSI_reportException(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeExceptionsManagerCxxSpecJSI *>(&turboModule)->reportException(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeExceptionsManagerCxxSpecJSI_dismissRedbox(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeExceptionsManagerCxxSpecJSI *>(&turboModule)->dismissRedbox(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeExceptionsManagerCxxSpecJSI::NativeExceptionsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ExceptionsManager", jsInvoker) {
+  methodMap_["reportFatalException"] = MethodMetadata {3, __hostFunction_NativeExceptionsManagerCxxSpecJSI_reportFatalException};
+  methodMap_["reportSoftException"] = MethodMetadata {3, __hostFunction_NativeExceptionsManagerCxxSpecJSI_reportSoftException};
+  methodMap_["reportException"] = MethodMetadata {1, __hostFunction_NativeExceptionsManagerCxxSpecJSI_reportException};
+  methodMap_["dismissRedbox"] = MethodMetadata {0, __hostFunction_NativeExceptionsManagerCxxSpecJSI_dismissRedbox};
+}
+static jsi::Value __hostFunction_NativeFileReaderModuleCxxSpecJSI_readAsDataURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeFileReaderModuleCxxSpecJSI *>(&turboModule)->readAsDataURL(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeFileReaderModuleCxxSpecJSI_readAsText(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeFileReaderModuleCxxSpecJSI *>(&turboModule)->readAsText(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+}
+
+NativeFileReaderModuleCxxSpecJSI::NativeFileReaderModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("FileReaderModule", jsInvoker) {
+  methodMap_["readAsDataURL"] = MethodMetadata {1, __hostFunction_NativeFileReaderModuleCxxSpecJSI_readAsDataURL};
+  methodMap_["readAsText"] = MethodMetadata {2, __hostFunction_NativeFileReaderModuleCxxSpecJSI_readAsText};
+}
+static jsi::Value __hostFunction_NativeFrameRateLoggerCxxSpecJSI_setGlobalOptions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeFrameRateLoggerCxxSpecJSI *>(&turboModule)->setGlobalOptions(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeFrameRateLoggerCxxSpecJSI_setContext(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeFrameRateLoggerCxxSpecJSI *>(&turboModule)->setContext(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeFrameRateLoggerCxxSpecJSI_beginScroll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeFrameRateLoggerCxxSpecJSI *>(&turboModule)->beginScroll(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeFrameRateLoggerCxxSpecJSI_endScroll(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeFrameRateLoggerCxxSpecJSI *>(&turboModule)->endScroll(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeFrameRateLoggerCxxSpecJSI::NativeFrameRateLoggerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("FrameRateLogger", jsInvoker) {
+  methodMap_["setGlobalOptions"] = MethodMetadata {1, __hostFunction_NativeFrameRateLoggerCxxSpecJSI_setGlobalOptions};
+  methodMap_["setContext"] = MethodMetadata {1, __hostFunction_NativeFrameRateLoggerCxxSpecJSI_setContext};
+  methodMap_["beginScroll"] = MethodMetadata {0, __hostFunction_NativeFrameRateLoggerCxxSpecJSI_beginScroll};
+  methodMap_["endScroll"] = MethodMetadata {0, __hostFunction_NativeFrameRateLoggerCxxSpecJSI_endScroll};
+}
+static jsi::Value __hostFunction_NativeHeadlessJsTaskSupportCxxSpecJSI_notifyTaskFinished(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeHeadlessJsTaskSupportCxxSpecJSI *>(&turboModule)->notifyTaskFinished(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeHeadlessJsTaskSupportCxxSpecJSI_notifyTaskRetry(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeHeadlessJsTaskSupportCxxSpecJSI *>(&turboModule)->notifyTaskRetry(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+}
+
+NativeHeadlessJsTaskSupportCxxSpecJSI::NativeHeadlessJsTaskSupportCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("HeadlessJsTaskSupport", jsInvoker) {
+  methodMap_["notifyTaskFinished"] = MethodMetadata {1, __hostFunction_NativeHeadlessJsTaskSupportCxxSpecJSI_notifyTaskFinished};
+  methodMap_["notifyTaskRetry"] = MethodMetadata {1, __hostFunction_NativeHeadlessJsTaskSupportCxxSpecJSI_notifyTaskRetry};
+}
+static jsi::Value __hostFunction_NativeI18nManagerCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeI18nManagerCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeI18nManagerCxxSpecJSI_allowRTL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeI18nManagerCxxSpecJSI *>(&turboModule)->allowRTL(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeI18nManagerCxxSpecJSI_forceRTL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeI18nManagerCxxSpecJSI *>(&turboModule)->forceRTL(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeI18nManagerCxxSpecJSI_swapLeftAndRightInRTL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeI18nManagerCxxSpecJSI *>(&turboModule)->swapLeftAndRightInRTL(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeI18nManagerCxxSpecJSI::NativeI18nManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("I18nManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeI18nManagerCxxSpecJSI_getConstants};
+  methodMap_["allowRTL"] = MethodMetadata {1, __hostFunction_NativeI18nManagerCxxSpecJSI_allowRTL};
+  methodMap_["forceRTL"] = MethodMetadata {1, __hostFunction_NativeI18nManagerCxxSpecJSI_forceRTL};
+  methodMap_["swapLeftAndRightInRTL"] = MethodMetadata {1, __hostFunction_NativeI18nManagerCxxSpecJSI_swapLeftAndRightInRTL};
+}
+static jsi::Value __hostFunction_NativeImageEditorCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageEditorCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeImageEditorCxxSpecJSI_cropImage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeImageEditorCxxSpecJSI *>(&turboModule)->cropImage(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeImageEditorCxxSpecJSI::NativeImageEditorCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ImageEditingManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeImageEditorCxxSpecJSI_getConstants};
+  methodMap_["cropImage"] = MethodMetadata {4, __hostFunction_NativeImageEditorCxxSpecJSI_cropImage};
+}
+static jsi::Value __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_abortRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeImageLoaderAndroidCxxSpecJSI *>(&turboModule)->abortRequest(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderAndroidCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_getSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderAndroidCxxSpecJSI *>(&turboModule)->getSize(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_getSizeWithHeaders(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderAndroidCxxSpecJSI *>(&turboModule)->getSizeWithHeaders(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_prefetchImage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderAndroidCxxSpecJSI *>(&turboModule)->prefetchImage(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_queryCache(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderAndroidCxxSpecJSI *>(&turboModule)->queryCache(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+}
+
+NativeImageLoaderAndroidCxxSpecJSI::NativeImageLoaderAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ImageLoader", jsInvoker) {
+  methodMap_["abortRequest"] = MethodMetadata {1, __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_abortRequest};
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_getConstants};
+  methodMap_["getSize"] = MethodMetadata {1, __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_getSize};
+  methodMap_["getSizeWithHeaders"] = MethodMetadata {2, __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_getSizeWithHeaders};
+  methodMap_["prefetchImage"] = MethodMetadata {2, __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_prefetchImage};
+  methodMap_["queryCache"] = MethodMetadata {1, __hostFunction_NativeImageLoaderAndroidCxxSpecJSI_queryCache};
+}
+static jsi::Value __hostFunction_NativeImageLoaderIOSCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderIOSCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderIOSCxxSpecJSI_getSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderIOSCxxSpecJSI *>(&turboModule)->getSize(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderIOSCxxSpecJSI_getSizeWithHeaders(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderIOSCxxSpecJSI *>(&turboModule)->getSizeWithHeaders(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderIOSCxxSpecJSI_prefetchImage(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderIOSCxxSpecJSI *>(&turboModule)->prefetchImage(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderIOSCxxSpecJSI_prefetchImageWithMetadata(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderIOSCxxSpecJSI *>(&turboModule)->prefetchImageWithMetadata(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeImageLoaderIOSCxxSpecJSI_queryCache(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageLoaderIOSCxxSpecJSI *>(&turboModule)->queryCache(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+}
+
+NativeImageLoaderIOSCxxSpecJSI::NativeImageLoaderIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ImageLoader", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeImageLoaderIOSCxxSpecJSI_getConstants};
+  methodMap_["getSize"] = MethodMetadata {1, __hostFunction_NativeImageLoaderIOSCxxSpecJSI_getSize};
+  methodMap_["getSizeWithHeaders"] = MethodMetadata {2, __hostFunction_NativeImageLoaderIOSCxxSpecJSI_getSizeWithHeaders};
+  methodMap_["prefetchImage"] = MethodMetadata {1, __hostFunction_NativeImageLoaderIOSCxxSpecJSI_prefetchImage};
+  methodMap_["prefetchImageWithMetadata"] = MethodMetadata {3, __hostFunction_NativeImageLoaderIOSCxxSpecJSI_prefetchImageWithMetadata};
+  methodMap_["queryCache"] = MethodMetadata {1, __hostFunction_NativeImageLoaderIOSCxxSpecJSI_queryCache};
+}
+static jsi::Value __hostFunction_NativeImageStoreAndroidCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageStoreAndroidCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeImageStoreAndroidCxxSpecJSI_getBase64ForTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeImageStoreAndroidCxxSpecJSI *>(&turboModule)->getBase64ForTag(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeImageStoreAndroidCxxSpecJSI::NativeImageStoreAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ImageStoreManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeImageStoreAndroidCxxSpecJSI_getConstants};
+  methodMap_["getBase64ForTag"] = MethodMetadata {3, __hostFunction_NativeImageStoreAndroidCxxSpecJSI_getBase64ForTag};
+}
+static jsi::Value __hostFunction_NativeImageStoreIOSCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeImageStoreIOSCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeImageStoreIOSCxxSpecJSI_getBase64ForTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeImageStoreIOSCxxSpecJSI *>(&turboModule)->getBase64ForTag(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeImageStoreIOSCxxSpecJSI_hasImageForTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeImageStoreIOSCxxSpecJSI *>(&turboModule)->hasImageForTag(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeImageStoreIOSCxxSpecJSI_removeImageForTag(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeImageStoreIOSCxxSpecJSI *>(&turboModule)->removeImageForTag(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeImageStoreIOSCxxSpecJSI_addImageFromBase64(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeImageStoreIOSCxxSpecJSI *>(&turboModule)->addImageFromBase64(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeImageStoreIOSCxxSpecJSI::NativeImageStoreIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ImageStoreManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeImageStoreIOSCxxSpecJSI_getConstants};
+  methodMap_["getBase64ForTag"] = MethodMetadata {3, __hostFunction_NativeImageStoreIOSCxxSpecJSI_getBase64ForTag};
+  methodMap_["hasImageForTag"] = MethodMetadata {2, __hostFunction_NativeImageStoreIOSCxxSpecJSI_hasImageForTag};
+  methodMap_["removeImageForTag"] = MethodMetadata {1, __hostFunction_NativeImageStoreIOSCxxSpecJSI_removeImageForTag};
+  methodMap_["addImageFromBase64"] = MethodMetadata {3, __hostFunction_NativeImageStoreIOSCxxSpecJSI_addImageFromBase64};
+}
+static jsi::Value __hostFunction_NativeIntentAndroidCxxSpecJSI_getInitialURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeIntentAndroidCxxSpecJSI *>(&turboModule)->getInitialURL(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeIntentAndroidCxxSpecJSI_canOpenURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeIntentAndroidCxxSpecJSI *>(&turboModule)->canOpenURL(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeIntentAndroidCxxSpecJSI_openURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeIntentAndroidCxxSpecJSI *>(&turboModule)->openURL(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeIntentAndroidCxxSpecJSI_openSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeIntentAndroidCxxSpecJSI *>(&turboModule)->openSettings(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeIntentAndroidCxxSpecJSI_sendIntent(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeIntentAndroidCxxSpecJSI *>(&turboModule)->sendIntent(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asObject(rt).asArray(rt))
+  );
+}
+
+NativeIntentAndroidCxxSpecJSI::NativeIntentAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("IntentAndroid", jsInvoker) {
+  methodMap_["getInitialURL"] = MethodMetadata {0, __hostFunction_NativeIntentAndroidCxxSpecJSI_getInitialURL};
+  methodMap_["canOpenURL"] = MethodMetadata {1, __hostFunction_NativeIntentAndroidCxxSpecJSI_canOpenURL};
+  methodMap_["openURL"] = MethodMetadata {1, __hostFunction_NativeIntentAndroidCxxSpecJSI_openURL};
+  methodMap_["openSettings"] = MethodMetadata {0, __hostFunction_NativeIntentAndroidCxxSpecJSI_openSettings};
+  methodMap_["sendIntent"] = MethodMetadata {2, __hostFunction_NativeIntentAndroidCxxSpecJSI_sendIntent};
+}
+static jsi::Value __hostFunction_NativeJSCHeapCaptureCxxSpecJSI_captureComplete(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeJSCHeapCaptureCxxSpecJSI *>(&turboModule)->captureComplete(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt))
+  );
+  return jsi::Value::undefined();
+}
+
+NativeJSCHeapCaptureCxxSpecJSI::NativeJSCHeapCaptureCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("JSCHeapCapture", jsInvoker) {
+  methodMap_["captureComplete"] = MethodMetadata {2, __hostFunction_NativeJSCHeapCaptureCxxSpecJSI_captureComplete};
+}
+static jsi::Value __hostFunction_NativeKeyboardObserverCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeKeyboardObserverCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeKeyboardObserverCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeKeyboardObserverCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeKeyboardObserverCxxSpecJSI::NativeKeyboardObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("KeyboardObserver", jsInvoker) {
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeKeyboardObserverCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeKeyboardObserverCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativeLinkingManagerCxxSpecJSI_getInitialURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeLinkingManagerCxxSpecJSI *>(&turboModule)->getInitialURL(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeLinkingManagerCxxSpecJSI_canOpenURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeLinkingManagerCxxSpecJSI *>(&turboModule)->canOpenURL(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeLinkingManagerCxxSpecJSI_openURL(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeLinkingManagerCxxSpecJSI *>(&turboModule)->openURL(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativeLinkingManagerCxxSpecJSI_openSettings(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeLinkingManagerCxxSpecJSI *>(&turboModule)->openSettings(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeLinkingManagerCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeLinkingManagerCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeLinkingManagerCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeLinkingManagerCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeLinkingManagerCxxSpecJSI::NativeLinkingManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("LinkingManager", jsInvoker) {
+  methodMap_["getInitialURL"] = MethodMetadata {0, __hostFunction_NativeLinkingManagerCxxSpecJSI_getInitialURL};
+  methodMap_["canOpenURL"] = MethodMetadata {1, __hostFunction_NativeLinkingManagerCxxSpecJSI_canOpenURL};
+  methodMap_["openURL"] = MethodMetadata {1, __hostFunction_NativeLinkingManagerCxxSpecJSI_openURL};
+  methodMap_["openSettings"] = MethodMetadata {0, __hostFunction_NativeLinkingManagerCxxSpecJSI_openSettings};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeLinkingManagerCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeLinkingManagerCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativeLogBoxCxxSpecJSI_show(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeLogBoxCxxSpecJSI *>(&turboModule)->show(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeLogBoxCxxSpecJSI_hide(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeLogBoxCxxSpecJSI *>(&turboModule)->hide(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeLogBoxCxxSpecJSI::NativeLogBoxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("LogBox", jsInvoker) {
+  methodMap_["show"] = MethodMetadata {0, __hostFunction_NativeLogBoxCxxSpecJSI_show};
+  methodMap_["hide"] = MethodMetadata {0, __hostFunction_NativeLogBoxCxxSpecJSI_hide};
+}
+static jsi::Value __hostFunction_NativeModalManagerCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeModalManagerCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeModalManagerCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeModalManagerCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeModalManagerCxxSpecJSI::NativeModalManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ModalManager", jsInvoker) {
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeModalManagerCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeModalManagerCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativeNetworkingAndroidCxxSpecJSI_sendRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingAndroidCxxSpecJSI *>(&turboModule)->sendRequest(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asArray(rt),
+    count <= 4 ? throw jsi::JSError(rt, "Expected argument in position 4 to be passed") : args[4].asObject(rt),
+    count <= 5 ? throw jsi::JSError(rt, "Expected argument in position 5 to be passed") : args[5].asString(rt),
+    count <= 6 ? throw jsi::JSError(rt, "Expected argument in position 6 to be passed") : args[6].asBool(),
+    count <= 7 ? throw jsi::JSError(rt, "Expected argument in position 7 to be passed") : args[7].asNumber(),
+    count <= 8 ? throw jsi::JSError(rt, "Expected argument in position 8 to be passed") : args[8].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeNetworkingAndroidCxxSpecJSI_abortRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingAndroidCxxSpecJSI *>(&turboModule)->abortRequest(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeNetworkingAndroidCxxSpecJSI_clearCookies(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingAndroidCxxSpecJSI *>(&turboModule)->clearCookies(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeNetworkingAndroidCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingAndroidCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeNetworkingAndroidCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingAndroidCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeNetworkingAndroidCxxSpecJSI::NativeNetworkingAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("Networking", jsInvoker) {
+  methodMap_["sendRequest"] = MethodMetadata {9, __hostFunction_NativeNetworkingAndroidCxxSpecJSI_sendRequest};
+  methodMap_["abortRequest"] = MethodMetadata {1, __hostFunction_NativeNetworkingAndroidCxxSpecJSI_abortRequest};
+  methodMap_["clearCookies"] = MethodMetadata {1, __hostFunction_NativeNetworkingAndroidCxxSpecJSI_clearCookies};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeNetworkingAndroidCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeNetworkingAndroidCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativeNetworkingIOSCxxSpecJSI_sendRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingIOSCxxSpecJSI *>(&turboModule)->sendRequest(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeNetworkingIOSCxxSpecJSI_abortRequest(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingIOSCxxSpecJSI *>(&turboModule)->abortRequest(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeNetworkingIOSCxxSpecJSI_clearCookies(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingIOSCxxSpecJSI *>(&turboModule)->clearCookies(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeNetworkingIOSCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingIOSCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeNetworkingIOSCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeNetworkingIOSCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeNetworkingIOSCxxSpecJSI::NativeNetworkingIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("Networking", jsInvoker) {
+  methodMap_["sendRequest"] = MethodMetadata {2, __hostFunction_NativeNetworkingIOSCxxSpecJSI_sendRequest};
+  methodMap_["abortRequest"] = MethodMetadata {1, __hostFunction_NativeNetworkingIOSCxxSpecJSI_abortRequest};
+  methodMap_["clearCookies"] = MethodMetadata {1, __hostFunction_NativeNetworkingIOSCxxSpecJSI_clearCookies};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeNetworkingIOSCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeNetworkingIOSCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativePermissionsAndroidCxxSpecJSI_checkPermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePermissionsAndroidCxxSpecJSI *>(&turboModule)->checkPermission(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativePermissionsAndroidCxxSpecJSI_requestPermission(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePermissionsAndroidCxxSpecJSI *>(&turboModule)->requestPermission(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativePermissionsAndroidCxxSpecJSI_shouldShowRequestPermissionRationale(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePermissionsAndroidCxxSpecJSI *>(&turboModule)->shouldShowRequestPermissionRationale(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+}
+static jsi::Value __hostFunction_NativePermissionsAndroidCxxSpecJSI_requestMultiplePermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePermissionsAndroidCxxSpecJSI *>(&turboModule)->requestMultiplePermissions(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+}
+
+NativePermissionsAndroidCxxSpecJSI::NativePermissionsAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("PermissionsAndroid", jsInvoker) {
+  methodMap_["checkPermission"] = MethodMetadata {1, __hostFunction_NativePermissionsAndroidCxxSpecJSI_checkPermission};
+  methodMap_["requestPermission"] = MethodMetadata {1, __hostFunction_NativePermissionsAndroidCxxSpecJSI_requestPermission};
+  methodMap_["shouldShowRequestPermissionRationale"] = MethodMetadata {1, __hostFunction_NativePermissionsAndroidCxxSpecJSI_shouldShowRequestPermissionRationale};
+  methodMap_["requestMultiplePermissions"] = MethodMetadata {1, __hostFunction_NativePermissionsAndroidCxxSpecJSI_requestMultiplePermissions};
+}
+static jsi::Value __hostFunction_NativePlatformConstantsAndroidCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePlatformConstantsAndroidCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativePlatformConstantsAndroidCxxSpecJSI_getAndroidID(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePlatformConstantsAndroidCxxSpecJSI *>(&turboModule)->getAndroidID(
+    rt
+  );
+}
+
+NativePlatformConstantsAndroidCxxSpecJSI::NativePlatformConstantsAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("PlatformConstants", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativePlatformConstantsAndroidCxxSpecJSI_getConstants};
+  methodMap_["getAndroidID"] = MethodMetadata {0, __hostFunction_NativePlatformConstantsAndroidCxxSpecJSI_getAndroidID};
+}
+static jsi::Value __hostFunction_NativePlatformConstantsIOSCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePlatformConstantsIOSCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+
+NativePlatformConstantsIOSCxxSpecJSI::NativePlatformConstantsIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("PlatformConstants", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativePlatformConstantsIOSCxxSpecJSI_getConstants};
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_onFinishRemoteNotification(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->onFinishRemoteNotification(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_setApplicationIconBadgeNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->setApplicationIconBadgeNumber(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getApplicationIconBadgeNumber(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->getApplicationIconBadgeNumber(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_requestPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->requestPermissions(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_abandonPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->abandonPermissions(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_checkPermissions(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->checkPermissions(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_presentLocalNotification(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->presentLocalNotification(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_scheduleLocalNotification(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->scheduleLocalNotification(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_cancelAllLocalNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->cancelAllLocalNotifications(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_cancelLocalNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->cancelLocalNotifications(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getInitialNotification(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->getInitialNotification(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getScheduledLocalNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->getScheduledLocalNotifications(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_removeAllDeliveredNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->removeAllDeliveredNotifications(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_removeDeliveredNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->removeDeliveredNotifications(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getDeliveredNotifications(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->getDeliveredNotifications(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getAuthorizationStatus(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->getAuthorizationStatus(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePushNotificationManagerIOSCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativePushNotificationManagerIOSCxxSpecJSI::NativePushNotificationManagerIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("PushNotificationManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getConstants};
+  methodMap_["onFinishRemoteNotification"] = MethodMetadata {2, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_onFinishRemoteNotification};
+  methodMap_["setApplicationIconBadgeNumber"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_setApplicationIconBadgeNumber};
+  methodMap_["getApplicationIconBadgeNumber"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getApplicationIconBadgeNumber};
+  methodMap_["requestPermissions"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_requestPermissions};
+  methodMap_["abandonPermissions"] = MethodMetadata {0, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_abandonPermissions};
+  methodMap_["checkPermissions"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_checkPermissions};
+  methodMap_["presentLocalNotification"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_presentLocalNotification};
+  methodMap_["scheduleLocalNotification"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_scheduleLocalNotification};
+  methodMap_["cancelAllLocalNotifications"] = MethodMetadata {0, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_cancelAllLocalNotifications};
+  methodMap_["cancelLocalNotifications"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_cancelLocalNotifications};
+  methodMap_["getInitialNotification"] = MethodMetadata {0, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getInitialNotification};
+  methodMap_["getScheduledLocalNotifications"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getScheduledLocalNotifications};
+  methodMap_["removeAllDeliveredNotifications"] = MethodMetadata {0, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_removeAllDeliveredNotifications};
+  methodMap_["removeDeliveredNotifications"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_removeDeliveredNotifications};
+  methodMap_["getDeliveredNotifications"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getDeliveredNotifications};
+  methodMap_["getAuthorizationStatus"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_getAuthorizationStatus};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativePushNotificationManagerIOSCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativeRedBoxCxxSpecJSI_setExtraData(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeRedBoxCxxSpecJSI *>(&turboModule)->setExtraData(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeRedBoxCxxSpecJSI_dismiss(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeRedBoxCxxSpecJSI *>(&turboModule)->dismiss(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeRedBoxCxxSpecJSI::NativeRedBoxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("RedBox", jsInvoker) {
+  methodMap_["setExtraData"] = MethodMetadata {2, __hostFunction_NativeRedBoxCxxSpecJSI_setExtraData};
+  methodMap_["dismiss"] = MethodMetadata {0, __hostFunction_NativeRedBoxCxxSpecJSI_dismiss};
+}
+static jsi::Value __hostFunction_NativeSegmentFetcherCxxSpecJSI_fetchSegment(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeSegmentFetcherCxxSpecJSI *>(&turboModule)->fetchSegment(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeSegmentFetcherCxxSpecJSI_getSegment(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeSegmentFetcherCxxSpecJSI *>(&turboModule)->getSegment(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeSegmentFetcherCxxSpecJSI::NativeSegmentFetcherCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("SegmentFetcher", jsInvoker) {
+  methodMap_["fetchSegment"] = MethodMetadata {3, __hostFunction_NativeSegmentFetcherCxxSpecJSI_fetchSegment};
+  methodMap_["getSegment"] = MethodMetadata {3, __hostFunction_NativeSegmentFetcherCxxSpecJSI_getSegment};
+}
+static jsi::Value __hostFunction_NativeSettingsManagerCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeSettingsManagerCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeSettingsManagerCxxSpecJSI_setValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeSettingsManagerCxxSpecJSI *>(&turboModule)->setValues(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeSettingsManagerCxxSpecJSI_deleteValues(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeSettingsManagerCxxSpecJSI *>(&turboModule)->deleteValues(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeSettingsManagerCxxSpecJSI::NativeSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("SettingsManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeSettingsManagerCxxSpecJSI_getConstants};
+  methodMap_["setValues"] = MethodMetadata {1, __hostFunction_NativeSettingsManagerCxxSpecJSI_setValues};
+  methodMap_["deleteValues"] = MethodMetadata {1, __hostFunction_NativeSettingsManagerCxxSpecJSI_deleteValues};
+}
+static jsi::Value __hostFunction_NativeShareModuleCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeShareModuleCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeShareModuleCxxSpecJSI_share(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeShareModuleCxxSpecJSI *>(&turboModule)->share(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt),
+    count <= 1 || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asString(rt))
+  );
+}
+
+NativeShareModuleCxxSpecJSI::NativeShareModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ShareModule", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeShareModuleCxxSpecJSI_getConstants};
+  methodMap_["share"] = MethodMetadata {2, __hostFunction_NativeShareModuleCxxSpecJSI_share};
+}
+static jsi::Value __hostFunction_NativeSoundManagerCxxSpecJSI_playTouchSound(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeSoundManagerCxxSpecJSI *>(&turboModule)->playTouchSound(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeSoundManagerCxxSpecJSI::NativeSoundManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("SoundManager", jsInvoker) {
+  methodMap_["playTouchSound"] = MethodMetadata {0, __hostFunction_NativeSoundManagerCxxSpecJSI_playTouchSound};
+}
+static jsi::Value __hostFunction_NativeSourceCodeCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeSourceCodeCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+
+NativeSourceCodeCxxSpecJSI::NativeSourceCodeCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("SourceCode", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeSourceCodeCxxSpecJSI_getConstants};
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeStatusBarManagerAndroidCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_setColor(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerAndroidCxxSpecJSI *>(&turboModule)->setColor(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_setTranslucent(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerAndroidCxxSpecJSI *>(&turboModule)->setTranslucent(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_setStyle(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerAndroidCxxSpecJSI *>(&turboModule)->setStyle(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt))
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_setHidden(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerAndroidCxxSpecJSI *>(&turboModule)->setHidden(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeStatusBarManagerAndroidCxxSpecJSI::NativeStatusBarManagerAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("StatusBarManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_getConstants};
+  methodMap_["setColor"] = MethodMetadata {2, __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_setColor};
+  methodMap_["setTranslucent"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_setTranslucent};
+  methodMap_["setStyle"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_setStyle};
+  methodMap_["setHidden"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerAndroidCxxSpecJSI_setHidden};
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeStatusBarManagerIOSCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_getHeight(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerIOSCxxSpecJSI *>(&turboModule)->getHeight(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_setNetworkActivityIndicatorVisible(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerIOSCxxSpecJSI *>(&turboModule)->setNetworkActivityIndicatorVisible(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerIOSCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerIOSCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_setStyle(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerIOSCxxSpecJSI *>(&turboModule)->setStyle(
+    rt,
+    count <= 0 || args[0].isNull() || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt)),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_setHidden(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeStatusBarManagerIOSCxxSpecJSI *>(&turboModule)->setHidden(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeStatusBarManagerIOSCxxSpecJSI::NativeStatusBarManagerIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("StatusBarManager", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_getConstants};
+  methodMap_["getHeight"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_getHeight};
+  methodMap_["setNetworkActivityIndicatorVisible"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_setNetworkActivityIndicatorVisible};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_removeListeners};
+  methodMap_["setStyle"] = MethodMetadata {2, __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_setStyle};
+  methodMap_["setHidden"] = MethodMetadata {2, __hostFunction_NativeStatusBarManagerIOSCxxSpecJSI_setHidden};
+}
+static jsi::Value __hostFunction_NativeTimingCxxSpecJSI_createTimer(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeTimingCxxSpecJSI *>(&turboModule)->createTimer(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asBool()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeTimingCxxSpecJSI_deleteTimer(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeTimingCxxSpecJSI *>(&turboModule)->deleteTimer(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeTimingCxxSpecJSI_setSendIdleEvents(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeTimingCxxSpecJSI *>(&turboModule)->setSendIdleEvents(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asBool()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeTimingCxxSpecJSI::NativeTimingCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("Timing", jsInvoker) {
+  methodMap_["createTimer"] = MethodMetadata {4, __hostFunction_NativeTimingCxxSpecJSI_createTimer};
+  methodMap_["deleteTimer"] = MethodMetadata {1, __hostFunction_NativeTimingCxxSpecJSI_deleteTimer};
+  methodMap_["setSendIdleEvents"] = MethodMetadata {1, __hostFunction_NativeTimingCxxSpecJSI_setSendIdleEvents};
+}
+static jsi::Value __hostFunction_NativeToastAndroidCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeToastAndroidCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeToastAndroidCxxSpecJSI_show(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeToastAndroidCxxSpecJSI *>(&turboModule)->show(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeToastAndroidCxxSpecJSI_showWithGravity(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeToastAndroidCxxSpecJSI *>(&turboModule)->showWithGravity(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeToastAndroidCxxSpecJSI_showWithGravityAndOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeToastAndroidCxxSpecJSI *>(&turboModule)->showWithGravityAndOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber(),
+    count <= 4 ? throw jsi::JSError(rt, "Expected argument in position 4 to be passed") : args[4].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeToastAndroidCxxSpecJSI::NativeToastAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("ToastAndroid", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeToastAndroidCxxSpecJSI_getConstants};
+  methodMap_["show"] = MethodMetadata {2, __hostFunction_NativeToastAndroidCxxSpecJSI_show};
+  methodMap_["showWithGravity"] = MethodMetadata {3, __hostFunction_NativeToastAndroidCxxSpecJSI_showWithGravity};
+  methodMap_["showWithGravityAndOffset"] = MethodMetadata {5, __hostFunction_NativeToastAndroidCxxSpecJSI_showWithGravityAndOffset};
+}
+static jsi::Value __hostFunction_NativeVibrationCxxSpecJSI_getConstants(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeVibrationCxxSpecJSI *>(&turboModule)->getConstants(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativeVibrationCxxSpecJSI_vibrate(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeVibrationCxxSpecJSI *>(&turboModule)->vibrate(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeVibrationCxxSpecJSI_vibrateByPattern(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeVibrationCxxSpecJSI *>(&turboModule)->vibrateByPattern(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asArray(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeVibrationCxxSpecJSI_cancel(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeVibrationCxxSpecJSI *>(&turboModule)->cancel(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+
+NativeVibrationCxxSpecJSI::NativeVibrationCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("Vibration", jsInvoker) {
+  methodMap_["getConstants"] = MethodMetadata {0, __hostFunction_NativeVibrationCxxSpecJSI_getConstants};
+  methodMap_["vibrate"] = MethodMetadata {1, __hostFunction_NativeVibrationCxxSpecJSI_vibrate};
+  methodMap_["vibrateByPattern"] = MethodMetadata {2, __hostFunction_NativeVibrationCxxSpecJSI_vibrateByPattern};
+  methodMap_["cancel"] = MethodMetadata {0, __hostFunction_NativeVibrationCxxSpecJSI_cancel};
+}
+static jsi::Value __hostFunction_NativeWebSocketModuleCxxSpecJSI_connect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeWebSocketModuleCxxSpecJSI *>(&turboModule)->connect(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asObject(rt).asArray(rt)),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeWebSocketModuleCxxSpecJSI_send(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeWebSocketModuleCxxSpecJSI *>(&turboModule)->send(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeWebSocketModuleCxxSpecJSI_sendBinary(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeWebSocketModuleCxxSpecJSI *>(&turboModule)->sendBinary(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeWebSocketModuleCxxSpecJSI_ping(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeWebSocketModuleCxxSpecJSI *>(&turboModule)->ping(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeWebSocketModuleCxxSpecJSI_close(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeWebSocketModuleCxxSpecJSI *>(&turboModule)->close(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asString(rt),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeWebSocketModuleCxxSpecJSI_addListener(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeWebSocketModuleCxxSpecJSI *>(&turboModule)->addListener(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeWebSocketModuleCxxSpecJSI_removeListeners(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeWebSocketModuleCxxSpecJSI *>(&turboModule)->removeListeners(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+
+NativeWebSocketModuleCxxSpecJSI::NativeWebSocketModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("WebSocketModule", jsInvoker) {
+  methodMap_["connect"] = MethodMetadata {4, __hostFunction_NativeWebSocketModuleCxxSpecJSI_connect};
+  methodMap_["send"] = MethodMetadata {2, __hostFunction_NativeWebSocketModuleCxxSpecJSI_send};
+  methodMap_["sendBinary"] = MethodMetadata {2, __hostFunction_NativeWebSocketModuleCxxSpecJSI_sendBinary};
+  methodMap_["ping"] = MethodMetadata {1, __hostFunction_NativeWebSocketModuleCxxSpecJSI_ping};
+  methodMap_["close"] = MethodMetadata {3, __hostFunction_NativeWebSocketModuleCxxSpecJSI_close};
+  methodMap_["addListener"] = MethodMetadata {1, __hostFunction_NativeWebSocketModuleCxxSpecJSI_addListener};
+  methodMap_["removeListeners"] = MethodMetadata {1, __hostFunction_NativeWebSocketModuleCxxSpecJSI_removeListeners};
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_compareDocumentPosition(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->compareDocumentPosition(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getChildNodes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getChildNodes(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getParentNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getParentNode(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_isConnected(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->isConnected(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getBorderWidth(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getBorderWidth(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getBoundingClientRect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getBoundingClientRect(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool()
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getInnerSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getInnerSize(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getScrollPosition(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getScrollPosition(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getScrollSize(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getScrollSize(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getTagName(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getTagName(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getTextContent(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getTextContent(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_hasPointerCapture(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->hasPointerCapture(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_releasePointerCapture(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->releasePointerCapture(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_setPointerCapture(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->setPointerCapture(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber()
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_getOffset(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->getOffset(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_linkRootNode(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->linkRootNode(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1])
+  );
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_measure(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->measure(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_measureInWindow(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->measureInWindow(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeDOMCxxSpecJSI_measureLayout(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeDOMCxxSpecJSI *>(&turboModule)->measureLayout(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1]),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asObject(rt).asFunction(rt),
+    count <= 3 ? throw jsi::JSError(rt, "Expected argument in position 3 to be passed") : args[3].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeDOMCxxSpecJSI::NativeDOMCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativeDOMCxx", jsInvoker) {
+  methodMap_["compareDocumentPosition"] = MethodMetadata {2, __hostFunction_NativeDOMCxxSpecJSI_compareDocumentPosition};
+  methodMap_["getChildNodes"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getChildNodes};
+  methodMap_["getParentNode"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getParentNode};
+  methodMap_["isConnected"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_isConnected};
+  methodMap_["getBorderWidth"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getBorderWidth};
+  methodMap_["getBoundingClientRect"] = MethodMetadata {2, __hostFunction_NativeDOMCxxSpecJSI_getBoundingClientRect};
+  methodMap_["getInnerSize"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getInnerSize};
+  methodMap_["getScrollPosition"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getScrollPosition};
+  methodMap_["getScrollSize"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getScrollSize};
+  methodMap_["getTagName"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getTagName};
+  methodMap_["getTextContent"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getTextContent};
+  methodMap_["hasPointerCapture"] = MethodMetadata {2, __hostFunction_NativeDOMCxxSpecJSI_hasPointerCapture};
+  methodMap_["releasePointerCapture"] = MethodMetadata {2, __hostFunction_NativeDOMCxxSpecJSI_releasePointerCapture};
+  methodMap_["setPointerCapture"] = MethodMetadata {2, __hostFunction_NativeDOMCxxSpecJSI_setPointerCapture};
+  methodMap_["getOffset"] = MethodMetadata {1, __hostFunction_NativeDOMCxxSpecJSI_getOffset};
+  methodMap_["linkRootNode"] = MethodMetadata {2, __hostFunction_NativeDOMCxxSpecJSI_linkRootNode};
+  methodMap_["measure"] = MethodMetadata {2, __hostFunction_NativeDOMCxxSpecJSI_measure};
+  methodMap_["measureInWindow"] = MethodMetadata {2, __hostFunction_NativeDOMCxxSpecJSI_measureInWindow};
+  methodMap_["measureLayout"] = MethodMetadata {4, __hostFunction_NativeDOMCxxSpecJSI_measureLayout};
+}
+static jsi::Value __hostFunction_NativeIdleCallbacksCxxSpecJSI_requestIdleCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeIdleCallbacksCxxSpecJSI *>(&turboModule)->requestIdleCallback(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asObject(rt))
+  );
+}
+static jsi::Value __hostFunction_NativeIdleCallbacksCxxSpecJSI_cancelIdleCallback(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeIdleCallbacksCxxSpecJSI *>(&turboModule)->cancelIdleCallback(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+  return jsi::Value::undefined();
+}
+
+NativeIdleCallbacksCxxSpecJSI::NativeIdleCallbacksCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativeIdleCallbacksCxx", jsInvoker) {
+  methodMap_["requestIdleCallback"] = MethodMetadata {2, __hostFunction_NativeIdleCallbacksCxxSpecJSI_requestIdleCallback};
+  methodMap_["cancelIdleCallback"] = MethodMetadata {1, __hostFunction_NativeIdleCallbacksCxxSpecJSI_cancelIdleCallback};
+}
+static jsi::Value __hostFunction_NativeIntersectionObserverCxxSpecJSI_observe(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeIntersectionObserverCxxSpecJSI *>(&turboModule)->observe(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeIntersectionObserverCxxSpecJSI_unobserve(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeIntersectionObserverCxxSpecJSI *>(&turboModule)->unobserve(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1])
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeIntersectionObserverCxxSpecJSI_connect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeIntersectionObserverCxxSpecJSI *>(&turboModule)->connect(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeIntersectionObserverCxxSpecJSI_disconnect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeIntersectionObserverCxxSpecJSI *>(&turboModule)->disconnect(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeIntersectionObserverCxxSpecJSI_takeRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeIntersectionObserverCxxSpecJSI *>(&turboModule)->takeRecords(
+    rt
+  );
+}
+
+NativeIntersectionObserverCxxSpecJSI::NativeIntersectionObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativeIntersectionObserverCxx", jsInvoker) {
+  methodMap_["observe"] = MethodMetadata {1, __hostFunction_NativeIntersectionObserverCxxSpecJSI_observe};
+  methodMap_["unobserve"] = MethodMetadata {2, __hostFunction_NativeIntersectionObserverCxxSpecJSI_unobserve};
+  methodMap_["connect"] = MethodMetadata {1, __hostFunction_NativeIntersectionObserverCxxSpecJSI_connect};
+  methodMap_["disconnect"] = MethodMetadata {0, __hostFunction_NativeIntersectionObserverCxxSpecJSI_disconnect};
+  methodMap_["takeRecords"] = MethodMetadata {0, __hostFunction_NativeIntersectionObserverCxxSpecJSI_takeRecords};
+}
+static jsi::Value __hostFunction_NativeMicrotasksCxxSpecJSI_queueMicrotask(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeMicrotasksCxxSpecJSI *>(&turboModule)->queueMicrotask(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+
+NativeMicrotasksCxxSpecJSI::NativeMicrotasksCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativeMicrotasksCxx", jsInvoker) {
+  methodMap_["queueMicrotask"] = MethodMetadata {1, __hostFunction_NativeMicrotasksCxxSpecJSI_queueMicrotask};
+}
+static jsi::Value __hostFunction_NativeMutationObserverCxxSpecJSI_observe(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeMutationObserverCxxSpecJSI *>(&turboModule)->observe(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeMutationObserverCxxSpecJSI_unobserve(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeMutationObserverCxxSpecJSI *>(&turboModule)->unobserve(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber(),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : jsi::Value(rt, args[1])
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeMutationObserverCxxSpecJSI_connect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeMutationObserverCxxSpecJSI *>(&turboModule)->connect(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt).asFunction(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeMutationObserverCxxSpecJSI_disconnect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativeMutationObserverCxxSpecJSI *>(&turboModule)->disconnect(
+    rt
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativeMutationObserverCxxSpecJSI_takeRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativeMutationObserverCxxSpecJSI *>(&turboModule)->takeRecords(
+    rt
+  );
+}
+
+NativeMutationObserverCxxSpecJSI::NativeMutationObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativeMutationObserverCxx", jsInvoker) {
+  methodMap_["observe"] = MethodMetadata {1, __hostFunction_NativeMutationObserverCxxSpecJSI_observe};
+  methodMap_["unobserve"] = MethodMetadata {2, __hostFunction_NativeMutationObserverCxxSpecJSI_unobserve};
+  methodMap_["connect"] = MethodMetadata {2, __hostFunction_NativeMutationObserverCxxSpecJSI_connect};
+  methodMap_["disconnect"] = MethodMetadata {0, __hostFunction_NativeMutationObserverCxxSpecJSI_disconnect};
+  methodMap_["takeRecords"] = MethodMetadata {0, __hostFunction_NativeMutationObserverCxxSpecJSI_takeRecords};
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_now(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->now(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_markWithResult(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->markWithResult(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asNumber())
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_measureWithResult(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->measureWithResult(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asNumber(),
+    count <= 2 ? throw jsi::JSError(rt, "Expected argument in position 2 to be passed") : args[2].asNumber(),
+    count <= 3 || args[3].isUndefined() ? std::nullopt : std::make_optional(args[3].asNumber()),
+    count <= 4 || args[4].isUndefined() ? std::nullopt : std::make_optional(args[4].asString(rt)),
+    count <= 5 || args[5].isUndefined() ? std::nullopt : std::make_optional(args[5].asString(rt))
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_clearMarks(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->clearMarks(
+    rt,
+    count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt))
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_clearMeasures(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->clearMeasures(
+    rt,
+    count <= 0 || args[0].isUndefined() ? std::nullopt : std::make_optional(args[0].asString(rt))
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_getEntries(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->getEntries(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_getEntriesByName(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->getEntriesByName(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asString(rt),
+    count <= 1 || args[1].isNull() || args[1].isUndefined() ? std::nullopt : std::make_optional(args[1].asNumber())
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_getEntriesByType(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->getEntriesByType(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asNumber()
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_getEventCounts(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->getEventCounts(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_getSimpleMemoryInfo(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->getSimpleMemoryInfo(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_getReactNativeStartupTiming(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->getReactNativeStartupTiming(
+    rt
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_createObserver(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->createObserver(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : args[0].asObject(rt).asFunction(rt)
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_getDroppedEntriesCount(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->getDroppedEntriesCount(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_observe(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->observe(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asObject(rt)
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_disconnect(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->disconnect(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0])
+  );
+  return jsi::Value::undefined();
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_takeRecords(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->takeRecords(
+    rt,
+    count <= 0 ? throw jsi::JSError(rt, "Expected argument in position 0 to be passed") : jsi::Value(rt, args[0]),
+    count <= 1 ? throw jsi::JSError(rt, "Expected argument in position 1 to be passed") : args[1].asBool()
+  );
+}
+static jsi::Value __hostFunction_NativePerformanceCxxSpecJSI_getSupportedPerformanceEntryTypes(jsi::Runtime &rt, TurboModule &turboModule, const jsi::Value* args, size_t count) {
+  return static_cast<NativePerformanceCxxSpecJSI *>(&turboModule)->getSupportedPerformanceEntryTypes(
+    rt
+  );
+}
+
+NativePerformanceCxxSpecJSI::NativePerformanceCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker)
+  : TurboModule("NativePerformanceCxx", jsInvoker) {
+  methodMap_["now"] = MethodMetadata {0, __hostFunction_NativePerformanceCxxSpecJSI_now};
+  methodMap_["markWithResult"] = MethodMetadata {2, __hostFunction_NativePerformanceCxxSpecJSI_markWithResult};
+  methodMap_["measureWithResult"] = MethodMetadata {6, __hostFunction_NativePerformanceCxxSpecJSI_measureWithResult};
+  methodMap_["clearMarks"] = MethodMetadata {1, __hostFunction_NativePerformanceCxxSpecJSI_clearMarks};
+  methodMap_["clearMeasures"] = MethodMetadata {1, __hostFunction_NativePerformanceCxxSpecJSI_clearMeasures};
+  methodMap_["getEntries"] = MethodMetadata {0, __hostFunction_NativePerformanceCxxSpecJSI_getEntries};
+  methodMap_["getEntriesByName"] = MethodMetadata {2, __hostFunction_NativePerformanceCxxSpecJSI_getEntriesByName};
+  methodMap_["getEntriesByType"] = MethodMetadata {1, __hostFunction_NativePerformanceCxxSpecJSI_getEntriesByType};
+  methodMap_["getEventCounts"] = MethodMetadata {0, __hostFunction_NativePerformanceCxxSpecJSI_getEventCounts};
+  methodMap_["getSimpleMemoryInfo"] = MethodMetadata {0, __hostFunction_NativePerformanceCxxSpecJSI_getSimpleMemoryInfo};
+  methodMap_["getReactNativeStartupTiming"] = MethodMetadata {0, __hostFunction_NativePerformanceCxxSpecJSI_getReactNativeStartupTiming};
+  methodMap_["createObserver"] = MethodMetadata {1, __hostFunction_NativePerformanceCxxSpecJSI_createObserver};
+  methodMap_["getDroppedEntriesCount"] = MethodMetadata {1, __hostFunction_NativePerformanceCxxSpecJSI_getDroppedEntriesCount};
+  methodMap_["observe"] = MethodMetadata {2, __hostFunction_NativePerformanceCxxSpecJSI_observe};
+  methodMap_["disconnect"] = MethodMetadata {1, __hostFunction_NativePerformanceCxxSpecJSI_disconnect};
+  methodMap_["takeRecords"] = MethodMetadata {2, __hostFunction_NativePerformanceCxxSpecJSI_takeRecords};
+  methodMap_["getSupportedPerformanceEntryTypes"] = MethodMetadata {0, __hostFunction_NativePerformanceCxxSpecJSI_getSupportedPerformanceEntryTypes};
+}
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/FBReactNativeSpec/FBReactNativeSpecJSI.h b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/FBReactNativeSpec/FBReactNativeSpecJSI.h
new file mode 100644
index 0000000..4f6a584
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/FBReactNativeSpec/FBReactNativeSpecJSI.h
@@ -0,0 +1,8156 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateModuleH.js
+ */
+
+#pragma once
+
+#include <ReactCommon/TurboModule.h>
+#include <react/bridging/Bridging.h>
+
+namespace facebook::react {
+
+
+  class JSI_EXPORT NativeDevMenuCxxSpecJSI : public TurboModule {
+protected:
+  NativeDevMenuCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void show(jsi::Runtime &rt) = 0;
+  virtual void reload(jsi::Runtime &rt) = 0;
+  virtual void setProfilingEnabled(jsi::Runtime &rt, bool enabled) = 0;
+  virtual void setHotLoadingEnabled(jsi::Runtime &rt, bool enabled) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeDevMenuCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "DevMenu";
+
+protected:
+  NativeDevMenuCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeDevMenuCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeDevMenuCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeDevMenuCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void show(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::show) == 1,
+          "Expected show(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::show, jsInvoker_, instance_);
+    }
+    void reload(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::reload) == 1,
+          "Expected reload(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::reload, jsInvoker_, instance_);
+    }
+    void setProfilingEnabled(jsi::Runtime &rt, bool enabled) override {
+      static_assert(
+          bridging::getParameterCount(&T::setProfilingEnabled) == 2,
+          "Expected setProfilingEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setProfilingEnabled, jsInvoker_, instance_, std::move(enabled));
+    }
+    void setHotLoadingEnabled(jsi::Runtime &rt, bool enabled) override {
+      static_assert(
+          bridging::getParameterCount(&T::setHotLoadingEnabled) == 2,
+          "Expected setHotLoadingEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setHotLoadingEnabled, jsInvoker_, instance_, std::move(enabled));
+    }
+
+  private:
+    friend class NativeDevMenuCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeReactDevToolsRuntimeSettingsModulePartialReloadAndProfileConfig
+
+template <typename P0, typename P1>
+struct NativeReactDevToolsRuntimeSettingsModulePartialReloadAndProfileConfig {
+  P0 shouldReloadAndProfile;
+  P1 recordChangeDescriptions;
+  bool operator==(const NativeReactDevToolsRuntimeSettingsModulePartialReloadAndProfileConfig &other) const {
+    return shouldReloadAndProfile == other.shouldReloadAndProfile && recordChangeDescriptions == other.recordChangeDescriptions;
+  }
+};
+
+template <typename T>
+struct NativeReactDevToolsRuntimeSettingsModulePartialReloadAndProfileConfigBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.shouldReloadAndProfile)>(rt, value.getProperty(rt, "shouldReloadAndProfile"), jsInvoker),
+      bridging::fromJs<decltype(types.recordChangeDescriptions)>(rt, value.getProperty(rt, "recordChangeDescriptions"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool shouldReloadAndProfileToJs(jsi::Runtime &rt, decltype(types.shouldReloadAndProfile) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool recordChangeDescriptionsToJs(jsi::Runtime &rt, decltype(types.recordChangeDescriptions) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    if (value.shouldReloadAndProfile) {
+      result.setProperty(rt, "shouldReloadAndProfile", bridging::toJs(rt, value.shouldReloadAndProfile.value(), jsInvoker));
+    }
+    if (value.recordChangeDescriptions) {
+      result.setProperty(rt, "recordChangeDescriptions", bridging::toJs(rt, value.recordChangeDescriptions.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeReactDevToolsRuntimeSettingsModuleReloadAndProfileConfig
+
+template <typename P0, typename P1>
+struct NativeReactDevToolsRuntimeSettingsModuleReloadAndProfileConfig {
+  P0 shouldReloadAndProfile;
+  P1 recordChangeDescriptions;
+  bool operator==(const NativeReactDevToolsRuntimeSettingsModuleReloadAndProfileConfig &other) const {
+    return shouldReloadAndProfile == other.shouldReloadAndProfile && recordChangeDescriptions == other.recordChangeDescriptions;
+  }
+};
+
+template <typename T>
+struct NativeReactDevToolsRuntimeSettingsModuleReloadAndProfileConfigBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.shouldReloadAndProfile)>(rt, value.getProperty(rt, "shouldReloadAndProfile"), jsInvoker),
+      bridging::fromJs<decltype(types.recordChangeDescriptions)>(rt, value.getProperty(rt, "recordChangeDescriptions"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool shouldReloadAndProfileToJs(jsi::Runtime &rt, decltype(types.shouldReloadAndProfile) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool recordChangeDescriptionsToJs(jsi::Runtime &rt, decltype(types.recordChangeDescriptions) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "shouldReloadAndProfile", bridging::toJs(rt, value.shouldReloadAndProfile, jsInvoker));
+    result.setProperty(rt, "recordChangeDescriptions", bridging::toJs(rt, value.recordChangeDescriptions, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void setReloadAndProfileConfig(jsi::Runtime &rt, jsi::Object config) = 0;
+  virtual jsi::Object getReloadAndProfileConfig(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeReactDevToolsRuntimeSettingsModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ReactDevToolsRuntimeSettingsModule";
+
+protected:
+  NativeReactDevToolsRuntimeSettingsModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeReactDevToolsRuntimeSettingsModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeReactDevToolsRuntimeSettingsModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void setReloadAndProfileConfig(jsi::Runtime &rt, jsi::Object config) override {
+      static_assert(
+          bridging::getParameterCount(&T::setReloadAndProfileConfig) == 2,
+          "Expected setReloadAndProfileConfig(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setReloadAndProfileConfig, jsInvoker_, instance_, std::move(config));
+    }
+    jsi::Object getReloadAndProfileConfig(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getReloadAndProfileConfig) == 1,
+          "Expected getReloadAndProfileConfig(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getReloadAndProfileConfig, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeReactDevToolsRuntimeSettingsModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeReactDevToolsSettingsManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeReactDevToolsSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void setGlobalHookSettings(jsi::Runtime &rt, jsi::String settings) = 0;
+  virtual std::optional<jsi::String> getGlobalHookSettings(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeReactDevToolsSettingsManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ReactDevToolsSettingsManager";
+
+protected:
+  NativeReactDevToolsSettingsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeReactDevToolsSettingsManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeReactDevToolsSettingsManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeReactDevToolsSettingsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void setGlobalHookSettings(jsi::Runtime &rt, jsi::String settings) override {
+      static_assert(
+          bridging::getParameterCount(&T::setGlobalHookSettings) == 2,
+          "Expected setGlobalHookSettings(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setGlobalHookSettings, jsInvoker_, instance_, std::move(settings));
+    }
+    std::optional<jsi::String> getGlobalHookSettings(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getGlobalHookSettings) == 1,
+          "Expected getGlobalHookSettings(...) to have 1 parameters");
+
+      return bridging::callFromJs<std::optional<jsi::String>>(
+          rt, &T::getGlobalHookSettings, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeReactDevToolsSettingsManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeReactNativeFeatureFlagsCxxSpecJSI : public TurboModule {
+protected:
+  NativeReactNativeFeatureFlagsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual bool commonTestFlag(jsi::Runtime &rt) = 0;
+  virtual bool commonTestFlagWithoutNativeImplementation(jsi::Runtime &rt) = 0;
+  virtual bool animatedShouldSignalBatch(jsi::Runtime &rt) = 0;
+  virtual bool cxxNativeAnimatedEnabled(jsi::Runtime &rt) = 0;
+  virtual bool disableMainQueueSyncDispatchIOS(jsi::Runtime &rt) = 0;
+  virtual bool disableMountItemReorderingAndroid(jsi::Runtime &rt) = 0;
+  virtual bool enableAccessibilityOrder(jsi::Runtime &rt) = 0;
+  virtual bool enableAccumulatedUpdatesInRawPropsAndroid(jsi::Runtime &rt) = 0;
+  virtual bool enableBridgelessArchitecture(jsi::Runtime &rt) = 0;
+  virtual bool enableCppPropsIteratorSetter(jsi::Runtime &rt) = 0;
+  virtual bool enableCustomFocusSearchOnClippedElementsAndroid(jsi::Runtime &rt) = 0;
+  virtual bool enableDestroyShadowTreeRevisionAsync(jsi::Runtime &rt) = 0;
+  virtual bool enableDoubleMeasurementFixAndroid(jsi::Runtime &rt) = 0;
+  virtual bool enableEagerRootViewAttachment(jsi::Runtime &rt) = 0;
+  virtual bool enableFabricLogs(jsi::Runtime &rt) = 0;
+  virtual bool enableFabricRenderer(jsi::Runtime &rt) = 0;
+  virtual bool enableFixForParentTagDuringReparenting(jsi::Runtime &rt) = 0;
+  virtual bool enableFontScaleChangesUpdatingLayout(jsi::Runtime &rt) = 0;
+  virtual bool enableIOSViewClipToPaddingBox(jsi::Runtime &rt) = 0;
+  virtual bool enableJSRuntimeGCOnMemoryPressureOnIOS(jsi::Runtime &rt) = 0;
+  virtual bool enableLayoutAnimationsOnAndroid(jsi::Runtime &rt) = 0;
+  virtual bool enableLayoutAnimationsOnIOS(jsi::Runtime &rt) = 0;
+  virtual bool enableMainQueueModulesOnIOS(jsi::Runtime &rt) = 0;
+  virtual bool enableNativeCSSParsing(jsi::Runtime &rt) = 0;
+  virtual bool enableNetworkEventReporting(jsi::Runtime &rt) = 0;
+  virtual bool enableNewBackgroundAndBorderDrawables(jsi::Runtime &rt) = 0;
+  virtual bool enablePreparedTextLayout(jsi::Runtime &rt) = 0;
+  virtual bool enablePropsUpdateReconciliationAndroid(jsi::Runtime &rt) = 0;
+  virtual bool enableResourceTimingAPI(jsi::Runtime &rt) = 0;
+  virtual bool enableSynchronousStateUpdates(jsi::Runtime &rt) = 0;
+  virtual bool enableViewCulling(jsi::Runtime &rt) = 0;
+  virtual bool enableViewRecycling(jsi::Runtime &rt) = 0;
+  virtual bool enableViewRecyclingForText(jsi::Runtime &rt) = 0;
+  virtual bool enableViewRecyclingForView(jsi::Runtime &rt) = 0;
+  virtual bool fixMappingOfEventPrioritiesBetweenFabricAndReact(jsi::Runtime &rt) = 0;
+  virtual bool fuseboxEnabledRelease(jsi::Runtime &rt) = 0;
+  virtual bool fuseboxNetworkInspectionEnabled(jsi::Runtime &rt) = 0;
+  virtual bool incorporateMaxLinesDuringAndroidLayout(jsi::Runtime &rt) = 0;
+  virtual bool traceTurboModulePromiseRejectionsOnAndroid(jsi::Runtime &rt) = 0;
+  virtual bool updateRuntimeShadowNodeReferencesOnCommit(jsi::Runtime &rt) = 0;
+  virtual bool useAlwaysAvailableJSErrorHandling(jsi::Runtime &rt) = 0;
+  virtual bool useFabricInterop(jsi::Runtime &rt) = 0;
+  virtual bool useNativeViewConfigsInBridgelessMode(jsi::Runtime &rt) = 0;
+  virtual bool useOptimizedEventBatchingOnAndroid(jsi::Runtime &rt) = 0;
+  virtual bool useRawPropsJsiValue(jsi::Runtime &rt) = 0;
+  virtual bool useShadowNodeStateOnClone(jsi::Runtime &rt) = 0;
+  virtual bool useTurboModuleInterop(jsi::Runtime &rt) = 0;
+  virtual bool useTurboModules(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeReactNativeFeatureFlagsCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativeReactNativeFeatureFlagsCxx";
+
+protected:
+  NativeReactNativeFeatureFlagsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeReactNativeFeatureFlagsCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeReactNativeFeatureFlagsCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeReactNativeFeatureFlagsCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    bool commonTestFlag(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::commonTestFlag) == 1,
+          "Expected commonTestFlag(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::commonTestFlag, jsInvoker_, instance_);
+    }
+    bool commonTestFlagWithoutNativeImplementation(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::commonTestFlagWithoutNativeImplementation) == 1,
+          "Expected commonTestFlagWithoutNativeImplementation(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::commonTestFlagWithoutNativeImplementation, jsInvoker_, instance_);
+    }
+    bool animatedShouldSignalBatch(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::animatedShouldSignalBatch) == 1,
+          "Expected animatedShouldSignalBatch(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::animatedShouldSignalBatch, jsInvoker_, instance_);
+    }
+    bool cxxNativeAnimatedEnabled(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::cxxNativeAnimatedEnabled) == 1,
+          "Expected cxxNativeAnimatedEnabled(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::cxxNativeAnimatedEnabled, jsInvoker_, instance_);
+    }
+    bool disableMainQueueSyncDispatchIOS(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::disableMainQueueSyncDispatchIOS) == 1,
+          "Expected disableMainQueueSyncDispatchIOS(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::disableMainQueueSyncDispatchIOS, jsInvoker_, instance_);
+    }
+    bool disableMountItemReorderingAndroid(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::disableMountItemReorderingAndroid) == 1,
+          "Expected disableMountItemReorderingAndroid(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::disableMountItemReorderingAndroid, jsInvoker_, instance_);
+    }
+    bool enableAccessibilityOrder(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableAccessibilityOrder) == 1,
+          "Expected enableAccessibilityOrder(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableAccessibilityOrder, jsInvoker_, instance_);
+    }
+    bool enableAccumulatedUpdatesInRawPropsAndroid(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableAccumulatedUpdatesInRawPropsAndroid) == 1,
+          "Expected enableAccumulatedUpdatesInRawPropsAndroid(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableAccumulatedUpdatesInRawPropsAndroid, jsInvoker_, instance_);
+    }
+    bool enableBridgelessArchitecture(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableBridgelessArchitecture) == 1,
+          "Expected enableBridgelessArchitecture(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableBridgelessArchitecture, jsInvoker_, instance_);
+    }
+    bool enableCppPropsIteratorSetter(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableCppPropsIteratorSetter) == 1,
+          "Expected enableCppPropsIteratorSetter(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableCppPropsIteratorSetter, jsInvoker_, instance_);
+    }
+    bool enableCustomFocusSearchOnClippedElementsAndroid(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableCustomFocusSearchOnClippedElementsAndroid) == 1,
+          "Expected enableCustomFocusSearchOnClippedElementsAndroid(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableCustomFocusSearchOnClippedElementsAndroid, jsInvoker_, instance_);
+    }
+    bool enableDestroyShadowTreeRevisionAsync(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableDestroyShadowTreeRevisionAsync) == 1,
+          "Expected enableDestroyShadowTreeRevisionAsync(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableDestroyShadowTreeRevisionAsync, jsInvoker_, instance_);
+    }
+    bool enableDoubleMeasurementFixAndroid(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableDoubleMeasurementFixAndroid) == 1,
+          "Expected enableDoubleMeasurementFixAndroid(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableDoubleMeasurementFixAndroid, jsInvoker_, instance_);
+    }
+    bool enableEagerRootViewAttachment(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableEagerRootViewAttachment) == 1,
+          "Expected enableEagerRootViewAttachment(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableEagerRootViewAttachment, jsInvoker_, instance_);
+    }
+    bool enableFabricLogs(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableFabricLogs) == 1,
+          "Expected enableFabricLogs(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableFabricLogs, jsInvoker_, instance_);
+    }
+    bool enableFabricRenderer(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableFabricRenderer) == 1,
+          "Expected enableFabricRenderer(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableFabricRenderer, jsInvoker_, instance_);
+    }
+    bool enableFixForParentTagDuringReparenting(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableFixForParentTagDuringReparenting) == 1,
+          "Expected enableFixForParentTagDuringReparenting(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableFixForParentTagDuringReparenting, jsInvoker_, instance_);
+    }
+    bool enableFontScaleChangesUpdatingLayout(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableFontScaleChangesUpdatingLayout) == 1,
+          "Expected enableFontScaleChangesUpdatingLayout(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableFontScaleChangesUpdatingLayout, jsInvoker_, instance_);
+    }
+    bool enableIOSViewClipToPaddingBox(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableIOSViewClipToPaddingBox) == 1,
+          "Expected enableIOSViewClipToPaddingBox(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableIOSViewClipToPaddingBox, jsInvoker_, instance_);
+    }
+    bool enableJSRuntimeGCOnMemoryPressureOnIOS(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableJSRuntimeGCOnMemoryPressureOnIOS) == 1,
+          "Expected enableJSRuntimeGCOnMemoryPressureOnIOS(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableJSRuntimeGCOnMemoryPressureOnIOS, jsInvoker_, instance_);
+    }
+    bool enableLayoutAnimationsOnAndroid(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableLayoutAnimationsOnAndroid) == 1,
+          "Expected enableLayoutAnimationsOnAndroid(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableLayoutAnimationsOnAndroid, jsInvoker_, instance_);
+    }
+    bool enableLayoutAnimationsOnIOS(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableLayoutAnimationsOnIOS) == 1,
+          "Expected enableLayoutAnimationsOnIOS(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableLayoutAnimationsOnIOS, jsInvoker_, instance_);
+    }
+    bool enableMainQueueModulesOnIOS(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableMainQueueModulesOnIOS) == 1,
+          "Expected enableMainQueueModulesOnIOS(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableMainQueueModulesOnIOS, jsInvoker_, instance_);
+    }
+    bool enableNativeCSSParsing(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableNativeCSSParsing) == 1,
+          "Expected enableNativeCSSParsing(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableNativeCSSParsing, jsInvoker_, instance_);
+    }
+    bool enableNetworkEventReporting(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableNetworkEventReporting) == 1,
+          "Expected enableNetworkEventReporting(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableNetworkEventReporting, jsInvoker_, instance_);
+    }
+    bool enableNewBackgroundAndBorderDrawables(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableNewBackgroundAndBorderDrawables) == 1,
+          "Expected enableNewBackgroundAndBorderDrawables(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableNewBackgroundAndBorderDrawables, jsInvoker_, instance_);
+    }
+    bool enablePreparedTextLayout(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enablePreparedTextLayout) == 1,
+          "Expected enablePreparedTextLayout(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enablePreparedTextLayout, jsInvoker_, instance_);
+    }
+    bool enablePropsUpdateReconciliationAndroid(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enablePropsUpdateReconciliationAndroid) == 1,
+          "Expected enablePropsUpdateReconciliationAndroid(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enablePropsUpdateReconciliationAndroid, jsInvoker_, instance_);
+    }
+    bool enableResourceTimingAPI(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableResourceTimingAPI) == 1,
+          "Expected enableResourceTimingAPI(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableResourceTimingAPI, jsInvoker_, instance_);
+    }
+    bool enableSynchronousStateUpdates(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableSynchronousStateUpdates) == 1,
+          "Expected enableSynchronousStateUpdates(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableSynchronousStateUpdates, jsInvoker_, instance_);
+    }
+    bool enableViewCulling(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableViewCulling) == 1,
+          "Expected enableViewCulling(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableViewCulling, jsInvoker_, instance_);
+    }
+    bool enableViewRecycling(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableViewRecycling) == 1,
+          "Expected enableViewRecycling(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableViewRecycling, jsInvoker_, instance_);
+    }
+    bool enableViewRecyclingForText(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableViewRecyclingForText) == 1,
+          "Expected enableViewRecyclingForText(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableViewRecyclingForText, jsInvoker_, instance_);
+    }
+    bool enableViewRecyclingForView(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::enableViewRecyclingForView) == 1,
+          "Expected enableViewRecyclingForView(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::enableViewRecyclingForView, jsInvoker_, instance_);
+    }
+    bool fixMappingOfEventPrioritiesBetweenFabricAndReact(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::fixMappingOfEventPrioritiesBetweenFabricAndReact) == 1,
+          "Expected fixMappingOfEventPrioritiesBetweenFabricAndReact(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::fixMappingOfEventPrioritiesBetweenFabricAndReact, jsInvoker_, instance_);
+    }
+    bool fuseboxEnabledRelease(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::fuseboxEnabledRelease) == 1,
+          "Expected fuseboxEnabledRelease(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::fuseboxEnabledRelease, jsInvoker_, instance_);
+    }
+    bool fuseboxNetworkInspectionEnabled(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::fuseboxNetworkInspectionEnabled) == 1,
+          "Expected fuseboxNetworkInspectionEnabled(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::fuseboxNetworkInspectionEnabled, jsInvoker_, instance_);
+    }
+    bool incorporateMaxLinesDuringAndroidLayout(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::incorporateMaxLinesDuringAndroidLayout) == 1,
+          "Expected incorporateMaxLinesDuringAndroidLayout(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::incorporateMaxLinesDuringAndroidLayout, jsInvoker_, instance_);
+    }
+    bool traceTurboModulePromiseRejectionsOnAndroid(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::traceTurboModulePromiseRejectionsOnAndroid) == 1,
+          "Expected traceTurboModulePromiseRejectionsOnAndroid(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::traceTurboModulePromiseRejectionsOnAndroid, jsInvoker_, instance_);
+    }
+    bool updateRuntimeShadowNodeReferencesOnCommit(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::updateRuntimeShadowNodeReferencesOnCommit) == 1,
+          "Expected updateRuntimeShadowNodeReferencesOnCommit(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::updateRuntimeShadowNodeReferencesOnCommit, jsInvoker_, instance_);
+    }
+    bool useAlwaysAvailableJSErrorHandling(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::useAlwaysAvailableJSErrorHandling) == 1,
+          "Expected useAlwaysAvailableJSErrorHandling(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::useAlwaysAvailableJSErrorHandling, jsInvoker_, instance_);
+    }
+    bool useFabricInterop(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::useFabricInterop) == 1,
+          "Expected useFabricInterop(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::useFabricInterop, jsInvoker_, instance_);
+    }
+    bool useNativeViewConfigsInBridgelessMode(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::useNativeViewConfigsInBridgelessMode) == 1,
+          "Expected useNativeViewConfigsInBridgelessMode(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::useNativeViewConfigsInBridgelessMode, jsInvoker_, instance_);
+    }
+    bool useOptimizedEventBatchingOnAndroid(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::useOptimizedEventBatchingOnAndroid) == 1,
+          "Expected useOptimizedEventBatchingOnAndroid(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::useOptimizedEventBatchingOnAndroid, jsInvoker_, instance_);
+    }
+    bool useRawPropsJsiValue(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::useRawPropsJsiValue) == 1,
+          "Expected useRawPropsJsiValue(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::useRawPropsJsiValue, jsInvoker_, instance_);
+    }
+    bool useShadowNodeStateOnClone(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::useShadowNodeStateOnClone) == 1,
+          "Expected useShadowNodeStateOnClone(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::useShadowNodeStateOnClone, jsInvoker_, instance_);
+    }
+    bool useTurboModuleInterop(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::useTurboModuleInterop) == 1,
+          "Expected useTurboModuleInterop(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::useTurboModuleInterop, jsInvoker_, instance_);
+    }
+    bool useTurboModules(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::useTurboModules) == 1,
+          "Expected useTurboModules(...) to have 1 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::useTurboModules, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeReactNativeFeatureFlagsCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeAccessibilityInfoCxxSpecJSI : public TurboModule {
+protected:
+  NativeAccessibilityInfoCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void isReduceMotionEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
+  virtual void isInvertColorsEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
+  virtual void isHighTextContrastEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
+  virtual void isTouchExplorationEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
+  virtual void isAccessibilityServiceEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
+  virtual void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) = 0;
+  virtual void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) = 0;
+  virtual void getRecommendedTimeoutMillis(jsi::Runtime &rt, double mSec, jsi::Function onSuccess) = 0;
+  virtual void isGrayscaleEnabled(jsi::Runtime &rt, jsi::Function onSuccess) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeAccessibilityInfoCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "AccessibilityInfo";
+
+protected:
+  NativeAccessibilityInfoCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeAccessibilityInfoCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeAccessibilityInfoCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeAccessibilityInfoCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void isReduceMotionEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
+      static_assert(
+          bridging::getParameterCount(&T::isReduceMotionEnabled) == 2,
+          "Expected isReduceMotionEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::isReduceMotionEnabled, jsInvoker_, instance_, std::move(onSuccess));
+    }
+    void isInvertColorsEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
+      static_assert(
+          bridging::getParameterCount(&T::isInvertColorsEnabled) == 2,
+          "Expected isInvertColorsEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::isInvertColorsEnabled, jsInvoker_, instance_, std::move(onSuccess));
+    }
+    void isHighTextContrastEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
+      static_assert(
+          bridging::getParameterCount(&T::isHighTextContrastEnabled) == 2,
+          "Expected isHighTextContrastEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::isHighTextContrastEnabled, jsInvoker_, instance_, std::move(onSuccess));
+    }
+    void isTouchExplorationEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
+      static_assert(
+          bridging::getParameterCount(&T::isTouchExplorationEnabled) == 2,
+          "Expected isTouchExplorationEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::isTouchExplorationEnabled, jsInvoker_, instance_, std::move(onSuccess));
+    }
+    void isAccessibilityServiceEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
+      static_assert(
+          bridging::getParameterCount(&T::isAccessibilityServiceEnabled) == 2,
+          "Expected isAccessibilityServiceEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::isAccessibilityServiceEnabled, jsInvoker_, instance_, std::move(onSuccess));
+    }
+    void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::setAccessibilityFocus) == 2,
+          "Expected setAccessibilityFocus(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setAccessibilityFocus, jsInvoker_, instance_, std::move(reactTag));
+    }
+    void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) override {
+      static_assert(
+          bridging::getParameterCount(&T::announceForAccessibility) == 2,
+          "Expected announceForAccessibility(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::announceForAccessibility, jsInvoker_, instance_, std::move(announcement));
+    }
+    void getRecommendedTimeoutMillis(jsi::Runtime &rt, double mSec, jsi::Function onSuccess) override {
+      static_assert(
+          bridging::getParameterCount(&T::getRecommendedTimeoutMillis) == 3,
+          "Expected getRecommendedTimeoutMillis(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getRecommendedTimeoutMillis, jsInvoker_, instance_, std::move(mSec), std::move(onSuccess));
+    }
+    void isGrayscaleEnabled(jsi::Runtime &rt, jsi::Function onSuccess) override {
+      static_assert(
+          bridging::getParameterCount(&T::isGrayscaleEnabled) == 2,
+          "Expected isGrayscaleEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::isGrayscaleEnabled, jsInvoker_, instance_, std::move(onSuccess));
+    }
+
+  private:
+    friend class NativeAccessibilityInfoCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeAccessibilityManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeAccessibilityManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void getCurrentBoldTextState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
+  virtual void getCurrentGrayscaleState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
+  virtual void getCurrentInvertColorsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
+  virtual void getCurrentReduceMotionState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
+  virtual void getCurrentDarkerSystemColorsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
+  virtual void getCurrentPrefersCrossFadeTransitionsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
+  virtual void getCurrentReduceTransparencyState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
+  virtual void getCurrentVoiceOverState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) = 0;
+  virtual void setAccessibilityContentSizeMultipliers(jsi::Runtime &rt, jsi::Object JSMultipliers) = 0;
+  virtual void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) = 0;
+  virtual void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) = 0;
+  virtual void announceForAccessibilityWithOptions(jsi::Runtime &rt, jsi::String announcement, jsi::Object options) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeAccessibilityManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "AccessibilityManager";
+
+protected:
+  NativeAccessibilityManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeAccessibilityManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeAccessibilityManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeAccessibilityManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void getCurrentBoldTextState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentBoldTextState) == 3,
+          "Expected getCurrentBoldTextState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentBoldTextState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
+    }
+    void getCurrentGrayscaleState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentGrayscaleState) == 3,
+          "Expected getCurrentGrayscaleState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentGrayscaleState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
+    }
+    void getCurrentInvertColorsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentInvertColorsState) == 3,
+          "Expected getCurrentInvertColorsState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentInvertColorsState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
+    }
+    void getCurrentReduceMotionState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentReduceMotionState) == 3,
+          "Expected getCurrentReduceMotionState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentReduceMotionState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
+    }
+    void getCurrentDarkerSystemColorsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentDarkerSystemColorsState) == 3,
+          "Expected getCurrentDarkerSystemColorsState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentDarkerSystemColorsState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
+    }
+    void getCurrentPrefersCrossFadeTransitionsState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentPrefersCrossFadeTransitionsState) == 3,
+          "Expected getCurrentPrefersCrossFadeTransitionsState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentPrefersCrossFadeTransitionsState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
+    }
+    void getCurrentReduceTransparencyState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentReduceTransparencyState) == 3,
+          "Expected getCurrentReduceTransparencyState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentReduceTransparencyState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
+    }
+    void getCurrentVoiceOverState(jsi::Runtime &rt, jsi::Function onSuccess, jsi::Function onError) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentVoiceOverState) == 3,
+          "Expected getCurrentVoiceOverState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentVoiceOverState, jsInvoker_, instance_, std::move(onSuccess), std::move(onError));
+    }
+    void setAccessibilityContentSizeMultipliers(jsi::Runtime &rt, jsi::Object JSMultipliers) override {
+      static_assert(
+          bridging::getParameterCount(&T::setAccessibilityContentSizeMultipliers) == 2,
+          "Expected setAccessibilityContentSizeMultipliers(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setAccessibilityContentSizeMultipliers, jsInvoker_, instance_, std::move(JSMultipliers));
+    }
+    void setAccessibilityFocus(jsi::Runtime &rt, double reactTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::setAccessibilityFocus) == 2,
+          "Expected setAccessibilityFocus(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setAccessibilityFocus, jsInvoker_, instance_, std::move(reactTag));
+    }
+    void announceForAccessibility(jsi::Runtime &rt, jsi::String announcement) override {
+      static_assert(
+          bridging::getParameterCount(&T::announceForAccessibility) == 2,
+          "Expected announceForAccessibility(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::announceForAccessibility, jsInvoker_, instance_, std::move(announcement));
+    }
+    void announceForAccessibilityWithOptions(jsi::Runtime &rt, jsi::String announcement, jsi::Object options) override {
+      static_assert(
+          bridging::getParameterCount(&T::announceForAccessibilityWithOptions) == 3,
+          "Expected announceForAccessibilityWithOptions(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::announceForAccessibilityWithOptions, jsInvoker_, instance_, std::move(announcement), std::move(options));
+    }
+
+  private:
+    friend class NativeAccessibilityManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeActionSheetManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeActionSheetManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void showActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function callback) = 0;
+  virtual void showShareActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function failureCallback, jsi::Function successCallback) = 0;
+  virtual void dismissActionSheet(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeActionSheetManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ActionSheetManager";
+
+protected:
+  NativeActionSheetManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeActionSheetManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeActionSheetManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeActionSheetManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void showActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::showActionSheetWithOptions) == 3,
+          "Expected showActionSheetWithOptions(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::showActionSheetWithOptions, jsInvoker_, instance_, std::move(options), std::move(callback));
+    }
+    void showShareActionSheetWithOptions(jsi::Runtime &rt, jsi::Object options, jsi::Function failureCallback, jsi::Function successCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::showShareActionSheetWithOptions) == 4,
+          "Expected showShareActionSheetWithOptions(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::showShareActionSheetWithOptions, jsInvoker_, instance_, std::move(options), std::move(failureCallback), std::move(successCallback));
+    }
+    void dismissActionSheet(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::dismissActionSheet) == 1,
+          "Expected dismissActionSheet(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::dismissActionSheet, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeActionSheetManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeAlertManagerArgs
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
+struct NativeAlertManagerArgs {
+  P0 title;
+  P1 message;
+  P2 buttons;
+  P3 type;
+  P4 defaultValue;
+  P5 cancelButtonKey;
+  P6 destructiveButtonKey;
+  P7 preferredButtonKey;
+  P8 keyboardType;
+  P9 userInterfaceStyle;
+  bool operator==(const NativeAlertManagerArgs &other) const {
+    return title == other.title && message == other.message && buttons == other.buttons && type == other.type && defaultValue == other.defaultValue && cancelButtonKey == other.cancelButtonKey && destructiveButtonKey == other.destructiveButtonKey && preferredButtonKey == other.preferredButtonKey && keyboardType == other.keyboardType && userInterfaceStyle == other.userInterfaceStyle;
+  }
+};
+
+template <typename T>
+struct NativeAlertManagerArgsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
+      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
+      bridging::fromJs<decltype(types.buttons)>(rt, value.getProperty(rt, "buttons"), jsInvoker),
+      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
+      bridging::fromJs<decltype(types.defaultValue)>(rt, value.getProperty(rt, "defaultValue"), jsInvoker),
+      bridging::fromJs<decltype(types.cancelButtonKey)>(rt, value.getProperty(rt, "cancelButtonKey"), jsInvoker),
+      bridging::fromJs<decltype(types.destructiveButtonKey)>(rt, value.getProperty(rt, "destructiveButtonKey"), jsInvoker),
+      bridging::fromJs<decltype(types.preferredButtonKey)>(rt, value.getProperty(rt, "preferredButtonKey"), jsInvoker),
+      bridging::fromJs<decltype(types.keyboardType)>(rt, value.getProperty(rt, "keyboardType"), jsInvoker),
+      bridging::fromJs<decltype(types.userInterfaceStyle)>(rt, value.getProperty(rt, "userInterfaceStyle"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array buttonsToJs(jsi::Runtime &rt, decltype(types.buttons) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String defaultValueToJs(jsi::Runtime &rt, decltype(types.defaultValue) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String cancelButtonKeyToJs(jsi::Runtime &rt, decltype(types.cancelButtonKey) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String destructiveButtonKeyToJs(jsi::Runtime &rt, decltype(types.destructiveButtonKey) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String preferredButtonKeyToJs(jsi::Runtime &rt, decltype(types.preferredButtonKey) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String keyboardTypeToJs(jsi::Runtime &rt, decltype(types.keyboardType) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String userInterfaceStyleToJs(jsi::Runtime &rt, decltype(types.userInterfaceStyle) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    if (value.title) {
+      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
+    }
+    if (value.message) {
+      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
+    }
+    if (value.buttons) {
+      result.setProperty(rt, "buttons", bridging::toJs(rt, value.buttons.value(), jsInvoker));
+    }
+    if (value.type) {
+      result.setProperty(rt, "type", bridging::toJs(rt, value.type.value(), jsInvoker));
+    }
+    if (value.defaultValue) {
+      result.setProperty(rt, "defaultValue", bridging::toJs(rt, value.defaultValue.value(), jsInvoker));
+    }
+    if (value.cancelButtonKey) {
+      result.setProperty(rt, "cancelButtonKey", bridging::toJs(rt, value.cancelButtonKey.value(), jsInvoker));
+    }
+    if (value.destructiveButtonKey) {
+      result.setProperty(rt, "destructiveButtonKey", bridging::toJs(rt, value.destructiveButtonKey.value(), jsInvoker));
+    }
+    if (value.preferredButtonKey) {
+      result.setProperty(rt, "preferredButtonKey", bridging::toJs(rt, value.preferredButtonKey.value(), jsInvoker));
+    }
+    if (value.keyboardType) {
+      result.setProperty(rt, "keyboardType", bridging::toJs(rt, value.keyboardType.value(), jsInvoker));
+    }
+    if (value.userInterfaceStyle) {
+      result.setProperty(rt, "userInterfaceStyle", bridging::toJs(rt, value.userInterfaceStyle.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeAlertManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeAlertManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void alertWithArgs(jsi::Runtime &rt, jsi::Object args, jsi::Function callback) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeAlertManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "AlertManager";
+
+protected:
+  NativeAlertManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeAlertManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeAlertManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeAlertManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void alertWithArgs(jsi::Runtime &rt, jsi::Object args, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::alertWithArgs) == 3,
+          "Expected alertWithArgs(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::alertWithArgs, jsInvoker_, instance_, std::move(args), std::move(callback));
+    }
+
+  private:
+    friend class NativeAlertManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeAnimatedModuleEndResult
+
+template <typename P0, typename P1, typename P2>
+struct NativeAnimatedModuleEndResult {
+  P0 finished;
+  P1 value;
+  P2 offset;
+  bool operator==(const NativeAnimatedModuleEndResult &other) const {
+    return finished == other.finished && value == other.value && offset == other.offset;
+  }
+};
+
+template <typename T>
+struct NativeAnimatedModuleEndResultBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.finished)>(rt, value.getProperty(rt, "finished"), jsInvoker),
+      bridging::fromJs<decltype(types.value)>(rt, value.getProperty(rt, "value"), jsInvoker),
+      bridging::fromJs<decltype(types.offset)>(rt, value.getProperty(rt, "offset"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool finishedToJs(jsi::Runtime &rt, decltype(types.finished) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double valueToJs(jsi::Runtime &rt, decltype(types.value) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double offsetToJs(jsi::Runtime &rt, decltype(types.offset) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
+    if (value.value) {
+      result.setProperty(rt, "value", bridging::toJs(rt, value.value.value(), jsInvoker));
+    }
+    if (value.offset) {
+      result.setProperty(rt, "offset", bridging::toJs(rt, value.offset.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeAnimatedModuleEventMapping
+
+template <typename P0, typename P1>
+struct NativeAnimatedModuleEventMapping {
+  P0 nativeEventPath;
+  P1 animatedValueTag;
+  bool operator==(const NativeAnimatedModuleEventMapping &other) const {
+    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
+  }
+};
+
+template <typename T>
+struct NativeAnimatedModuleEventMappingBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.nativeEventPath)>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
+      bridging::fromJs<decltype(types.animatedValueTag)>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, decltype(types.nativeEventPath) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, decltype(types.animatedValueTag) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
+    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeAnimatedModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeAnimatedModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void startOperationBatch(jsi::Runtime &rt) = 0;
+  virtual void finishOperationBatch(jsi::Runtime &rt) = 0;
+  virtual void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
+  virtual void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
+  virtual void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) = 0;
+  virtual void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
+  virtual void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
+  virtual void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
+  virtual void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
+  virtual void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) = 0;
+  virtual void stopAnimation(jsi::Runtime &rt, double animationId) = 0;
+  virtual void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) = 0;
+  virtual void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) = 0;
+  virtual void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
+  virtual void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
+  virtual void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
+  virtual void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
+  virtual void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) = 0;
+  virtual void dropAnimatedNode(jsi::Runtime &rt, double tag) = 0;
+  virtual void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) = 0;
+  virtual void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+  virtual void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeAnimatedModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativeAnimatedModule";
+
+protected:
+  NativeAnimatedModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeAnimatedModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeAnimatedModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeAnimatedModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void startOperationBatch(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::startOperationBatch) == 1,
+          "Expected startOperationBatch(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::startOperationBatch, jsInvoker_, instance_);
+    }
+    void finishOperationBatch(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::finishOperationBatch) == 1,
+          "Expected finishOperationBatch(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::finishOperationBatch, jsInvoker_, instance_);
+    }
+    void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) override {
+      static_assert(
+          bridging::getParameterCount(&T::createAnimatedNode) == 3,
+          "Expected createAnimatedNode(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::createAnimatedNode, jsInvoker_, instance_, std::move(tag), std::move(config));
+    }
+    void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
+      static_assert(
+          bridging::getParameterCount(&T::updateAnimatedNodeConfig) == 3,
+          "Expected updateAnimatedNodeConfig(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::updateAnimatedNodeConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
+    }
+    void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getValue) == 3,
+          "Expected getValue(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getValue, jsInvoker_, instance_, std::move(tag), std::move(saveValueCallback));
+    }
+    void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
+      static_assert(
+          bridging::getParameterCount(&T::startListeningToAnimatedNodeValue) == 2,
+          "Expected startListeningToAnimatedNodeValue(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::startListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
+    }
+    void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
+      static_assert(
+          bridging::getParameterCount(&T::stopListeningToAnimatedNodeValue) == 2,
+          "Expected stopListeningToAnimatedNodeValue(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::stopListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
+    }
+    void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::connectAnimatedNodes) == 3,
+          "Expected connectAnimatedNodes(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::connectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
+    }
+    void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::disconnectAnimatedNodes) == 3,
+          "Expected disconnectAnimatedNodes(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::disconnectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
+    }
+    void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::startAnimatingNode) == 5,
+          "Expected startAnimatingNode(...) to have 5 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::startAnimatingNode, jsInvoker_, instance_, std::move(animationId), std::move(nodeTag), std::move(config), std::move(endCallback));
+    }
+    void stopAnimation(jsi::Runtime &rt, double animationId) override {
+      static_assert(
+          bridging::getParameterCount(&T::stopAnimation) == 2,
+          "Expected stopAnimation(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::stopAnimation, jsInvoker_, instance_, std::move(animationId));
+    }
+    void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) override {
+      static_assert(
+          bridging::getParameterCount(&T::setAnimatedNodeValue) == 3,
+          "Expected setAnimatedNodeValue(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setAnimatedNodeValue, jsInvoker_, instance_, std::move(nodeTag), std::move(value));
+    }
+    void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) override {
+      static_assert(
+          bridging::getParameterCount(&T::setAnimatedNodeOffset) == 3,
+          "Expected setAnimatedNodeOffset(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag), std::move(offset));
+    }
+    void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::flattenAnimatedNodeOffset) == 2,
+          "Expected flattenAnimatedNodeOffset(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::flattenAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
+    }
+    void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::extractAnimatedNodeOffset) == 2,
+          "Expected extractAnimatedNodeOffset(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::extractAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
+    }
+    void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::connectAnimatedNodeToView) == 3,
+          "Expected connectAnimatedNodeToView(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::connectAnimatedNodeToView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
+    }
+    void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::disconnectAnimatedNodeFromView) == 3,
+          "Expected disconnectAnimatedNodeFromView(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::disconnectAnimatedNodeFromView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
+    }
+    void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::restoreDefaultValues) == 2,
+          "Expected restoreDefaultValues(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::restoreDefaultValues, jsInvoker_, instance_, std::move(nodeTag));
+    }
+    void dropAnimatedNode(jsi::Runtime &rt, double tag) override {
+      static_assert(
+          bridging::getParameterCount(&T::dropAnimatedNode) == 2,
+          "Expected dropAnimatedNode(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::dropAnimatedNode, jsInvoker_, instance_, std::move(tag));
+    }
+    void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) override {
+      static_assert(
+          bridging::getParameterCount(&T::addAnimatedEventToView) == 4,
+          "Expected addAnimatedEventToView(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addAnimatedEventToView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(eventMapping));
+    }
+    void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeAnimatedEventFromView) == 4,
+          "Expected removeAnimatedEventFromView(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeAnimatedEventFromView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(animatedNodeTag));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+    void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) override {
+      static_assert(
+          bridging::getParameterCount(&T::queueAndExecuteBatchedOperations) == 2,
+          "Expected queueAndExecuteBatchedOperations(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::queueAndExecuteBatchedOperations, jsInvoker_, instance_, std::move(operationsAndArgs));
+    }
+
+  private:
+    friend class NativeAnimatedModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeAnimatedTurboModuleEndResult
+
+template <typename P0, typename P1, typename P2>
+struct NativeAnimatedTurboModuleEndResult {
+  P0 finished;
+  P1 value;
+  P2 offset;
+  bool operator==(const NativeAnimatedTurboModuleEndResult &other) const {
+    return finished == other.finished && value == other.value && offset == other.offset;
+  }
+};
+
+template <typename T>
+struct NativeAnimatedTurboModuleEndResultBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.finished)>(rt, value.getProperty(rt, "finished"), jsInvoker),
+      bridging::fromJs<decltype(types.value)>(rt, value.getProperty(rt, "value"), jsInvoker),
+      bridging::fromJs<decltype(types.offset)>(rt, value.getProperty(rt, "offset"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool finishedToJs(jsi::Runtime &rt, decltype(types.finished) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double valueToJs(jsi::Runtime &rt, decltype(types.value) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double offsetToJs(jsi::Runtime &rt, decltype(types.offset) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "finished", bridging::toJs(rt, value.finished, jsInvoker));
+    if (value.value) {
+      result.setProperty(rt, "value", bridging::toJs(rt, value.value.value(), jsInvoker));
+    }
+    if (value.offset) {
+      result.setProperty(rt, "offset", bridging::toJs(rt, value.offset.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeAnimatedTurboModuleEventMapping
+
+template <typename P0, typename P1>
+struct NativeAnimatedTurboModuleEventMapping {
+  P0 nativeEventPath;
+  P1 animatedValueTag;
+  bool operator==(const NativeAnimatedTurboModuleEventMapping &other) const {
+    return nativeEventPath == other.nativeEventPath && animatedValueTag == other.animatedValueTag;
+  }
+};
+
+template <typename T>
+struct NativeAnimatedTurboModuleEventMappingBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.nativeEventPath)>(rt, value.getProperty(rt, "nativeEventPath"), jsInvoker),
+      bridging::fromJs<decltype(types.animatedValueTag)>(rt, value.getProperty(rt, "animatedValueTag"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::Array nativeEventPathToJs(jsi::Runtime &rt, decltype(types.nativeEventPath) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<double> animatedValueTagToJs(jsi::Runtime &rt, decltype(types.animatedValueTag) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "nativeEventPath", bridging::toJs(rt, value.nativeEventPath, jsInvoker));
+    result.setProperty(rt, "animatedValueTag", bridging::toJs(rt, value.animatedValueTag, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeAnimatedTurboModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeAnimatedTurboModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void startOperationBatch(jsi::Runtime &rt) = 0;
+  virtual void finishOperationBatch(jsi::Runtime &rt) = 0;
+  virtual void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
+  virtual void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) = 0;
+  virtual void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) = 0;
+  virtual void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
+  virtual void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) = 0;
+  virtual void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
+  virtual void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) = 0;
+  virtual void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) = 0;
+  virtual void stopAnimation(jsi::Runtime &rt, double animationId) = 0;
+  virtual void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) = 0;
+  virtual void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) = 0;
+  virtual void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
+  virtual void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) = 0;
+  virtual void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
+  virtual void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) = 0;
+  virtual void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) = 0;
+  virtual void dropAnimatedNode(jsi::Runtime &rt, double tag) = 0;
+  virtual void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) = 0;
+  virtual void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+  virtual void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeAnimatedTurboModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativeAnimatedTurboModule";
+
+protected:
+  NativeAnimatedTurboModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeAnimatedTurboModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeAnimatedTurboModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeAnimatedTurboModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void startOperationBatch(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::startOperationBatch) == 1,
+          "Expected startOperationBatch(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::startOperationBatch, jsInvoker_, instance_);
+    }
+    void finishOperationBatch(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::finishOperationBatch) == 1,
+          "Expected finishOperationBatch(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::finishOperationBatch, jsInvoker_, instance_);
+    }
+    void createAnimatedNode(jsi::Runtime &rt, double tag, jsi::Object config) override {
+      static_assert(
+          bridging::getParameterCount(&T::createAnimatedNode) == 3,
+          "Expected createAnimatedNode(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::createAnimatedNode, jsInvoker_, instance_, std::move(tag), std::move(config));
+    }
+    void updateAnimatedNodeConfig(jsi::Runtime &rt, double tag, jsi::Object config) override {
+      static_assert(
+          bridging::getParameterCount(&T::updateAnimatedNodeConfig) == 3,
+          "Expected updateAnimatedNodeConfig(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::updateAnimatedNodeConfig, jsInvoker_, instance_, std::move(tag), std::move(config));
+    }
+    void getValue(jsi::Runtime &rt, double tag, jsi::Function saveValueCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getValue) == 3,
+          "Expected getValue(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getValue, jsInvoker_, instance_, std::move(tag), std::move(saveValueCallback));
+    }
+    void startListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
+      static_assert(
+          bridging::getParameterCount(&T::startListeningToAnimatedNodeValue) == 2,
+          "Expected startListeningToAnimatedNodeValue(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::startListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
+    }
+    void stopListeningToAnimatedNodeValue(jsi::Runtime &rt, double tag) override {
+      static_assert(
+          bridging::getParameterCount(&T::stopListeningToAnimatedNodeValue) == 2,
+          "Expected stopListeningToAnimatedNodeValue(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::stopListeningToAnimatedNodeValue, jsInvoker_, instance_, std::move(tag));
+    }
+    void connectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::connectAnimatedNodes) == 3,
+          "Expected connectAnimatedNodes(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::connectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
+    }
+    void disconnectAnimatedNodes(jsi::Runtime &rt, double parentTag, double childTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::disconnectAnimatedNodes) == 3,
+          "Expected disconnectAnimatedNodes(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::disconnectAnimatedNodes, jsInvoker_, instance_, std::move(parentTag), std::move(childTag));
+    }
+    void startAnimatingNode(jsi::Runtime &rt, double animationId, double nodeTag, jsi::Object config, jsi::Function endCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::startAnimatingNode) == 5,
+          "Expected startAnimatingNode(...) to have 5 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::startAnimatingNode, jsInvoker_, instance_, std::move(animationId), std::move(nodeTag), std::move(config), std::move(endCallback));
+    }
+    void stopAnimation(jsi::Runtime &rt, double animationId) override {
+      static_assert(
+          bridging::getParameterCount(&T::stopAnimation) == 2,
+          "Expected stopAnimation(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::stopAnimation, jsInvoker_, instance_, std::move(animationId));
+    }
+    void setAnimatedNodeValue(jsi::Runtime &rt, double nodeTag, double value) override {
+      static_assert(
+          bridging::getParameterCount(&T::setAnimatedNodeValue) == 3,
+          "Expected setAnimatedNodeValue(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setAnimatedNodeValue, jsInvoker_, instance_, std::move(nodeTag), std::move(value));
+    }
+    void setAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag, double offset) override {
+      static_assert(
+          bridging::getParameterCount(&T::setAnimatedNodeOffset) == 3,
+          "Expected setAnimatedNodeOffset(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag), std::move(offset));
+    }
+    void flattenAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::flattenAnimatedNodeOffset) == 2,
+          "Expected flattenAnimatedNodeOffset(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::flattenAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
+    }
+    void extractAnimatedNodeOffset(jsi::Runtime &rt, double nodeTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::extractAnimatedNodeOffset) == 2,
+          "Expected extractAnimatedNodeOffset(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::extractAnimatedNodeOffset, jsInvoker_, instance_, std::move(nodeTag));
+    }
+    void connectAnimatedNodeToView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::connectAnimatedNodeToView) == 3,
+          "Expected connectAnimatedNodeToView(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::connectAnimatedNodeToView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
+    }
+    void disconnectAnimatedNodeFromView(jsi::Runtime &rt, double nodeTag, double viewTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::disconnectAnimatedNodeFromView) == 3,
+          "Expected disconnectAnimatedNodeFromView(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::disconnectAnimatedNodeFromView, jsInvoker_, instance_, std::move(nodeTag), std::move(viewTag));
+    }
+    void restoreDefaultValues(jsi::Runtime &rt, double nodeTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::restoreDefaultValues) == 2,
+          "Expected restoreDefaultValues(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::restoreDefaultValues, jsInvoker_, instance_, std::move(nodeTag));
+    }
+    void dropAnimatedNode(jsi::Runtime &rt, double tag) override {
+      static_assert(
+          bridging::getParameterCount(&T::dropAnimatedNode) == 2,
+          "Expected dropAnimatedNode(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::dropAnimatedNode, jsInvoker_, instance_, std::move(tag));
+    }
+    void addAnimatedEventToView(jsi::Runtime &rt, double viewTag, jsi::String eventName, jsi::Object eventMapping) override {
+      static_assert(
+          bridging::getParameterCount(&T::addAnimatedEventToView) == 4,
+          "Expected addAnimatedEventToView(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addAnimatedEventToView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(eventMapping));
+    }
+    void removeAnimatedEventFromView(jsi::Runtime &rt, double viewTag, jsi::String eventName, double animatedNodeTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeAnimatedEventFromView) == 4,
+          "Expected removeAnimatedEventFromView(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeAnimatedEventFromView, jsInvoker_, instance_, std::move(viewTag), std::move(eventName), std::move(animatedNodeTag));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+    void queueAndExecuteBatchedOperations(jsi::Runtime &rt, jsi::Array operationsAndArgs) override {
+      static_assert(
+          bridging::getParameterCount(&T::queueAndExecuteBatchedOperations) == 2,
+          "Expected queueAndExecuteBatchedOperations(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::queueAndExecuteBatchedOperations, jsInvoker_, instance_, std::move(operationsAndArgs));
+    }
+
+  private:
+    friend class NativeAnimatedTurboModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeAppearanceCxxSpecJSI : public TurboModule {
+protected:
+  NativeAppearanceCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual std::optional<jsi::String> getColorScheme(jsi::Runtime &rt) = 0;
+  virtual void setColorScheme(jsi::Runtime &rt, jsi::String colorScheme) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeAppearanceCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "Appearance";
+
+protected:
+  NativeAppearanceCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeAppearanceCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeAppearanceCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeAppearanceCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    std::optional<jsi::String> getColorScheme(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getColorScheme) == 1,
+          "Expected getColorScheme(...) to have 1 parameters");
+
+      return bridging::callFromJs<std::optional<jsi::String>>(
+          rt, &T::getColorScheme, jsInvoker_, instance_);
+    }
+    void setColorScheme(jsi::Runtime &rt, jsi::String colorScheme) override {
+      static_assert(
+          bridging::getParameterCount(&T::setColorScheme) == 2,
+          "Expected setColorScheme(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setColorScheme, jsInvoker_, instance_, std::move(colorScheme));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativeAppearanceCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeAppStateAppState
+
+template <typename P0>
+struct NativeAppStateAppState {
+  P0 app_state;
+  bool operator==(const NativeAppStateAppState &other) const {
+    return app_state == other.app_state;
+  }
+};
+
+template <typename T>
+struct NativeAppStateAppStateBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.app_state)>(rt, value.getProperty(rt, "app_state"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String app_stateToJs(jsi::Runtime &rt, decltype(types.app_state) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "app_state", bridging::toJs(rt, value.app_state, jsInvoker));
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeAppStateAppStateConstants
+
+template <typename P0>
+struct NativeAppStateAppStateConstants {
+  P0 initialAppState;
+  bool operator==(const NativeAppStateAppStateConstants &other) const {
+    return initialAppState == other.initialAppState;
+  }
+};
+
+template <typename T>
+struct NativeAppStateAppStateConstantsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.initialAppState)>(rt, value.getProperty(rt, "initialAppState"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String initialAppStateToJs(jsi::Runtime &rt, decltype(types.initialAppState) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "initialAppState", bridging::toJs(rt, value.initialAppState, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeAppStateCxxSpecJSI : public TurboModule {
+protected:
+  NativeAppStateCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void getCurrentAppState(jsi::Runtime &rt, jsi::Function success, jsi::Function error) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeAppStateCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "AppState";
+
+protected:
+  NativeAppStateCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeAppStateCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeAppStateCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeAppStateCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void getCurrentAppState(jsi::Runtime &rt, jsi::Function success, jsi::Function error) override {
+      static_assert(
+          bridging::getParameterCount(&T::getCurrentAppState) == 3,
+          "Expected getCurrentAppState(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getCurrentAppState, jsInvoker_, instance_, std::move(success), std::move(error));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativeAppStateCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeBlobModuleConstants
+
+template <typename P0, typename P1>
+struct NativeBlobModuleConstants {
+  P0 BLOB_URI_SCHEME;
+  P1 BLOB_URI_HOST;
+  bool operator==(const NativeBlobModuleConstants &other) const {
+    return BLOB_URI_SCHEME == other.BLOB_URI_SCHEME && BLOB_URI_HOST == other.BLOB_URI_HOST;
+  }
+};
+
+template <typename T>
+struct NativeBlobModuleConstantsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.BLOB_URI_SCHEME)>(rt, value.getProperty(rt, "BLOB_URI_SCHEME"), jsInvoker),
+      bridging::fromJs<decltype(types.BLOB_URI_HOST)>(rt, value.getProperty(rt, "BLOB_URI_HOST"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static std::optional<jsi::String> BLOB_URI_SCHEMEToJs(jsi::Runtime &rt, decltype(types.BLOB_URI_SCHEME) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> BLOB_URI_HOSTToJs(jsi::Runtime &rt, decltype(types.BLOB_URI_HOST) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "BLOB_URI_SCHEME", bridging::toJs(rt, value.BLOB_URI_SCHEME, jsInvoker));
+    result.setProperty(rt, "BLOB_URI_HOST", bridging::toJs(rt, value.BLOB_URI_HOST, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeBlobModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeBlobModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void addNetworkingHandler(jsi::Runtime &rt) = 0;
+  virtual void addWebSocketHandler(jsi::Runtime &rt, double id) = 0;
+  virtual void removeWebSocketHandler(jsi::Runtime &rt, double id) = 0;
+  virtual void sendOverSocket(jsi::Runtime &rt, jsi::Object blob, double socketID) = 0;
+  virtual void createFromParts(jsi::Runtime &rt, jsi::Array parts, jsi::String withId) = 0;
+  virtual void release(jsi::Runtime &rt, jsi::String blobId) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeBlobModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "BlobModule";
+
+protected:
+  NativeBlobModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeBlobModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeBlobModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeBlobModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void addNetworkingHandler(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::addNetworkingHandler) == 1,
+          "Expected addNetworkingHandler(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addNetworkingHandler, jsInvoker_, instance_);
+    }
+    void addWebSocketHandler(jsi::Runtime &rt, double id) override {
+      static_assert(
+          bridging::getParameterCount(&T::addWebSocketHandler) == 2,
+          "Expected addWebSocketHandler(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addWebSocketHandler, jsInvoker_, instance_, std::move(id));
+    }
+    void removeWebSocketHandler(jsi::Runtime &rt, double id) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeWebSocketHandler) == 2,
+          "Expected removeWebSocketHandler(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeWebSocketHandler, jsInvoker_, instance_, std::move(id));
+    }
+    void sendOverSocket(jsi::Runtime &rt, jsi::Object blob, double socketID) override {
+      static_assert(
+          bridging::getParameterCount(&T::sendOverSocket) == 3,
+          "Expected sendOverSocket(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::sendOverSocket, jsInvoker_, instance_, std::move(blob), std::move(socketID));
+    }
+    void createFromParts(jsi::Runtime &rt, jsi::Array parts, jsi::String withId) override {
+      static_assert(
+          bridging::getParameterCount(&T::createFromParts) == 3,
+          "Expected createFromParts(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::createFromParts, jsInvoker_, instance_, std::move(parts), std::move(withId));
+    }
+    void release(jsi::Runtime &rt, jsi::String blobId) override {
+      static_assert(
+          bridging::getParameterCount(&T::release) == 2,
+          "Expected release(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::release, jsInvoker_, instance_, std::move(blobId));
+    }
+
+  private:
+    friend class NativeBlobModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeBugReportingCxxSpecJSI : public TurboModule {
+protected:
+  NativeBugReportingCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void startReportAProblemFlow(jsi::Runtime &rt) = 0;
+  virtual void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::Object extraFiles) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeBugReportingCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "BugReporting";
+
+protected:
+  NativeBugReportingCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeBugReportingCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeBugReportingCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeBugReportingCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void startReportAProblemFlow(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::startReportAProblemFlow) == 1,
+          "Expected startReportAProblemFlow(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::startReportAProblemFlow, jsInvoker_, instance_);
+    }
+    void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::Object extraFiles) override {
+      static_assert(
+          bridging::getParameterCount(&T::setExtraData) == 3,
+          "Expected setExtraData(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setExtraData, jsInvoker_, instance_, std::move(extraData), std::move(extraFiles));
+    }
+
+  private:
+    friend class NativeBugReportingCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeClipboardCxxSpecJSI : public TurboModule {
+protected:
+  NativeClipboardCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual jsi::Value getString(jsi::Runtime &rt) = 0;
+  virtual void setString(jsi::Runtime &rt, jsi::String content) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeClipboardCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "Clipboard";
+
+protected:
+  NativeClipboardCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeClipboardCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeClipboardCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeClipboardCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    jsi::Value getString(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getString) == 1,
+          "Expected getString(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getString, jsInvoker_, instance_);
+    }
+    void setString(jsi::Runtime &rt, jsi::String content) override {
+      static_assert(
+          bridging::getParameterCount(&T::setString) == 2,
+          "Expected setString(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setString, jsInvoker_, instance_, std::move(content));
+    }
+
+  private:
+    friend class NativeClipboardCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeDeviceEventManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeDeviceEventManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void invokeDefaultBackPressHandler(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeDeviceEventManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "DeviceEventManager";
+
+protected:
+  NativeDeviceEventManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeDeviceEventManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeDeviceEventManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeDeviceEventManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void invokeDefaultBackPressHandler(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::invokeDefaultBackPressHandler) == 1,
+          "Expected invokeDefaultBackPressHandler(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::invokeDefaultBackPressHandler, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeDeviceEventManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeDeviceInfoDeviceInfoConstants
+
+template <typename P0, typename P1>
+struct NativeDeviceInfoDeviceInfoConstants {
+  P0 Dimensions;
+  P1 isIPhoneX_deprecated;
+  bool operator==(const NativeDeviceInfoDeviceInfoConstants &other) const {
+    return Dimensions == other.Dimensions && isIPhoneX_deprecated == other.isIPhoneX_deprecated;
+  }
+};
+
+template <typename T>
+struct NativeDeviceInfoDeviceInfoConstantsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.Dimensions)>(rt, value.getProperty(rt, "Dimensions"), jsInvoker),
+      bridging::fromJs<decltype(types.isIPhoneX_deprecated)>(rt, value.getProperty(rt, "isIPhoneX_deprecated"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::Object DimensionsToJs(jsi::Runtime &rt, decltype(types.Dimensions) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool isIPhoneX_deprecatedToJs(jsi::Runtime &rt, decltype(types.isIPhoneX_deprecated) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "Dimensions", bridging::toJs(rt, value.Dimensions, jsInvoker));
+    if (value.isIPhoneX_deprecated) {
+      result.setProperty(rt, "isIPhoneX_deprecated", bridging::toJs(rt, value.isIPhoneX_deprecated.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeDeviceInfoDimensionsPayload
+
+template <typename P0, typename P1, typename P2, typename P3>
+struct NativeDeviceInfoDimensionsPayload {
+  P0 window;
+  P1 screen;
+  P2 windowPhysicalPixels;
+  P3 screenPhysicalPixels;
+  bool operator==(const NativeDeviceInfoDimensionsPayload &other) const {
+    return window == other.window && screen == other.screen && windowPhysicalPixels == other.windowPhysicalPixels && screenPhysicalPixels == other.screenPhysicalPixels;
+  }
+};
+
+template <typename T>
+struct NativeDeviceInfoDimensionsPayloadBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.window)>(rt, value.getProperty(rt, "window"), jsInvoker),
+      bridging::fromJs<decltype(types.screen)>(rt, value.getProperty(rt, "screen"), jsInvoker),
+      bridging::fromJs<decltype(types.windowPhysicalPixels)>(rt, value.getProperty(rt, "windowPhysicalPixels"), jsInvoker),
+      bridging::fromJs<decltype(types.screenPhysicalPixels)>(rt, value.getProperty(rt, "screenPhysicalPixels"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::Object windowToJs(jsi::Runtime &rt, decltype(types.window) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object screenToJs(jsi::Runtime &rt, decltype(types.screen) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object windowPhysicalPixelsToJs(jsi::Runtime &rt, decltype(types.windowPhysicalPixels) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object screenPhysicalPixelsToJs(jsi::Runtime &rt, decltype(types.screenPhysicalPixels) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    if (value.window) {
+      result.setProperty(rt, "window", bridging::toJs(rt, value.window.value(), jsInvoker));
+    }
+    if (value.screen) {
+      result.setProperty(rt, "screen", bridging::toJs(rt, value.screen.value(), jsInvoker));
+    }
+    if (value.windowPhysicalPixels) {
+      result.setProperty(rt, "windowPhysicalPixels", bridging::toJs(rt, value.windowPhysicalPixels.value(), jsInvoker));
+    }
+    if (value.screenPhysicalPixels) {
+      result.setProperty(rt, "screenPhysicalPixels", bridging::toJs(rt, value.screenPhysicalPixels.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeDeviceInfoDisplayMetrics
+
+template <typename P0, typename P1, typename P2, typename P3>
+struct NativeDeviceInfoDisplayMetrics {
+  P0 width;
+  P1 height;
+  P2 scale;
+  P3 fontScale;
+  bool operator==(const NativeDeviceInfoDisplayMetrics &other) const {
+    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale;
+  }
+};
+
+template <typename T>
+struct NativeDeviceInfoDisplayMetricsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
+      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
+      bridging::fromJs<decltype(types.scale)>(rt, value.getProperty(rt, "scale"), jsInvoker),
+      bridging::fromJs<decltype(types.fontScale)>(rt, value.getProperty(rt, "fontScale"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double scaleToJs(jsi::Runtime &rt, decltype(types.scale) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double fontScaleToJs(jsi::Runtime &rt, decltype(types.fontScale) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
+    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
+    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
+    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeDeviceInfoDisplayMetricsAndroid
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4>
+struct NativeDeviceInfoDisplayMetricsAndroid {
+  P0 width;
+  P1 height;
+  P2 scale;
+  P3 fontScale;
+  P4 densityDpi;
+  bool operator==(const NativeDeviceInfoDisplayMetricsAndroid &other) const {
+    return width == other.width && height == other.height && scale == other.scale && fontScale == other.fontScale && densityDpi == other.densityDpi;
+  }
+};
+
+template <typename T>
+struct NativeDeviceInfoDisplayMetricsAndroidBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
+      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
+      bridging::fromJs<decltype(types.scale)>(rt, value.getProperty(rt, "scale"), jsInvoker),
+      bridging::fromJs<decltype(types.fontScale)>(rt, value.getProperty(rt, "fontScale"), jsInvoker),
+      bridging::fromJs<decltype(types.densityDpi)>(rt, value.getProperty(rt, "densityDpi"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double scaleToJs(jsi::Runtime &rt, decltype(types.scale) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double fontScaleToJs(jsi::Runtime &rt, decltype(types.fontScale) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double densityDpiToJs(jsi::Runtime &rt, decltype(types.densityDpi) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
+    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
+    result.setProperty(rt, "scale", bridging::toJs(rt, value.scale, jsInvoker));
+    result.setProperty(rt, "fontScale", bridging::toJs(rt, value.fontScale, jsInvoker));
+    result.setProperty(rt, "densityDpi", bridging::toJs(rt, value.densityDpi, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeDeviceInfoCxxSpecJSI : public TurboModule {
+protected:
+  NativeDeviceInfoCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeDeviceInfoCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "DeviceInfo";
+
+protected:
+  NativeDeviceInfoCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeDeviceInfoCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeDeviceInfoCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeDeviceInfoCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeDeviceInfoCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeDevLoadingViewCxxSpecJSI : public TurboModule {
+protected:
+  NativeDevLoadingViewCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void showMessage(jsi::Runtime &rt, jsi::String message, std::optional<double> withColor, std::optional<double> withBackgroundColor) = 0;
+  virtual void hide(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeDevLoadingViewCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "DevLoadingView";
+
+protected:
+  NativeDevLoadingViewCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeDevLoadingViewCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeDevLoadingViewCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeDevLoadingViewCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void showMessage(jsi::Runtime &rt, jsi::String message, std::optional<double> withColor, std::optional<double> withBackgroundColor) override {
+      static_assert(
+          bridging::getParameterCount(&T::showMessage) == 4,
+          "Expected showMessage(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::showMessage, jsInvoker_, instance_, std::move(message), std::move(withColor), std::move(withBackgroundColor));
+    }
+    void hide(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::hide) == 1,
+          "Expected hide(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::hide, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeDevLoadingViewCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeDevSettingsCxxSpecJSI : public TurboModule {
+protected:
+  NativeDevSettingsCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void reload(jsi::Runtime &rt) = 0;
+  virtual void reloadWithReason(jsi::Runtime &rt, jsi::String reason) = 0;
+  virtual void onFastRefresh(jsi::Runtime &rt) = 0;
+  virtual void setHotLoadingEnabled(jsi::Runtime &rt, bool isHotLoadingEnabled) = 0;
+  virtual void setProfilingEnabled(jsi::Runtime &rt, bool isProfilingEnabled) = 0;
+  virtual void toggleElementInspector(jsi::Runtime &rt) = 0;
+  virtual void addMenuItem(jsi::Runtime &rt, jsi::String title) = 0;
+  virtual void openDebugger(jsi::Runtime &rt) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+  virtual void setIsShakeToShowDevMenuEnabled(jsi::Runtime &rt, bool enabled) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeDevSettingsCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "DevSettings";
+
+protected:
+  NativeDevSettingsCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeDevSettingsCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeDevSettingsCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeDevSettingsCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void reload(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::reload) == 1,
+          "Expected reload(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::reload, jsInvoker_, instance_);
+    }
+    void reloadWithReason(jsi::Runtime &rt, jsi::String reason) override {
+      static_assert(
+          bridging::getParameterCount(&T::reloadWithReason) == 2,
+          "Expected reloadWithReason(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::reloadWithReason, jsInvoker_, instance_, std::move(reason));
+    }
+    void onFastRefresh(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::onFastRefresh) == 1,
+          "Expected onFastRefresh(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::onFastRefresh, jsInvoker_, instance_);
+    }
+    void setHotLoadingEnabled(jsi::Runtime &rt, bool isHotLoadingEnabled) override {
+      static_assert(
+          bridging::getParameterCount(&T::setHotLoadingEnabled) == 2,
+          "Expected setHotLoadingEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setHotLoadingEnabled, jsInvoker_, instance_, std::move(isHotLoadingEnabled));
+    }
+    void setProfilingEnabled(jsi::Runtime &rt, bool isProfilingEnabled) override {
+      static_assert(
+          bridging::getParameterCount(&T::setProfilingEnabled) == 2,
+          "Expected setProfilingEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setProfilingEnabled, jsInvoker_, instance_, std::move(isProfilingEnabled));
+    }
+    void toggleElementInspector(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::toggleElementInspector) == 1,
+          "Expected toggleElementInspector(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::toggleElementInspector, jsInvoker_, instance_);
+    }
+    void addMenuItem(jsi::Runtime &rt, jsi::String title) override {
+      static_assert(
+          bridging::getParameterCount(&T::addMenuItem) == 2,
+          "Expected addMenuItem(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addMenuItem, jsInvoker_, instance_, std::move(title));
+    }
+    void openDebugger(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::openDebugger) == 1,
+          "Expected openDebugger(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::openDebugger, jsInvoker_, instance_);
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+    void setIsShakeToShowDevMenuEnabled(jsi::Runtime &rt, bool enabled) override {
+      static_assert(
+          bridging::getParameterCount(&T::setIsShakeToShowDevMenuEnabled) == 2,
+          "Expected setIsShakeToShowDevMenuEnabled(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setIsShakeToShowDevMenuEnabled, jsInvoker_, instance_, std::move(enabled));
+    }
+
+  private:
+    friend class NativeDevSettingsCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeDialogManagerAndroidDialogOptions
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+struct NativeDialogManagerAndroidDialogOptions {
+  P0 title;
+  P1 message;
+  P2 buttonPositive;
+  P3 buttonNegative;
+  P4 buttonNeutral;
+  P5 items;
+  P6 cancelable;
+  bool operator==(const NativeDialogManagerAndroidDialogOptions &other) const {
+    return title == other.title && message == other.message && buttonPositive == other.buttonPositive && buttonNegative == other.buttonNegative && buttonNeutral == other.buttonNeutral && items == other.items && cancelable == other.cancelable;
+  }
+};
+
+template <typename T>
+struct NativeDialogManagerAndroidDialogOptionsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
+      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
+      bridging::fromJs<decltype(types.buttonPositive)>(rt, value.getProperty(rt, "buttonPositive"), jsInvoker),
+      bridging::fromJs<decltype(types.buttonNegative)>(rt, value.getProperty(rt, "buttonNegative"), jsInvoker),
+      bridging::fromJs<decltype(types.buttonNeutral)>(rt, value.getProperty(rt, "buttonNeutral"), jsInvoker),
+      bridging::fromJs<decltype(types.items)>(rt, value.getProperty(rt, "items"), jsInvoker),
+      bridging::fromJs<decltype(types.cancelable)>(rt, value.getProperty(rt, "cancelable"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String buttonPositiveToJs(jsi::Runtime &rt, decltype(types.buttonPositive) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String buttonNegativeToJs(jsi::Runtime &rt, decltype(types.buttonNegative) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String buttonNeutralToJs(jsi::Runtime &rt, decltype(types.buttonNeutral) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array itemsToJs(jsi::Runtime &rt, decltype(types.items) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool cancelableToJs(jsi::Runtime &rt, decltype(types.cancelable) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    if (value.title) {
+      result.setProperty(rt, "title", bridging::toJs(rt, value.title.value(), jsInvoker));
+    }
+    if (value.message) {
+      result.setProperty(rt, "message", bridging::toJs(rt, value.message.value(), jsInvoker));
+    }
+    if (value.buttonPositive) {
+      result.setProperty(rt, "buttonPositive", bridging::toJs(rt, value.buttonPositive.value(), jsInvoker));
+    }
+    if (value.buttonNegative) {
+      result.setProperty(rt, "buttonNegative", bridging::toJs(rt, value.buttonNegative.value(), jsInvoker));
+    }
+    if (value.buttonNeutral) {
+      result.setProperty(rt, "buttonNeutral", bridging::toJs(rt, value.buttonNeutral.value(), jsInvoker));
+    }
+    if (value.items) {
+      result.setProperty(rt, "items", bridging::toJs(rt, value.items.value(), jsInvoker));
+    }
+    if (value.cancelable) {
+      result.setProperty(rt, "cancelable", bridging::toJs(rt, value.cancelable.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeDialogManagerAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativeDialogManagerAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeDialogManagerAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "DialogManagerAndroid";
+
+protected:
+  NativeDialogManagerAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeDialogManagerAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeDialogManagerAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeDialogManagerAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void showAlert(jsi::Runtime &rt, jsi::Object config, jsi::Function onError, jsi::Function onAction) override {
+      static_assert(
+          bridging::getParameterCount(&T::showAlert) == 4,
+          "Expected showAlert(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::showAlert, jsInvoker_, instance_, std::move(config), std::move(onError), std::move(onAction));
+    }
+
+  private:
+    friend class NativeDialogManagerAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeExceptionsManagerExceptionData
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+struct NativeExceptionsManagerExceptionData {
+  P0 message;
+  P1 originalMessage;
+  P2 name;
+  P3 componentStack;
+  P4 stack;
+  P5 id;
+  P6 isFatal;
+  P7 extraData;
+  bool operator==(const NativeExceptionsManagerExceptionData &other) const {
+    return message == other.message && originalMessage == other.originalMessage && name == other.name && componentStack == other.componentStack && stack == other.stack && id == other.id && isFatal == other.isFatal && extraData == other.extraData;
+  }
+};
+
+template <typename T>
+struct NativeExceptionsManagerExceptionDataBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.message)>(rt, value.getProperty(rt, "message"), jsInvoker),
+      bridging::fromJs<decltype(types.originalMessage)>(rt, value.getProperty(rt, "originalMessage"), jsInvoker),
+      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
+      bridging::fromJs<decltype(types.componentStack)>(rt, value.getProperty(rt, "componentStack"), jsInvoker),
+      bridging::fromJs<decltype(types.stack)>(rt, value.getProperty(rt, "stack"), jsInvoker),
+      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
+      bridging::fromJs<decltype(types.isFatal)>(rt, value.getProperty(rt, "isFatal"), jsInvoker),
+      bridging::fromJs<decltype(types.extraData)>(rt, value.getProperty(rt, "extraData"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String messageToJs(jsi::Runtime &rt, decltype(types.message) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> originalMessageToJs(jsi::Runtime &rt, decltype(types.originalMessage) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> componentStackToJs(jsi::Runtime &rt, decltype(types.componentStack) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array stackToJs(jsi::Runtime &rt, decltype(types.stack) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double idToJs(jsi::Runtime &rt, decltype(types.id) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool isFatalToJs(jsi::Runtime &rt, decltype(types.isFatal) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object extraDataToJs(jsi::Runtime &rt, decltype(types.extraData) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "message", bridging::toJs(rt, value.message, jsInvoker));
+    result.setProperty(rt, "originalMessage", bridging::toJs(rt, value.originalMessage, jsInvoker));
+    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
+    result.setProperty(rt, "componentStack", bridging::toJs(rt, value.componentStack, jsInvoker));
+    result.setProperty(rt, "stack", bridging::toJs(rt, value.stack, jsInvoker));
+    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
+    result.setProperty(rt, "isFatal", bridging::toJs(rt, value.isFatal, jsInvoker));
+    if (value.extraData) {
+      result.setProperty(rt, "extraData", bridging::toJs(rt, value.extraData.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeExceptionsManagerStackFrame
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4>
+struct NativeExceptionsManagerStackFrame {
+  P0 column;
+  P1 file;
+  P2 lineNumber;
+  P3 methodName;
+  P4 collapse;
+  bool operator==(const NativeExceptionsManagerStackFrame &other) const {
+    return column == other.column && file == other.file && lineNumber == other.lineNumber && methodName == other.methodName && collapse == other.collapse;
+  }
+};
+
+template <typename T>
+struct NativeExceptionsManagerStackFrameBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.column)>(rt, value.getProperty(rt, "column"), jsInvoker),
+      bridging::fromJs<decltype(types.file)>(rt, value.getProperty(rt, "file"), jsInvoker),
+      bridging::fromJs<decltype(types.lineNumber)>(rt, value.getProperty(rt, "lineNumber"), jsInvoker),
+      bridging::fromJs<decltype(types.methodName)>(rt, value.getProperty(rt, "methodName"), jsInvoker),
+      bridging::fromJs<decltype(types.collapse)>(rt, value.getProperty(rt, "collapse"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static std::optional<double> columnToJs(jsi::Runtime &rt, decltype(types.column) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> fileToJs(jsi::Runtime &rt, decltype(types.file) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<double> lineNumberToJs(jsi::Runtime &rt, decltype(types.lineNumber) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String methodNameToJs(jsi::Runtime &rt, decltype(types.methodName) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool collapseToJs(jsi::Runtime &rt, decltype(types.collapse) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "column", bridging::toJs(rt, value.column, jsInvoker));
+    result.setProperty(rt, "file", bridging::toJs(rt, value.file, jsInvoker));
+    result.setProperty(rt, "lineNumber", bridging::toJs(rt, value.lineNumber, jsInvoker));
+    result.setProperty(rt, "methodName", bridging::toJs(rt, value.methodName, jsInvoker));
+    if (value.collapse) {
+      result.setProperty(rt, "collapse", bridging::toJs(rt, value.collapse.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeExceptionsManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeExceptionsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void reportFatalException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) = 0;
+  virtual void reportSoftException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) = 0;
+  virtual void reportException(jsi::Runtime &rt, jsi::Object data) = 0;
+  virtual void dismissRedbox(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeExceptionsManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ExceptionsManager";
+
+protected:
+  NativeExceptionsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeExceptionsManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeExceptionsManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeExceptionsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void reportFatalException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) override {
+      static_assert(
+          bridging::getParameterCount(&T::reportFatalException) == 4,
+          "Expected reportFatalException(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::reportFatalException, jsInvoker_, instance_, std::move(message), std::move(stack), std::move(exceptionId));
+    }
+    void reportSoftException(jsi::Runtime &rt, jsi::String message, jsi::Array stack, double exceptionId) override {
+      static_assert(
+          bridging::getParameterCount(&T::reportSoftException) == 4,
+          "Expected reportSoftException(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::reportSoftException, jsInvoker_, instance_, std::move(message), std::move(stack), std::move(exceptionId));
+    }
+    void reportException(jsi::Runtime &rt, jsi::Object data) override {
+      static_assert(
+          bridging::getParameterCount(&T::reportException) == 2,
+          "Expected reportException(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::reportException, jsInvoker_, instance_, std::move(data));
+    }
+    void dismissRedbox(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::dismissRedbox) == 1,
+          "Expected dismissRedbox(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::dismissRedbox, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeExceptionsManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeFileReaderModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeFileReaderModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value readAsDataURL(jsi::Runtime &rt, jsi::Object data) = 0;
+  virtual jsi::Value readAsText(jsi::Runtime &rt, jsi::Object data, jsi::String encoding) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeFileReaderModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "FileReaderModule";
+
+protected:
+  NativeFileReaderModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeFileReaderModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeFileReaderModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeFileReaderModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value readAsDataURL(jsi::Runtime &rt, jsi::Object data) override {
+      static_assert(
+          bridging::getParameterCount(&T::readAsDataURL) == 2,
+          "Expected readAsDataURL(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::readAsDataURL, jsInvoker_, instance_, std::move(data));
+    }
+    jsi::Value readAsText(jsi::Runtime &rt, jsi::Object data, jsi::String encoding) override {
+      static_assert(
+          bridging::getParameterCount(&T::readAsText) == 3,
+          "Expected readAsText(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::readAsText, jsInvoker_, instance_, std::move(data), std::move(encoding));
+    }
+
+  private:
+    friend class NativeFileReaderModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeFrameRateLoggerCxxSpecJSI : public TurboModule {
+protected:
+  NativeFrameRateLoggerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void setGlobalOptions(jsi::Runtime &rt, jsi::Object options) = 0;
+  virtual void setContext(jsi::Runtime &rt, jsi::String context) = 0;
+  virtual void beginScroll(jsi::Runtime &rt) = 0;
+  virtual void endScroll(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeFrameRateLoggerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "FrameRateLogger";
+
+protected:
+  NativeFrameRateLoggerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeFrameRateLoggerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeFrameRateLoggerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeFrameRateLoggerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void setGlobalOptions(jsi::Runtime &rt, jsi::Object options) override {
+      static_assert(
+          bridging::getParameterCount(&T::setGlobalOptions) == 2,
+          "Expected setGlobalOptions(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setGlobalOptions, jsInvoker_, instance_, std::move(options));
+    }
+    void setContext(jsi::Runtime &rt, jsi::String context) override {
+      static_assert(
+          bridging::getParameterCount(&T::setContext) == 2,
+          "Expected setContext(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setContext, jsInvoker_, instance_, std::move(context));
+    }
+    void beginScroll(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::beginScroll) == 1,
+          "Expected beginScroll(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::beginScroll, jsInvoker_, instance_);
+    }
+    void endScroll(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::endScroll) == 1,
+          "Expected endScroll(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::endScroll, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeFrameRateLoggerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeHeadlessJsTaskSupportCxxSpecJSI : public TurboModule {
+protected:
+  NativeHeadlessJsTaskSupportCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void notifyTaskFinished(jsi::Runtime &rt, double taskId) = 0;
+  virtual jsi::Value notifyTaskRetry(jsi::Runtime &rt, double taskId) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeHeadlessJsTaskSupportCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "HeadlessJsTaskSupport";
+
+protected:
+  NativeHeadlessJsTaskSupportCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeHeadlessJsTaskSupportCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeHeadlessJsTaskSupportCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeHeadlessJsTaskSupportCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void notifyTaskFinished(jsi::Runtime &rt, double taskId) override {
+      static_assert(
+          bridging::getParameterCount(&T::notifyTaskFinished) == 2,
+          "Expected notifyTaskFinished(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::notifyTaskFinished, jsInvoker_, instance_, std::move(taskId));
+    }
+    jsi::Value notifyTaskRetry(jsi::Runtime &rt, double taskId) override {
+      static_assert(
+          bridging::getParameterCount(&T::notifyTaskRetry) == 2,
+          "Expected notifyTaskRetry(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::notifyTaskRetry, jsInvoker_, instance_, std::move(taskId));
+    }
+
+  private:
+    friend class NativeHeadlessJsTaskSupportCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeI18nManagerI18nManagerConstants
+
+template <typename P0, typename P1, typename P2>
+struct NativeI18nManagerI18nManagerConstants {
+  P0 doLeftAndRightSwapInRTL;
+  P1 isRTL;
+  P2 localeIdentifier;
+  bool operator==(const NativeI18nManagerI18nManagerConstants &other) const {
+    return doLeftAndRightSwapInRTL == other.doLeftAndRightSwapInRTL && isRTL == other.isRTL && localeIdentifier == other.localeIdentifier;
+  }
+};
+
+template <typename T>
+struct NativeI18nManagerI18nManagerConstantsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.doLeftAndRightSwapInRTL)>(rt, value.getProperty(rt, "doLeftAndRightSwapInRTL"), jsInvoker),
+      bridging::fromJs<decltype(types.isRTL)>(rt, value.getProperty(rt, "isRTL"), jsInvoker),
+      bridging::fromJs<decltype(types.localeIdentifier)>(rt, value.getProperty(rt, "localeIdentifier"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool doLeftAndRightSwapInRTLToJs(jsi::Runtime &rt, decltype(types.doLeftAndRightSwapInRTL) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool isRTLToJs(jsi::Runtime &rt, decltype(types.isRTL) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> localeIdentifierToJs(jsi::Runtime &rt, decltype(types.localeIdentifier) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "doLeftAndRightSwapInRTL", bridging::toJs(rt, value.doLeftAndRightSwapInRTL, jsInvoker));
+    result.setProperty(rt, "isRTL", bridging::toJs(rt, value.isRTL, jsInvoker));
+    if (value.localeIdentifier) {
+      result.setProperty(rt, "localeIdentifier", bridging::toJs(rt, value.localeIdentifier.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeI18nManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeI18nManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void allowRTL(jsi::Runtime &rt, bool allowRTL) = 0;
+  virtual void forceRTL(jsi::Runtime &rt, bool forceRTL) = 0;
+  virtual void swapLeftAndRightInRTL(jsi::Runtime &rt, bool flipStyles) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeI18nManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "I18nManager";
+
+protected:
+  NativeI18nManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeI18nManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeI18nManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeI18nManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void allowRTL(jsi::Runtime &rt, bool allowRTL) override {
+      static_assert(
+          bridging::getParameterCount(&T::allowRTL) == 2,
+          "Expected allowRTL(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::allowRTL, jsInvoker_, instance_, std::move(allowRTL));
+    }
+    void forceRTL(jsi::Runtime &rt, bool forceRTL) override {
+      static_assert(
+          bridging::getParameterCount(&T::forceRTL) == 2,
+          "Expected forceRTL(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::forceRTL, jsInvoker_, instance_, std::move(forceRTL));
+    }
+    void swapLeftAndRightInRTL(jsi::Runtime &rt, bool flipStyles) override {
+      static_assert(
+          bridging::getParameterCount(&T::swapLeftAndRightInRTL) == 2,
+          "Expected swapLeftAndRightInRTL(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::swapLeftAndRightInRTL, jsInvoker_, instance_, std::move(flipStyles));
+    }
+
+  private:
+    friend class NativeI18nManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeImageEditorOptions
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4>
+struct NativeImageEditorOptions {
+  P0 offset;
+  P1 size;
+  P2 displaySize;
+  P3 resizeMode;
+  P4 allowExternalStorage;
+  bool operator==(const NativeImageEditorOptions &other) const {
+    return offset == other.offset && size == other.size && displaySize == other.displaySize && resizeMode == other.resizeMode && allowExternalStorage == other.allowExternalStorage;
+  }
+};
+
+template <typename T>
+struct NativeImageEditorOptionsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.offset)>(rt, value.getProperty(rt, "offset"), jsInvoker),
+      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
+      bridging::fromJs<decltype(types.displaySize)>(rt, value.getProperty(rt, "displaySize"), jsInvoker),
+      bridging::fromJs<decltype(types.resizeMode)>(rt, value.getProperty(rt, "resizeMode"), jsInvoker),
+      bridging::fromJs<decltype(types.allowExternalStorage)>(rt, value.getProperty(rt, "allowExternalStorage"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::Object offsetToJs(jsi::Runtime &rt, decltype(types.offset) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::Object> displaySizeToJs(jsi::Runtime &rt, decltype(types.displaySize) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> resizeModeToJs(jsi::Runtime &rt, decltype(types.resizeMode) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool allowExternalStorageToJs(jsi::Runtime &rt, decltype(types.allowExternalStorage) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "offset", bridging::toJs(rt, value.offset, jsInvoker));
+    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
+    if (value.displaySize) {
+      result.setProperty(rt, "displaySize", bridging::toJs(rt, value.displaySize.value(), jsInvoker));
+    }
+    if (value.resizeMode) {
+      result.setProperty(rt, "resizeMode", bridging::toJs(rt, value.resizeMode.value(), jsInvoker));
+    }
+    if (value.allowExternalStorage) {
+      result.setProperty(rt, "allowExternalStorage", bridging::toJs(rt, value.allowExternalStorage.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeImageEditorCxxSpecJSI : public TurboModule {
+protected:
+  NativeImageEditorCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void cropImage(jsi::Runtime &rt, jsi::String uri, jsi::Object cropData, jsi::Function successCallback, jsi::Function errorCallback) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeImageEditorCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ImageEditingManager";
+
+protected:
+  NativeImageEditorCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeImageEditorCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeImageEditorCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeImageEditorCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void cropImage(jsi::Runtime &rt, jsi::String uri, jsi::Object cropData, jsi::Function successCallback, jsi::Function errorCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::cropImage) == 5,
+          "Expected cropImage(...) to have 5 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::cropImage, jsInvoker_, instance_, std::move(uri), std::move(cropData), std::move(successCallback), std::move(errorCallback));
+    }
+
+  private:
+    friend class NativeImageEditorCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeImageLoaderAndroidImageSize
+
+template <typename P0, typename P1>
+struct NativeImageLoaderAndroidImageSize {
+  P0 width;
+  P1 height;
+  bool operator==(const NativeImageLoaderAndroidImageSize &other) const {
+    return width == other.width && height == other.height;
+  }
+};
+
+template <typename T>
+struct NativeImageLoaderAndroidImageSizeBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
+      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
+    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeImageLoaderAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativeImageLoaderAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) = 0;
+  virtual jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) = 0;
+  virtual jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri, double requestId) = 0;
+  virtual jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeImageLoaderAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ImageLoader";
+
+protected:
+  NativeImageLoaderAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeImageLoaderAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeImageLoaderAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeImageLoaderAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void abortRequest(jsi::Runtime &rt, double requestId) override {
+      static_assert(
+          bridging::getParameterCount(&T::abortRequest) == 2,
+          "Expected abortRequest(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
+    }
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSize) == 2,
+          "Expected getSize(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getSize, jsInvoker_, instance_, std::move(uri));
+    }
+    jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSizeWithHeaders) == 3,
+          "Expected getSizeWithHeaders(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getSizeWithHeaders, jsInvoker_, instance_, std::move(uri), std::move(headers));
+    }
+    jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri, double requestId) override {
+      static_assert(
+          bridging::getParameterCount(&T::prefetchImage) == 3,
+          "Expected prefetchImage(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::prefetchImage, jsInvoker_, instance_, std::move(uri), std::move(requestId));
+    }
+    jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) override {
+      static_assert(
+          bridging::getParameterCount(&T::queryCache) == 2,
+          "Expected queryCache(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::queryCache, jsInvoker_, instance_, std::move(uris));
+    }
+
+  private:
+    friend class NativeImageLoaderAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeImageLoaderIOSCxxSpecJSI : public TurboModule {
+protected:
+  NativeImageLoaderIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) = 0;
+  virtual jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) = 0;
+  virtual jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri) = 0;
+  virtual jsi::Value prefetchImageWithMetadata(jsi::Runtime &rt, jsi::String uri, jsi::String queryRootName, double rootTag) = 0;
+  virtual jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeImageLoaderIOSCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ImageLoader";
+
+protected:
+  NativeImageLoaderIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeImageLoaderIOSCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeImageLoaderIOSCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeImageLoaderIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    jsi::Value getSize(jsi::Runtime &rt, jsi::String uri) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSize) == 2,
+          "Expected getSize(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getSize, jsInvoker_, instance_, std::move(uri));
+    }
+    jsi::Value getSizeWithHeaders(jsi::Runtime &rt, jsi::String uri, jsi::Object headers) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSizeWithHeaders) == 3,
+          "Expected getSizeWithHeaders(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getSizeWithHeaders, jsInvoker_, instance_, std::move(uri), std::move(headers));
+    }
+    jsi::Value prefetchImage(jsi::Runtime &rt, jsi::String uri) override {
+      static_assert(
+          bridging::getParameterCount(&T::prefetchImage) == 2,
+          "Expected prefetchImage(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::prefetchImage, jsInvoker_, instance_, std::move(uri));
+    }
+    jsi::Value prefetchImageWithMetadata(jsi::Runtime &rt, jsi::String uri, jsi::String queryRootName, double rootTag) override {
+      static_assert(
+          bridging::getParameterCount(&T::prefetchImageWithMetadata) == 4,
+          "Expected prefetchImageWithMetadata(...) to have 4 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::prefetchImageWithMetadata, jsInvoker_, instance_, std::move(uri), std::move(queryRootName), std::move(rootTag));
+    }
+    jsi::Value queryCache(jsi::Runtime &rt, jsi::Array uris) override {
+      static_assert(
+          bridging::getParameterCount(&T::queryCache) == 2,
+          "Expected queryCache(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::queryCache, jsInvoker_, instance_, std::move(uris));
+    }
+
+  private:
+    friend class NativeImageLoaderIOSCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeImageStoreAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativeImageStoreAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeImageStoreAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ImageStoreManager";
+
+protected:
+  NativeImageStoreAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeImageStoreAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeImageStoreAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeImageStoreAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getBase64ForTag) == 4,
+          "Expected getBase64ForTag(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getBase64ForTag, jsInvoker_, instance_, std::move(uri), std::move(successCallback), std::move(errorCallback));
+    }
+
+  private:
+    friend class NativeImageStoreAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeImageStoreIOSCxxSpecJSI : public TurboModule {
+protected:
+  NativeImageStoreIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) = 0;
+  virtual void hasImageForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function callback) = 0;
+  virtual void removeImageForTag(jsi::Runtime &rt, jsi::String uri) = 0;
+  virtual void addImageFromBase64(jsi::Runtime &rt, jsi::String base64ImageData, jsi::Function successCallback, jsi::Function errorCallback) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeImageStoreIOSCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ImageStoreManager";
+
+protected:
+  NativeImageStoreIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeImageStoreIOSCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeImageStoreIOSCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeImageStoreIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void getBase64ForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function successCallback, jsi::Function errorCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getBase64ForTag) == 4,
+          "Expected getBase64ForTag(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getBase64ForTag, jsInvoker_, instance_, std::move(uri), std::move(successCallback), std::move(errorCallback));
+    }
+    void hasImageForTag(jsi::Runtime &rt, jsi::String uri, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::hasImageForTag) == 3,
+          "Expected hasImageForTag(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::hasImageForTag, jsInvoker_, instance_, std::move(uri), std::move(callback));
+    }
+    void removeImageForTag(jsi::Runtime &rt, jsi::String uri) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeImageForTag) == 2,
+          "Expected removeImageForTag(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeImageForTag, jsInvoker_, instance_, std::move(uri));
+    }
+    void addImageFromBase64(jsi::Runtime &rt, jsi::String base64ImageData, jsi::Function successCallback, jsi::Function errorCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::addImageFromBase64) == 4,
+          "Expected addImageFromBase64(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addImageFromBase64, jsInvoker_, instance_, std::move(base64ImageData), std::move(successCallback), std::move(errorCallback));
+    }
+
+  private:
+    friend class NativeImageStoreIOSCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeIntentAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativeIntentAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value getInitialURL(jsi::Runtime &rt) = 0;
+  virtual jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) = 0;
+  virtual jsi::Value openURL(jsi::Runtime &rt, jsi::String url) = 0;
+  virtual jsi::Value openSettings(jsi::Runtime &rt) = 0;
+  virtual jsi::Value sendIntent(jsi::Runtime &rt, jsi::String action, std::optional<jsi::Array> extras) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeIntentAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "IntentAndroid";
+
+protected:
+  NativeIntentAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeIntentAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeIntentAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeIntentAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value getInitialURL(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getInitialURL) == 1,
+          "Expected getInitialURL(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getInitialURL, jsInvoker_, instance_);
+    }
+    jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) override {
+      static_assert(
+          bridging::getParameterCount(&T::canOpenURL) == 2,
+          "Expected canOpenURL(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::canOpenURL, jsInvoker_, instance_, std::move(url));
+    }
+    jsi::Value openURL(jsi::Runtime &rt, jsi::String url) override {
+      static_assert(
+          bridging::getParameterCount(&T::openURL) == 2,
+          "Expected openURL(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::openURL, jsInvoker_, instance_, std::move(url));
+    }
+    jsi::Value openSettings(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::openSettings) == 1,
+          "Expected openSettings(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::openSettings, jsInvoker_, instance_);
+    }
+    jsi::Value sendIntent(jsi::Runtime &rt, jsi::String action, std::optional<jsi::Array> extras) override {
+      static_assert(
+          bridging::getParameterCount(&T::sendIntent) == 3,
+          "Expected sendIntent(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::sendIntent, jsInvoker_, instance_, std::move(action), std::move(extras));
+    }
+
+  private:
+    friend class NativeIntentAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeJSCHeapCaptureCxxSpecJSI : public TurboModule {
+protected:
+  NativeJSCHeapCaptureCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void captureComplete(jsi::Runtime &rt, jsi::String path, std::optional<jsi::String> error) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeJSCHeapCaptureCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "JSCHeapCapture";
+
+protected:
+  NativeJSCHeapCaptureCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeJSCHeapCaptureCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeJSCHeapCaptureCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeJSCHeapCaptureCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void captureComplete(jsi::Runtime &rt, jsi::String path, std::optional<jsi::String> error) override {
+      static_assert(
+          bridging::getParameterCount(&T::captureComplete) == 3,
+          "Expected captureComplete(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::captureComplete, jsInvoker_, instance_, std::move(path), std::move(error));
+    }
+
+  private:
+    friend class NativeJSCHeapCaptureCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeKeyboardObserverCxxSpecJSI : public TurboModule {
+protected:
+  NativeKeyboardObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeKeyboardObserverCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "KeyboardObserver";
+
+protected:
+  NativeKeyboardObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeKeyboardObserverCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeKeyboardObserverCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeKeyboardObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativeKeyboardObserverCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeLinkingManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeLinkingManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value getInitialURL(jsi::Runtime &rt) = 0;
+  virtual jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) = 0;
+  virtual jsi::Value openURL(jsi::Runtime &rt, jsi::String url) = 0;
+  virtual jsi::Value openSettings(jsi::Runtime &rt) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeLinkingManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "LinkingManager";
+
+protected:
+  NativeLinkingManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeLinkingManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeLinkingManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeLinkingManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value getInitialURL(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getInitialURL) == 1,
+          "Expected getInitialURL(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getInitialURL, jsInvoker_, instance_);
+    }
+    jsi::Value canOpenURL(jsi::Runtime &rt, jsi::String url) override {
+      static_assert(
+          bridging::getParameterCount(&T::canOpenURL) == 2,
+          "Expected canOpenURL(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::canOpenURL, jsInvoker_, instance_, std::move(url));
+    }
+    jsi::Value openURL(jsi::Runtime &rt, jsi::String url) override {
+      static_assert(
+          bridging::getParameterCount(&T::openURL) == 2,
+          "Expected openURL(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::openURL, jsInvoker_, instance_, std::move(url));
+    }
+    jsi::Value openSettings(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::openSettings) == 1,
+          "Expected openSettings(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::openSettings, jsInvoker_, instance_);
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativeLinkingManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeLogBoxCxxSpecJSI : public TurboModule {
+protected:
+  NativeLogBoxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void show(jsi::Runtime &rt) = 0;
+  virtual void hide(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeLogBoxCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "LogBox";
+
+protected:
+  NativeLogBoxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeLogBoxCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeLogBoxCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeLogBoxCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void show(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::show) == 1,
+          "Expected show(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::show, jsInvoker_, instance_);
+    }
+    void hide(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::hide) == 1,
+          "Expected hide(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::hide, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeLogBoxCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeModalManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeModalManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeModalManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ModalManager";
+
+protected:
+  NativeModalManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeModalManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeModalManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeModalManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativeModalManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeNetworkingAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativeNetworkingAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void sendRequest(jsi::Runtime &rt, jsi::String method, jsi::String url, double requestId, jsi::Array headers, jsi::Object data, jsi::String responseType, bool useIncrementalUpdates, double timeout, bool withCredentials) = 0;
+  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
+  virtual void clearCookies(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeNetworkingAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "Networking";
+
+protected:
+  NativeNetworkingAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeNetworkingAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeNetworkingAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeNetworkingAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void sendRequest(jsi::Runtime &rt, jsi::String method, jsi::String url, double requestId, jsi::Array headers, jsi::Object data, jsi::String responseType, bool useIncrementalUpdates, double timeout, bool withCredentials) override {
+      static_assert(
+          bridging::getParameterCount(&T::sendRequest) == 10,
+          "Expected sendRequest(...) to have 10 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::sendRequest, jsInvoker_, instance_, std::move(method), std::move(url), std::move(requestId), std::move(headers), std::move(data), std::move(responseType), std::move(useIncrementalUpdates), std::move(timeout), std::move(withCredentials));
+    }
+    void abortRequest(jsi::Runtime &rt, double requestId) override {
+      static_assert(
+          bridging::getParameterCount(&T::abortRequest) == 2,
+          "Expected abortRequest(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
+    }
+    void clearCookies(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::clearCookies) == 2,
+          "Expected clearCookies(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::clearCookies, jsInvoker_, instance_, std::move(callback));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativeNetworkingAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeNetworkingIOSCxxSpecJSI : public TurboModule {
+protected:
+  NativeNetworkingIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void sendRequest(jsi::Runtime &rt, jsi::Object query, jsi::Function callback) = 0;
+  virtual void abortRequest(jsi::Runtime &rt, double requestId) = 0;
+  virtual void clearCookies(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeNetworkingIOSCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "Networking";
+
+protected:
+  NativeNetworkingIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeNetworkingIOSCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeNetworkingIOSCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeNetworkingIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void sendRequest(jsi::Runtime &rt, jsi::Object query, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::sendRequest) == 3,
+          "Expected sendRequest(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::sendRequest, jsInvoker_, instance_, std::move(query), std::move(callback));
+    }
+    void abortRequest(jsi::Runtime &rt, double requestId) override {
+      static_assert(
+          bridging::getParameterCount(&T::abortRequest) == 2,
+          "Expected abortRequest(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::abortRequest, jsInvoker_, instance_, std::move(requestId));
+    }
+    void clearCookies(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::clearCookies) == 2,
+          "Expected clearCookies(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::clearCookies, jsInvoker_, instance_, std::move(callback));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativeNetworkingIOSCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativePermissionsAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativePermissionsAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value checkPermission(jsi::Runtime &rt, jsi::String permission) = 0;
+  virtual jsi::Value requestPermission(jsi::Runtime &rt, jsi::String permission) = 0;
+  virtual jsi::Value shouldShowRequestPermissionRationale(jsi::Runtime &rt, jsi::String permission) = 0;
+  virtual jsi::Value requestMultiplePermissions(jsi::Runtime &rt, jsi::Array permissions) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativePermissionsAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "PermissionsAndroid";
+
+protected:
+  NativePermissionsAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativePermissionsAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativePermissionsAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativePermissionsAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value checkPermission(jsi::Runtime &rt, jsi::String permission) override {
+      static_assert(
+          bridging::getParameterCount(&T::checkPermission) == 2,
+          "Expected checkPermission(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::checkPermission, jsInvoker_, instance_, std::move(permission));
+    }
+    jsi::Value requestPermission(jsi::Runtime &rt, jsi::String permission) override {
+      static_assert(
+          bridging::getParameterCount(&T::requestPermission) == 2,
+          "Expected requestPermission(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::requestPermission, jsInvoker_, instance_, std::move(permission));
+    }
+    jsi::Value shouldShowRequestPermissionRationale(jsi::Runtime &rt, jsi::String permission) override {
+      static_assert(
+          bridging::getParameterCount(&T::shouldShowRequestPermissionRationale) == 2,
+          "Expected shouldShowRequestPermissionRationale(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::shouldShowRequestPermissionRationale, jsInvoker_, instance_, std::move(permission));
+    }
+    jsi::Value requestMultiplePermissions(jsi::Runtime &rt, jsi::Array permissions) override {
+      static_assert(
+          bridging::getParameterCount(&T::requestMultiplePermissions) == 2,
+          "Expected requestMultiplePermissions(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::requestMultiplePermissions, jsInvoker_, instance_, std::move(permissions));
+    }
+
+  private:
+    friend class NativePermissionsAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativePlatformConstantsAndroidPlatformConstantsAndroid
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11>
+struct NativePlatformConstantsAndroidPlatformConstantsAndroid {
+  P0 isTesting;
+  P1 isDisableAnimations;
+  P2 reactNativeVersion;
+  P3 Version;
+  P4 Release;
+  P5 Serial;
+  P6 Fingerprint;
+  P7 Model;
+  P8 ServerHost;
+  P9 uiMode;
+  P10 Brand;
+  P11 Manufacturer;
+  bool operator==(const NativePlatformConstantsAndroidPlatformConstantsAndroid &other) const {
+    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && Version == other.Version && Release == other.Release && Serial == other.Serial && Fingerprint == other.Fingerprint && Model == other.Model && ServerHost == other.ServerHost && uiMode == other.uiMode && Brand == other.Brand && Manufacturer == other.Manufacturer;
+  }
+};
+
+template <typename T>
+struct NativePlatformConstantsAndroidPlatformConstantsAndroidBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.isTesting)>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
+      bridging::fromJs<decltype(types.isDisableAnimations)>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
+      bridging::fromJs<decltype(types.reactNativeVersion)>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
+      bridging::fromJs<decltype(types.Version)>(rt, value.getProperty(rt, "Version"), jsInvoker),
+      bridging::fromJs<decltype(types.Release)>(rt, value.getProperty(rt, "Release"), jsInvoker),
+      bridging::fromJs<decltype(types.Serial)>(rt, value.getProperty(rt, "Serial"), jsInvoker),
+      bridging::fromJs<decltype(types.Fingerprint)>(rt, value.getProperty(rt, "Fingerprint"), jsInvoker),
+      bridging::fromJs<decltype(types.Model)>(rt, value.getProperty(rt, "Model"), jsInvoker),
+      bridging::fromJs<decltype(types.ServerHost)>(rt, value.getProperty(rt, "ServerHost"), jsInvoker),
+      bridging::fromJs<decltype(types.uiMode)>(rt, value.getProperty(rt, "uiMode"), jsInvoker),
+      bridging::fromJs<decltype(types.Brand)>(rt, value.getProperty(rt, "Brand"), jsInvoker),
+      bridging::fromJs<decltype(types.Manufacturer)>(rt, value.getProperty(rt, "Manufacturer"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool isTestingToJs(jsi::Runtime &rt, decltype(types.isTesting) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool isDisableAnimationsToJs(jsi::Runtime &rt, decltype(types.isDisableAnimations) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, decltype(types.reactNativeVersion) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double VersionToJs(jsi::Runtime &rt, decltype(types.Version) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String ReleaseToJs(jsi::Runtime &rt, decltype(types.Release) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String SerialToJs(jsi::Runtime &rt, decltype(types.Serial) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String FingerprintToJs(jsi::Runtime &rt, decltype(types.Fingerprint) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String ModelToJs(jsi::Runtime &rt, decltype(types.Model) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String ServerHostToJs(jsi::Runtime &rt, decltype(types.ServerHost) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String uiModeToJs(jsi::Runtime &rt, decltype(types.uiMode) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String BrandToJs(jsi::Runtime &rt, decltype(types.Brand) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String ManufacturerToJs(jsi::Runtime &rt, decltype(types.Manufacturer) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
+    if (value.isDisableAnimations) {
+      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
+    }
+    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
+    result.setProperty(rt, "Version", bridging::toJs(rt, value.Version, jsInvoker));
+    result.setProperty(rt, "Release", bridging::toJs(rt, value.Release, jsInvoker));
+    result.setProperty(rt, "Serial", bridging::toJs(rt, value.Serial, jsInvoker));
+    result.setProperty(rt, "Fingerprint", bridging::toJs(rt, value.Fingerprint, jsInvoker));
+    result.setProperty(rt, "Model", bridging::toJs(rt, value.Model, jsInvoker));
+    if (value.ServerHost) {
+      result.setProperty(rt, "ServerHost", bridging::toJs(rt, value.ServerHost.value(), jsInvoker));
+    }
+    result.setProperty(rt, "uiMode", bridging::toJs(rt, value.uiMode, jsInvoker));
+    result.setProperty(rt, "Brand", bridging::toJs(rt, value.Brand, jsInvoker));
+    result.setProperty(rt, "Manufacturer", bridging::toJs(rt, value.Manufacturer, jsInvoker));
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativePlatformConstantsAndroidReactNativeVersionAndroid
+
+template <typename P0, typename P1, typename P2, typename P3>
+struct NativePlatformConstantsAndroidReactNativeVersionAndroid {
+  P0 major;
+  P1 minor;
+  P2 patch;
+  P3 prerelease;
+  bool operator==(const NativePlatformConstantsAndroidReactNativeVersionAndroid &other) const {
+    return major == other.major && minor == other.minor && patch == other.patch && prerelease == other.prerelease;
+  }
+};
+
+template <typename T>
+struct NativePlatformConstantsAndroidReactNativeVersionAndroidBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.major)>(rt, value.getProperty(rt, "major"), jsInvoker),
+      bridging::fromJs<decltype(types.minor)>(rt, value.getProperty(rt, "minor"), jsInvoker),
+      bridging::fromJs<decltype(types.patch)>(rt, value.getProperty(rt, "patch"), jsInvoker),
+      bridging::fromJs<decltype(types.prerelease)>(rt, value.getProperty(rt, "prerelease"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double majorToJs(jsi::Runtime &rt, decltype(types.major) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double minorToJs(jsi::Runtime &rt, decltype(types.minor) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double patchToJs(jsi::Runtime &rt, decltype(types.patch) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> prereleaseToJs(jsi::Runtime &rt, decltype(types.prerelease) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "major", bridging::toJs(rt, value.major, jsInvoker));
+    result.setProperty(rt, "minor", bridging::toJs(rt, value.minor, jsInvoker));
+    result.setProperty(rt, "patch", bridging::toJs(rt, value.patch, jsInvoker));
+    result.setProperty(rt, "prerelease", bridging::toJs(rt, value.prerelease, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativePlatformConstantsAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativePlatformConstantsAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual jsi::String getAndroidID(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativePlatformConstantsAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "PlatformConstants";
+
+protected:
+  NativePlatformConstantsAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativePlatformConstantsAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativePlatformConstantsAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativePlatformConstantsAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    jsi::String getAndroidID(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getAndroidID) == 1,
+          "Expected getAndroidID(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::String>(
+          rt, &T::getAndroidID, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativePlatformConstantsAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativePlatformConstantsIOSPlatformConstantsIOS
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
+struct NativePlatformConstantsIOSPlatformConstantsIOS {
+  P0 isTesting;
+  P1 isDisableAnimations;
+  P2 reactNativeVersion;
+  P3 forceTouchAvailable;
+  P4 osVersion;
+  P5 systemName;
+  P6 interfaceIdiom;
+  P7 isMacCatalyst;
+  bool operator==(const NativePlatformConstantsIOSPlatformConstantsIOS &other) const {
+    return isTesting == other.isTesting && isDisableAnimations == other.isDisableAnimations && reactNativeVersion == other.reactNativeVersion && forceTouchAvailable == other.forceTouchAvailable && osVersion == other.osVersion && systemName == other.systemName && interfaceIdiom == other.interfaceIdiom && isMacCatalyst == other.isMacCatalyst;
+  }
+};
+
+template <typename T>
+struct NativePlatformConstantsIOSPlatformConstantsIOSBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.isTesting)>(rt, value.getProperty(rt, "isTesting"), jsInvoker),
+      bridging::fromJs<decltype(types.isDisableAnimations)>(rt, value.getProperty(rt, "isDisableAnimations"), jsInvoker),
+      bridging::fromJs<decltype(types.reactNativeVersion)>(rt, value.getProperty(rt, "reactNativeVersion"), jsInvoker),
+      bridging::fromJs<decltype(types.forceTouchAvailable)>(rt, value.getProperty(rt, "forceTouchAvailable"), jsInvoker),
+      bridging::fromJs<decltype(types.osVersion)>(rt, value.getProperty(rt, "osVersion"), jsInvoker),
+      bridging::fromJs<decltype(types.systemName)>(rt, value.getProperty(rt, "systemName"), jsInvoker),
+      bridging::fromJs<decltype(types.interfaceIdiom)>(rt, value.getProperty(rt, "interfaceIdiom"), jsInvoker),
+      bridging::fromJs<decltype(types.isMacCatalyst)>(rt, value.getProperty(rt, "isMacCatalyst"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool isTestingToJs(jsi::Runtime &rt, decltype(types.isTesting) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool isDisableAnimationsToJs(jsi::Runtime &rt, decltype(types.isDisableAnimations) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Object reactNativeVersionToJs(jsi::Runtime &rt, decltype(types.reactNativeVersion) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool forceTouchAvailableToJs(jsi::Runtime &rt, decltype(types.forceTouchAvailable) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String osVersionToJs(jsi::Runtime &rt, decltype(types.osVersion) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String systemNameToJs(jsi::Runtime &rt, decltype(types.systemName) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::String interfaceIdiomToJs(jsi::Runtime &rt, decltype(types.interfaceIdiom) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool isMacCatalystToJs(jsi::Runtime &rt, decltype(types.isMacCatalyst) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "isTesting", bridging::toJs(rt, value.isTesting, jsInvoker));
+    if (value.isDisableAnimations) {
+      result.setProperty(rt, "isDisableAnimations", bridging::toJs(rt, value.isDisableAnimations.value(), jsInvoker));
+    }
+    result.setProperty(rt, "reactNativeVersion", bridging::toJs(rt, value.reactNativeVersion, jsInvoker));
+    result.setProperty(rt, "forceTouchAvailable", bridging::toJs(rt, value.forceTouchAvailable, jsInvoker));
+    result.setProperty(rt, "osVersion", bridging::toJs(rt, value.osVersion, jsInvoker));
+    result.setProperty(rt, "systemName", bridging::toJs(rt, value.systemName, jsInvoker));
+    result.setProperty(rt, "interfaceIdiom", bridging::toJs(rt, value.interfaceIdiom, jsInvoker));
+    if (value.isMacCatalyst) {
+      result.setProperty(rt, "isMacCatalyst", bridging::toJs(rt, value.isMacCatalyst.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativePlatformConstantsIOSCxxSpecJSI : public TurboModule {
+protected:
+  NativePlatformConstantsIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativePlatformConstantsIOSCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "PlatformConstants";
+
+protected:
+  NativePlatformConstantsIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativePlatformConstantsIOSCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativePlatformConstantsIOSCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativePlatformConstantsIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativePlatformConstantsIOSCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativePushNotificationManagerIOSNotification
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
+struct NativePushNotificationManagerIOSNotification {
+  P0 alertTitle;
+  P1 alertBody;
+  P2 userInfo;
+  P3 category;
+  P4 fireDate;
+  P5 fireIntervalSeconds;
+  P6 applicationIconBadgeNumber;
+  P7 isSilent;
+  P8 soundName;
+  bool operator==(const NativePushNotificationManagerIOSNotification &other) const {
+    return alertTitle == other.alertTitle && alertBody == other.alertBody && userInfo == other.userInfo && category == other.category && fireDate == other.fireDate && fireIntervalSeconds == other.fireIntervalSeconds && applicationIconBadgeNumber == other.applicationIconBadgeNumber && isSilent == other.isSilent && soundName == other.soundName;
+  }
+};
+
+template <typename T>
+struct NativePushNotificationManagerIOSNotificationBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.alertTitle)>(rt, value.getProperty(rt, "alertTitle"), jsInvoker),
+      bridging::fromJs<decltype(types.alertBody)>(rt, value.getProperty(rt, "alertBody"), jsInvoker),
+      bridging::fromJs<decltype(types.userInfo)>(rt, value.getProperty(rt, "userInfo"), jsInvoker),
+      bridging::fromJs<decltype(types.category)>(rt, value.getProperty(rt, "category"), jsInvoker),
+      bridging::fromJs<decltype(types.fireDate)>(rt, value.getProperty(rt, "fireDate"), jsInvoker),
+      bridging::fromJs<decltype(types.fireIntervalSeconds)>(rt, value.getProperty(rt, "fireIntervalSeconds"), jsInvoker),
+      bridging::fromJs<decltype(types.applicationIconBadgeNumber)>(rt, value.getProperty(rt, "applicationIconBadgeNumber"), jsInvoker),
+      bridging::fromJs<decltype(types.isSilent)>(rt, value.getProperty(rt, "isSilent"), jsInvoker),
+      bridging::fromJs<decltype(types.soundName)>(rt, value.getProperty(rt, "soundName"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static std::optional<jsi::String> alertTitleToJs(jsi::Runtime &rt, decltype(types.alertTitle) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> alertBodyToJs(jsi::Runtime &rt, decltype(types.alertBody) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::Object> userInfoToJs(jsi::Runtime &rt, decltype(types.userInfo) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> categoryToJs(jsi::Runtime &rt, decltype(types.category) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<double> fireDateToJs(jsi::Runtime &rt, decltype(types.fireDate) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<double> fireIntervalSecondsToJs(jsi::Runtime &rt, decltype(types.fireIntervalSeconds) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<double> applicationIconBadgeNumberToJs(jsi::Runtime &rt, decltype(types.applicationIconBadgeNumber) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<bool> isSilentToJs(jsi::Runtime &rt, decltype(types.isSilent) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::String> soundNameToJs(jsi::Runtime &rt, decltype(types.soundName) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    if (value.alertTitle) {
+      result.setProperty(rt, "alertTitle", bridging::toJs(rt, value.alertTitle.value(), jsInvoker));
+    }
+    if (value.alertBody) {
+      result.setProperty(rt, "alertBody", bridging::toJs(rt, value.alertBody.value(), jsInvoker));
+    }
+    if (value.userInfo) {
+      result.setProperty(rt, "userInfo", bridging::toJs(rt, value.userInfo.value(), jsInvoker));
+    }
+    if (value.category) {
+      result.setProperty(rt, "category", bridging::toJs(rt, value.category.value(), jsInvoker));
+    }
+    if (value.fireDate) {
+      result.setProperty(rt, "fireDate", bridging::toJs(rt, value.fireDate.value(), jsInvoker));
+    }
+    if (value.fireIntervalSeconds) {
+      result.setProperty(rt, "fireIntervalSeconds", bridging::toJs(rt, value.fireIntervalSeconds.value(), jsInvoker));
+    }
+    if (value.applicationIconBadgeNumber) {
+      result.setProperty(rt, "applicationIconBadgeNumber", bridging::toJs(rt, value.applicationIconBadgeNumber.value(), jsInvoker));
+    }
+    if (value.isSilent) {
+      result.setProperty(rt, "isSilent", bridging::toJs(rt, value.isSilent.value(), jsInvoker));
+    }
+    if (value.soundName) {
+      result.setProperty(rt, "soundName", bridging::toJs(rt, value.soundName.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativePushNotificationManagerIOSPermissions
+
+template <typename P0, typename P1, typename P2>
+struct NativePushNotificationManagerIOSPermissions {
+  P0 alert;
+  P1 badge;
+  P2 sound;
+  bool operator==(const NativePushNotificationManagerIOSPermissions &other) const {
+    return alert == other.alert && badge == other.badge && sound == other.sound;
+  }
+};
+
+template <typename T>
+struct NativePushNotificationManagerIOSPermissionsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.alert)>(rt, value.getProperty(rt, "alert"), jsInvoker),
+      bridging::fromJs<decltype(types.badge)>(rt, value.getProperty(rt, "badge"), jsInvoker),
+      bridging::fromJs<decltype(types.sound)>(rt, value.getProperty(rt, "sound"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool alertToJs(jsi::Runtime &rt, decltype(types.alert) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool badgeToJs(jsi::Runtime &rt, decltype(types.badge) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool soundToJs(jsi::Runtime &rt, decltype(types.sound) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "alert", bridging::toJs(rt, value.alert, jsInvoker));
+    result.setProperty(rt, "badge", bridging::toJs(rt, value.badge, jsInvoker));
+    result.setProperty(rt, "sound", bridging::toJs(rt, value.sound, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativePushNotificationManagerIOSCxxSpecJSI : public TurboModule {
+protected:
+  NativePushNotificationManagerIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void onFinishRemoteNotification(jsi::Runtime &rt, jsi::String notificationId, jsi::String fetchResult) = 0;
+  virtual void setApplicationIconBadgeNumber(jsi::Runtime &rt, double num) = 0;
+  virtual void getApplicationIconBadgeNumber(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual jsi::Value requestPermissions(jsi::Runtime &rt, jsi::Object permission) = 0;
+  virtual void abandonPermissions(jsi::Runtime &rt) = 0;
+  virtual void checkPermissions(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual void presentLocalNotification(jsi::Runtime &rt, jsi::Object notification) = 0;
+  virtual void scheduleLocalNotification(jsi::Runtime &rt, jsi::Object notification) = 0;
+  virtual void cancelAllLocalNotifications(jsi::Runtime &rt) = 0;
+  virtual void cancelLocalNotifications(jsi::Runtime &rt, jsi::Object userInfo) = 0;
+  virtual jsi::Value getInitialNotification(jsi::Runtime &rt) = 0;
+  virtual void getScheduledLocalNotifications(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual void removeAllDeliveredNotifications(jsi::Runtime &rt) = 0;
+  virtual void removeDeliveredNotifications(jsi::Runtime &rt, jsi::Array identifiers) = 0;
+  virtual void getDeliveredNotifications(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual void getAuthorizationStatus(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventType) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativePushNotificationManagerIOSCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "PushNotificationManager";
+
+protected:
+  NativePushNotificationManagerIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativePushNotificationManagerIOSCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativePushNotificationManagerIOSCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativePushNotificationManagerIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void onFinishRemoteNotification(jsi::Runtime &rt, jsi::String notificationId, jsi::String fetchResult) override {
+      static_assert(
+          bridging::getParameterCount(&T::onFinishRemoteNotification) == 3,
+          "Expected onFinishRemoteNotification(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::onFinishRemoteNotification, jsInvoker_, instance_, std::move(notificationId), std::move(fetchResult));
+    }
+    void setApplicationIconBadgeNumber(jsi::Runtime &rt, double num) override {
+      static_assert(
+          bridging::getParameterCount(&T::setApplicationIconBadgeNumber) == 2,
+          "Expected setApplicationIconBadgeNumber(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setApplicationIconBadgeNumber, jsInvoker_, instance_, std::move(num));
+    }
+    void getApplicationIconBadgeNumber(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getApplicationIconBadgeNumber) == 2,
+          "Expected getApplicationIconBadgeNumber(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getApplicationIconBadgeNumber, jsInvoker_, instance_, std::move(callback));
+    }
+    jsi::Value requestPermissions(jsi::Runtime &rt, jsi::Object permission) override {
+      static_assert(
+          bridging::getParameterCount(&T::requestPermissions) == 2,
+          "Expected requestPermissions(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::requestPermissions, jsInvoker_, instance_, std::move(permission));
+    }
+    void abandonPermissions(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::abandonPermissions) == 1,
+          "Expected abandonPermissions(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::abandonPermissions, jsInvoker_, instance_);
+    }
+    void checkPermissions(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::checkPermissions) == 2,
+          "Expected checkPermissions(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::checkPermissions, jsInvoker_, instance_, std::move(callback));
+    }
+    void presentLocalNotification(jsi::Runtime &rt, jsi::Object notification) override {
+      static_assert(
+          bridging::getParameterCount(&T::presentLocalNotification) == 2,
+          "Expected presentLocalNotification(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::presentLocalNotification, jsInvoker_, instance_, std::move(notification));
+    }
+    void scheduleLocalNotification(jsi::Runtime &rt, jsi::Object notification) override {
+      static_assert(
+          bridging::getParameterCount(&T::scheduleLocalNotification) == 2,
+          "Expected scheduleLocalNotification(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::scheduleLocalNotification, jsInvoker_, instance_, std::move(notification));
+    }
+    void cancelAllLocalNotifications(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::cancelAllLocalNotifications) == 1,
+          "Expected cancelAllLocalNotifications(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::cancelAllLocalNotifications, jsInvoker_, instance_);
+    }
+    void cancelLocalNotifications(jsi::Runtime &rt, jsi::Object userInfo) override {
+      static_assert(
+          bridging::getParameterCount(&T::cancelLocalNotifications) == 2,
+          "Expected cancelLocalNotifications(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::cancelLocalNotifications, jsInvoker_, instance_, std::move(userInfo));
+    }
+    jsi::Value getInitialNotification(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getInitialNotification) == 1,
+          "Expected getInitialNotification(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getInitialNotification, jsInvoker_, instance_);
+    }
+    void getScheduledLocalNotifications(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getScheduledLocalNotifications) == 2,
+          "Expected getScheduledLocalNotifications(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getScheduledLocalNotifications, jsInvoker_, instance_, std::move(callback));
+    }
+    void removeAllDeliveredNotifications(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeAllDeliveredNotifications) == 1,
+          "Expected removeAllDeliveredNotifications(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeAllDeliveredNotifications, jsInvoker_, instance_);
+    }
+    void removeDeliveredNotifications(jsi::Runtime &rt, jsi::Array identifiers) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeDeliveredNotifications) == 2,
+          "Expected removeDeliveredNotifications(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeDeliveredNotifications, jsInvoker_, instance_, std::move(identifiers));
+    }
+    void getDeliveredNotifications(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getDeliveredNotifications) == 2,
+          "Expected getDeliveredNotifications(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getDeliveredNotifications, jsInvoker_, instance_, std::move(callback));
+    }
+    void getAuthorizationStatus(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getAuthorizationStatus) == 2,
+          "Expected getAuthorizationStatus(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getAuthorizationStatus, jsInvoker_, instance_, std::move(callback));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventType) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventType));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativePushNotificationManagerIOSCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeRedBoxCxxSpecJSI : public TurboModule {
+protected:
+  NativeRedBoxCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::String forIdentifier) = 0;
+  virtual void dismiss(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeRedBoxCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "RedBox";
+
+protected:
+  NativeRedBoxCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeRedBoxCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeRedBoxCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeRedBoxCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void setExtraData(jsi::Runtime &rt, jsi::Object extraData, jsi::String forIdentifier) override {
+      static_assert(
+          bridging::getParameterCount(&T::setExtraData) == 3,
+          "Expected setExtraData(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setExtraData, jsInvoker_, instance_, std::move(extraData), std::move(forIdentifier));
+    }
+    void dismiss(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::dismiss) == 1,
+          "Expected dismiss(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::dismiss, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeRedBoxCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeSegmentFetcherCxxSpecJSI : public TurboModule {
+protected:
+  NativeSegmentFetcherCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void fetchSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) = 0;
+  virtual void getSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeSegmentFetcherCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "SegmentFetcher";
+
+protected:
+  NativeSegmentFetcherCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeSegmentFetcherCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeSegmentFetcherCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeSegmentFetcherCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void fetchSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::fetchSegment) == 4,
+          "Expected fetchSegment(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::fetchSegment, jsInvoker_, instance_, std::move(segmentId), std::move(options), std::move(callback));
+    }
+    void getSegment(jsi::Runtime &rt, double segmentId, jsi::Object options, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSegment) == 4,
+          "Expected getSegment(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getSegment, jsInvoker_, instance_, std::move(segmentId), std::move(options), std::move(callback));
+    }
+
+  private:
+    friend class NativeSegmentFetcherCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeSettingsManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeSettingsManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void setValues(jsi::Runtime &rt, jsi::Object values) = 0;
+  virtual void deleteValues(jsi::Runtime &rt, jsi::Array values) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeSettingsManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "SettingsManager";
+
+protected:
+  NativeSettingsManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeSettingsManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeSettingsManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeSettingsManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void setValues(jsi::Runtime &rt, jsi::Object values) override {
+      static_assert(
+          bridging::getParameterCount(&T::setValues) == 2,
+          "Expected setValues(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setValues, jsInvoker_, instance_, std::move(values));
+    }
+    void deleteValues(jsi::Runtime &rt, jsi::Array values) override {
+      static_assert(
+          bridging::getParameterCount(&T::deleteValues) == 2,
+          "Expected deleteValues(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::deleteValues, jsInvoker_, instance_, std::move(values));
+    }
+
+  private:
+    friend class NativeSettingsManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeShareModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeShareModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual jsi::Value share(jsi::Runtime &rt, jsi::Object content, std::optional<jsi::String> dialogTitle) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeShareModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ShareModule";
+
+protected:
+  NativeShareModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeShareModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeShareModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeShareModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    jsi::Value share(jsi::Runtime &rt, jsi::Object content, std::optional<jsi::String> dialogTitle) override {
+      static_assert(
+          bridging::getParameterCount(&T::share) == 3,
+          "Expected share(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::share, jsInvoker_, instance_, std::move(content), std::move(dialogTitle));
+    }
+
+  private:
+    friend class NativeShareModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeSoundManagerCxxSpecJSI : public TurboModule {
+protected:
+  NativeSoundManagerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void playTouchSound(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeSoundManagerCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "SoundManager";
+
+protected:
+  NativeSoundManagerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeSoundManagerCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeSoundManagerCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeSoundManagerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void playTouchSound(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::playTouchSound) == 1,
+          "Expected playTouchSound(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::playTouchSound, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeSoundManagerCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeSourceCodeSourceCodeConstants
+
+template <typename P0>
+struct NativeSourceCodeSourceCodeConstants {
+  P0 scriptURL;
+  bool operator==(const NativeSourceCodeSourceCodeConstants &other) const {
+    return scriptURL == other.scriptURL;
+  }
+};
+
+template <typename T>
+struct NativeSourceCodeSourceCodeConstantsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.scriptURL)>(rt, value.getProperty(rt, "scriptURL"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String scriptURLToJs(jsi::Runtime &rt, decltype(types.scriptURL) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "scriptURL", bridging::toJs(rt, value.scriptURL, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeSourceCodeCxxSpecJSI : public TurboModule {
+protected:
+  NativeSourceCodeCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeSourceCodeCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "SourceCode";
+
+protected:
+  NativeSourceCodeCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeSourceCodeCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeSourceCodeCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeSourceCodeCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeSourceCodeCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeStatusBarManagerAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativeStatusBarManagerAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void setColor(jsi::Runtime &rt, double color, bool animated) = 0;
+  virtual void setTranslucent(jsi::Runtime &rt, bool translucent) = 0;
+  virtual void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle) = 0;
+  virtual void setHidden(jsi::Runtime &rt, bool hidden) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeStatusBarManagerAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "StatusBarManager";
+
+protected:
+  NativeStatusBarManagerAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeStatusBarManagerAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeStatusBarManagerAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeStatusBarManagerAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void setColor(jsi::Runtime &rt, double color, bool animated) override {
+      static_assert(
+          bridging::getParameterCount(&T::setColor) == 3,
+          "Expected setColor(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setColor, jsInvoker_, instance_, std::move(color), std::move(animated));
+    }
+    void setTranslucent(jsi::Runtime &rt, bool translucent) override {
+      static_assert(
+          bridging::getParameterCount(&T::setTranslucent) == 2,
+          "Expected setTranslucent(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setTranslucent, jsInvoker_, instance_, std::move(translucent));
+    }
+    void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle) override {
+      static_assert(
+          bridging::getParameterCount(&T::setStyle) == 2,
+          "Expected setStyle(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setStyle, jsInvoker_, instance_, std::move(statusBarStyle));
+    }
+    void setHidden(jsi::Runtime &rt, bool hidden) override {
+      static_assert(
+          bridging::getParameterCount(&T::setHidden) == 2,
+          "Expected setHidden(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setHidden, jsInvoker_, instance_, std::move(hidden));
+    }
+
+  private:
+    friend class NativeStatusBarManagerAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeStatusBarManagerIOSCxxSpecJSI : public TurboModule {
+protected:
+  NativeStatusBarManagerIOSCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void getHeight(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual void setNetworkActivityIndicatorVisible(jsi::Runtime &rt, bool visible) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventType) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+  virtual void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle, bool animated) = 0;
+  virtual void setHidden(jsi::Runtime &rt, bool hidden, jsi::String withAnimation) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeStatusBarManagerIOSCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "StatusBarManager";
+
+protected:
+  NativeStatusBarManagerIOSCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeStatusBarManagerIOSCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeStatusBarManagerIOSCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeStatusBarManagerIOSCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void getHeight(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::getHeight) == 2,
+          "Expected getHeight(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::getHeight, jsInvoker_, instance_, std::move(callback));
+    }
+    void setNetworkActivityIndicatorVisible(jsi::Runtime &rt, bool visible) override {
+      static_assert(
+          bridging::getParameterCount(&T::setNetworkActivityIndicatorVisible) == 2,
+          "Expected setNetworkActivityIndicatorVisible(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setNetworkActivityIndicatorVisible, jsInvoker_, instance_, std::move(visible));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventType) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventType));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+    void setStyle(jsi::Runtime &rt, std::optional<jsi::String> statusBarStyle, bool animated) override {
+      static_assert(
+          bridging::getParameterCount(&T::setStyle) == 3,
+          "Expected setStyle(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setStyle, jsInvoker_, instance_, std::move(statusBarStyle), std::move(animated));
+    }
+    void setHidden(jsi::Runtime &rt, bool hidden, jsi::String withAnimation) override {
+      static_assert(
+          bridging::getParameterCount(&T::setHidden) == 3,
+          "Expected setHidden(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setHidden, jsInvoker_, instance_, std::move(hidden), std::move(withAnimation));
+    }
+
+  private:
+    friend class NativeStatusBarManagerIOSCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeTimingCxxSpecJSI : public TurboModule {
+protected:
+  NativeTimingCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void createTimer(jsi::Runtime &rt, double callbackID, double duration, double jsSchedulingTime, bool repeats) = 0;
+  virtual void deleteTimer(jsi::Runtime &rt, double timerID) = 0;
+  virtual void setSendIdleEvents(jsi::Runtime &rt, bool sendIdleEvents) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeTimingCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "Timing";
+
+protected:
+  NativeTimingCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeTimingCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeTimingCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeTimingCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void createTimer(jsi::Runtime &rt, double callbackID, double duration, double jsSchedulingTime, bool repeats) override {
+      static_assert(
+          bridging::getParameterCount(&T::createTimer) == 5,
+          "Expected createTimer(...) to have 5 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::createTimer, jsInvoker_, instance_, std::move(callbackID), std::move(duration), std::move(jsSchedulingTime), std::move(repeats));
+    }
+    void deleteTimer(jsi::Runtime &rt, double timerID) override {
+      static_assert(
+          bridging::getParameterCount(&T::deleteTimer) == 2,
+          "Expected deleteTimer(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::deleteTimer, jsInvoker_, instance_, std::move(timerID));
+    }
+    void setSendIdleEvents(jsi::Runtime &rt, bool sendIdleEvents) override {
+      static_assert(
+          bridging::getParameterCount(&T::setSendIdleEvents) == 2,
+          "Expected setSendIdleEvents(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setSendIdleEvents, jsInvoker_, instance_, std::move(sendIdleEvents));
+    }
+
+  private:
+    friend class NativeTimingCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeToastAndroidCxxSpecJSI : public TurboModule {
+protected:
+  NativeToastAndroidCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void show(jsi::Runtime &rt, jsi::String message, double duration) = 0;
+  virtual void showWithGravity(jsi::Runtime &rt, jsi::String message, double duration, double gravity) = 0;
+  virtual void showWithGravityAndOffset(jsi::Runtime &rt, jsi::String message, double duration, double gravity, double xOffset, double yOffset) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeToastAndroidCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "ToastAndroid";
+
+protected:
+  NativeToastAndroidCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeToastAndroidCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeToastAndroidCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeToastAndroidCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void show(jsi::Runtime &rt, jsi::String message, double duration) override {
+      static_assert(
+          bridging::getParameterCount(&T::show) == 3,
+          "Expected show(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::show, jsInvoker_, instance_, std::move(message), std::move(duration));
+    }
+    void showWithGravity(jsi::Runtime &rt, jsi::String message, double duration, double gravity) override {
+      static_assert(
+          bridging::getParameterCount(&T::showWithGravity) == 4,
+          "Expected showWithGravity(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::showWithGravity, jsInvoker_, instance_, std::move(message), std::move(duration), std::move(gravity));
+    }
+    void showWithGravityAndOffset(jsi::Runtime &rt, jsi::String message, double duration, double gravity, double xOffset, double yOffset) override {
+      static_assert(
+          bridging::getParameterCount(&T::showWithGravityAndOffset) == 6,
+          "Expected showWithGravityAndOffset(...) to have 6 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::showWithGravityAndOffset, jsInvoker_, instance_, std::move(message), std::move(duration), std::move(gravity), std::move(xOffset), std::move(yOffset));
+    }
+
+  private:
+    friend class NativeToastAndroidCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeVibrationCxxSpecJSI : public TurboModule {
+protected:
+  NativeVibrationCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Object getConstants(jsi::Runtime &rt) = 0;
+  virtual void vibrate(jsi::Runtime &rt, double pattern) = 0;
+  virtual void vibrateByPattern(jsi::Runtime &rt, jsi::Array pattern, double repeat) = 0;
+  virtual void cancel(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeVibrationCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "Vibration";
+
+protected:
+  NativeVibrationCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeVibrationCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeVibrationCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeVibrationCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Object getConstants(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getConstants) == 1,
+          "Expected getConstants(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getConstants, jsInvoker_, instance_);
+    }
+    void vibrate(jsi::Runtime &rt, double pattern) override {
+      static_assert(
+          bridging::getParameterCount(&T::vibrate) == 2,
+          "Expected vibrate(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::vibrate, jsInvoker_, instance_, std::move(pattern));
+    }
+    void vibrateByPattern(jsi::Runtime &rt, jsi::Array pattern, double repeat) override {
+      static_assert(
+          bridging::getParameterCount(&T::vibrateByPattern) == 3,
+          "Expected vibrateByPattern(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::vibrateByPattern, jsInvoker_, instance_, std::move(pattern), std::move(repeat));
+    }
+    void cancel(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::cancel) == 1,
+          "Expected cancel(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::cancel, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeVibrationCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeWebSocketModuleCxxSpecJSI : public TurboModule {
+protected:
+  NativeWebSocketModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void connect(jsi::Runtime &rt, jsi::String url, std::optional<jsi::Array> protocols, jsi::Object options, double socketID) = 0;
+  virtual void send(jsi::Runtime &rt, jsi::String message, double forSocketID) = 0;
+  virtual void sendBinary(jsi::Runtime &rt, jsi::String base64String, double forSocketID) = 0;
+  virtual void ping(jsi::Runtime &rt, double socketID) = 0;
+  virtual void close(jsi::Runtime &rt, double code, jsi::String reason, double socketID) = 0;
+  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
+  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeWebSocketModuleCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "WebSocketModule";
+
+protected:
+  NativeWebSocketModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeWebSocketModuleCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeWebSocketModuleCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeWebSocketModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void connect(jsi::Runtime &rt, jsi::String url, std::optional<jsi::Array> protocols, jsi::Object options, double socketID) override {
+      static_assert(
+          bridging::getParameterCount(&T::connect) == 5,
+          "Expected connect(...) to have 5 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::connect, jsInvoker_, instance_, std::move(url), std::move(protocols), std::move(options), std::move(socketID));
+    }
+    void send(jsi::Runtime &rt, jsi::String message, double forSocketID) override {
+      static_assert(
+          bridging::getParameterCount(&T::send) == 3,
+          "Expected send(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::send, jsInvoker_, instance_, std::move(message), std::move(forSocketID));
+    }
+    void sendBinary(jsi::Runtime &rt, jsi::String base64String, double forSocketID) override {
+      static_assert(
+          bridging::getParameterCount(&T::sendBinary) == 3,
+          "Expected sendBinary(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::sendBinary, jsInvoker_, instance_, std::move(base64String), std::move(forSocketID));
+    }
+    void ping(jsi::Runtime &rt, double socketID) override {
+      static_assert(
+          bridging::getParameterCount(&T::ping) == 2,
+          "Expected ping(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::ping, jsInvoker_, instance_, std::move(socketID));
+    }
+    void close(jsi::Runtime &rt, double code, jsi::String reason, double socketID) override {
+      static_assert(
+          bridging::getParameterCount(&T::close) == 4,
+          "Expected close(...) to have 4 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::close, jsInvoker_, instance_, std::move(code), std::move(reason), std::move(socketID));
+    }
+    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
+      static_assert(
+          bridging::getParameterCount(&T::addListener) == 2,
+          "Expected addListener(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
+    }
+    void removeListeners(jsi::Runtime &rt, double count) override {
+      static_assert(
+          bridging::getParameterCount(&T::removeListeners) == 2,
+          "Expected removeListeners(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
+    }
+
+  private:
+    friend class NativeWebSocketModuleCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeDOMCxxSpecJSI : public TurboModule {
+protected:
+  NativeDOMCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual double compareDocumentPosition(jsi::Runtime &rt, jsi::Value nativeNodeReference, jsi::Value otherNativeNodeReference) = 0;
+  virtual jsi::Array getChildNodes(jsi::Runtime &rt, jsi::Value nativeNodeReference) = 0;
+  virtual jsi::Value getParentNode(jsi::Runtime &rt, jsi::Value nativeNodeReference) = 0;
+  virtual bool isConnected(jsi::Runtime &rt, jsi::Value nativeNodeReference) = 0;
+  virtual jsi::Array getBorderWidth(jsi::Runtime &rt, jsi::Value nativeElementReference) = 0;
+  virtual jsi::Array getBoundingClientRect(jsi::Runtime &rt, jsi::Value nativeElementReference, bool includeTransform) = 0;
+  virtual jsi::Array getInnerSize(jsi::Runtime &rt, jsi::Value nativeElementReference) = 0;
+  virtual jsi::Array getScrollPosition(jsi::Runtime &rt, jsi::Value nativeElementReference) = 0;
+  virtual jsi::Array getScrollSize(jsi::Runtime &rt, jsi::Value nativeElementReference) = 0;
+  virtual jsi::String getTagName(jsi::Runtime &rt, jsi::Value nativeElementReference) = 0;
+  virtual jsi::String getTextContent(jsi::Runtime &rt, jsi::Value nativeElementReference) = 0;
+  virtual bool hasPointerCapture(jsi::Runtime &rt, jsi::Value nativeElementReference, double pointerId) = 0;
+  virtual void releasePointerCapture(jsi::Runtime &rt, jsi::Value nativeElementReference, double pointerId) = 0;
+  virtual void setPointerCapture(jsi::Runtime &rt, jsi::Value nativeElementReference, double pointerId) = 0;
+  virtual jsi::Array getOffset(jsi::Runtime &rt, jsi::Value nativeElementReference) = 0;
+  virtual jsi::Value linkRootNode(jsi::Runtime &rt, double rootTag, jsi::Value instanceHandle) = 0;
+  virtual void measure(jsi::Runtime &rt, jsi::Value nativeElementReference, jsi::Function callback) = 0;
+  virtual void measureInWindow(jsi::Runtime &rt, jsi::Value nativeElementReference, jsi::Function callback) = 0;
+  virtual void measureLayout(jsi::Runtime &rt, jsi::Value nativeElementReference, jsi::Value relativeNode, jsi::Function onFail, jsi::Function onSuccess) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeDOMCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativeDOMCxx";
+
+protected:
+  NativeDOMCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeDOMCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeDOMCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeDOMCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    double compareDocumentPosition(jsi::Runtime &rt, jsi::Value nativeNodeReference, jsi::Value otherNativeNodeReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::compareDocumentPosition) == 3,
+          "Expected compareDocumentPosition(...) to have 3 parameters");
+
+      return bridging::callFromJs<double>(
+          rt, &T::compareDocumentPosition, jsInvoker_, instance_, std::move(nativeNodeReference), std::move(otherNativeNodeReference));
+    }
+    jsi::Array getChildNodes(jsi::Runtime &rt, jsi::Value nativeNodeReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getChildNodes) == 2,
+          "Expected getChildNodes(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getChildNodes, jsInvoker_, instance_, std::move(nativeNodeReference));
+    }
+    jsi::Value getParentNode(jsi::Runtime &rt, jsi::Value nativeNodeReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getParentNode) == 2,
+          "Expected getParentNode(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::getParentNode, jsInvoker_, instance_, std::move(nativeNodeReference));
+    }
+    bool isConnected(jsi::Runtime &rt, jsi::Value nativeNodeReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::isConnected) == 2,
+          "Expected isConnected(...) to have 2 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::isConnected, jsInvoker_, instance_, std::move(nativeNodeReference));
+    }
+    jsi::Array getBorderWidth(jsi::Runtime &rt, jsi::Value nativeElementReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getBorderWidth) == 2,
+          "Expected getBorderWidth(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getBorderWidth, jsInvoker_, instance_, std::move(nativeElementReference));
+    }
+    jsi::Array getBoundingClientRect(jsi::Runtime &rt, jsi::Value nativeElementReference, bool includeTransform) override {
+      static_assert(
+          bridging::getParameterCount(&T::getBoundingClientRect) == 3,
+          "Expected getBoundingClientRect(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getBoundingClientRect, jsInvoker_, instance_, std::move(nativeElementReference), std::move(includeTransform));
+    }
+    jsi::Array getInnerSize(jsi::Runtime &rt, jsi::Value nativeElementReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getInnerSize) == 2,
+          "Expected getInnerSize(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getInnerSize, jsInvoker_, instance_, std::move(nativeElementReference));
+    }
+    jsi::Array getScrollPosition(jsi::Runtime &rt, jsi::Value nativeElementReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getScrollPosition) == 2,
+          "Expected getScrollPosition(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getScrollPosition, jsInvoker_, instance_, std::move(nativeElementReference));
+    }
+    jsi::Array getScrollSize(jsi::Runtime &rt, jsi::Value nativeElementReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getScrollSize) == 2,
+          "Expected getScrollSize(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getScrollSize, jsInvoker_, instance_, std::move(nativeElementReference));
+    }
+    jsi::String getTagName(jsi::Runtime &rt, jsi::Value nativeElementReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getTagName) == 2,
+          "Expected getTagName(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::String>(
+          rt, &T::getTagName, jsInvoker_, instance_, std::move(nativeElementReference));
+    }
+    jsi::String getTextContent(jsi::Runtime &rt, jsi::Value nativeElementReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getTextContent) == 2,
+          "Expected getTextContent(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::String>(
+          rt, &T::getTextContent, jsInvoker_, instance_, std::move(nativeElementReference));
+    }
+    bool hasPointerCapture(jsi::Runtime &rt, jsi::Value nativeElementReference, double pointerId) override {
+      static_assert(
+          bridging::getParameterCount(&T::hasPointerCapture) == 3,
+          "Expected hasPointerCapture(...) to have 3 parameters");
+
+      return bridging::callFromJs<bool>(
+          rt, &T::hasPointerCapture, jsInvoker_, instance_, std::move(nativeElementReference), std::move(pointerId));
+    }
+    void releasePointerCapture(jsi::Runtime &rt, jsi::Value nativeElementReference, double pointerId) override {
+      static_assert(
+          bridging::getParameterCount(&T::releasePointerCapture) == 3,
+          "Expected releasePointerCapture(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::releasePointerCapture, jsInvoker_, instance_, std::move(nativeElementReference), std::move(pointerId));
+    }
+    void setPointerCapture(jsi::Runtime &rt, jsi::Value nativeElementReference, double pointerId) override {
+      static_assert(
+          bridging::getParameterCount(&T::setPointerCapture) == 3,
+          "Expected setPointerCapture(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::setPointerCapture, jsInvoker_, instance_, std::move(nativeElementReference), std::move(pointerId));
+    }
+    jsi::Array getOffset(jsi::Runtime &rt, jsi::Value nativeElementReference) override {
+      static_assert(
+          bridging::getParameterCount(&T::getOffset) == 2,
+          "Expected getOffset(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getOffset, jsInvoker_, instance_, std::move(nativeElementReference));
+    }
+    jsi::Value linkRootNode(jsi::Runtime &rt, double rootTag, jsi::Value instanceHandle) override {
+      static_assert(
+          bridging::getParameterCount(&T::linkRootNode) == 3,
+          "Expected linkRootNode(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::linkRootNode, jsInvoker_, instance_, std::move(rootTag), std::move(instanceHandle));
+    }
+    void measure(jsi::Runtime &rt, jsi::Value nativeElementReference, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::measure) == 3,
+          "Expected measure(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::measure, jsInvoker_, instance_, std::move(nativeElementReference), std::move(callback));
+    }
+    void measureInWindow(jsi::Runtime &rt, jsi::Value nativeElementReference, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::measureInWindow) == 3,
+          "Expected measureInWindow(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::measureInWindow, jsInvoker_, instance_, std::move(nativeElementReference), std::move(callback));
+    }
+    void measureLayout(jsi::Runtime &rt, jsi::Value nativeElementReference, jsi::Value relativeNode, jsi::Function onFail, jsi::Function onSuccess) override {
+      static_assert(
+          bridging::getParameterCount(&T::measureLayout) == 5,
+          "Expected measureLayout(...) to have 5 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::measureLayout, jsInvoker_, instance_, std::move(nativeElementReference), std::move(relativeNode), std::move(onFail), std::move(onSuccess));
+    }
+
+  private:
+    friend class NativeDOMCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeIdleCallbacksIdleDeadline
+
+template <typename P0, typename P1>
+struct NativeIdleCallbacksIdleDeadline {
+  P0 didTimeout;
+  P1 timeRemaining;
+  bool operator==(const NativeIdleCallbacksIdleDeadline &other) const {
+    return didTimeout == other.didTimeout && timeRemaining == other.timeRemaining;
+  }
+};
+
+template <typename T>
+struct NativeIdleCallbacksIdleDeadlineBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.didTimeout)>(rt, value.getProperty(rt, "didTimeout"), jsInvoker),
+      bridging::fromJs<decltype(types.timeRemaining)>(rt, value.getProperty(rt, "timeRemaining"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static bool didTimeoutToJs(jsi::Runtime &rt, decltype(types.didTimeout) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Function timeRemainingToJs(jsi::Runtime &rt, decltype(types.timeRemaining) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "didTimeout", bridging::toJs(rt, value.didTimeout, jsInvoker));
+    result.setProperty(rt, "timeRemaining", bridging::toJs(rt, value.timeRemaining, jsInvoker));
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeIdleCallbacksRequestIdleCallbackOptions
+
+template <typename P0>
+struct NativeIdleCallbacksRequestIdleCallbackOptions {
+  P0 timeout;
+  bool operator==(const NativeIdleCallbacksRequestIdleCallbackOptions &other) const {
+    return timeout == other.timeout;
+  }
+};
+
+template <typename T>
+struct NativeIdleCallbacksRequestIdleCallbackOptionsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.timeout)>(rt, value.getProperty(rt, "timeout"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double timeoutToJs(jsi::Runtime &rt, decltype(types.timeout) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    if (value.timeout) {
+      result.setProperty(rt, "timeout", bridging::toJs(rt, value.timeout.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeIdleCallbacksCxxSpecJSI : public TurboModule {
+protected:
+  NativeIdleCallbacksCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual jsi::Value requestIdleCallback(jsi::Runtime &rt, jsi::Function callback, std::optional<jsi::Object> options) = 0;
+  virtual void cancelIdleCallback(jsi::Runtime &rt, jsi::Value handle) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeIdleCallbacksCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativeIdleCallbacksCxx";
+
+protected:
+  NativeIdleCallbacksCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeIdleCallbacksCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeIdleCallbacksCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeIdleCallbacksCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    jsi::Value requestIdleCallback(jsi::Runtime &rt, jsi::Function callback, std::optional<jsi::Object> options) override {
+      static_assert(
+          bridging::getParameterCount(&T::requestIdleCallback) == 3,
+          "Expected requestIdleCallback(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::requestIdleCallback, jsInvoker_, instance_, std::move(callback), std::move(options));
+    }
+    void cancelIdleCallback(jsi::Runtime &rt, jsi::Value handle) override {
+      static_assert(
+          bridging::getParameterCount(&T::cancelIdleCallback) == 2,
+          "Expected cancelIdleCallback(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::cancelIdleCallback, jsInvoker_, instance_, std::move(handle));
+    }
+
+  private:
+    friend class NativeIdleCallbacksCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeIntersectionObserverNativeIntersectionObserverEntry
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
+struct NativeIntersectionObserverNativeIntersectionObserverEntry {
+  P0 intersectionObserverId;
+  P1 targetInstanceHandle;
+  P2 targetRect;
+  P3 rootRect;
+  P4 intersectionRect;
+  P5 isIntersectingAboveThresholds;
+  P6 time;
+  bool operator==(const NativeIntersectionObserverNativeIntersectionObserverEntry &other) const {
+    return intersectionObserverId == other.intersectionObserverId && targetInstanceHandle == other.targetInstanceHandle && targetRect == other.targetRect && rootRect == other.rootRect && intersectionRect == other.intersectionRect && isIntersectingAboveThresholds == other.isIntersectingAboveThresholds && time == other.time;
+  }
+};
+
+template <typename T>
+struct NativeIntersectionObserverNativeIntersectionObserverEntryBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.intersectionObserverId)>(rt, value.getProperty(rt, "intersectionObserverId"), jsInvoker),
+      bridging::fromJs<decltype(types.targetInstanceHandle)>(rt, value.getProperty(rt, "targetInstanceHandle"), jsInvoker),
+      bridging::fromJs<decltype(types.targetRect)>(rt, value.getProperty(rt, "targetRect"), jsInvoker),
+      bridging::fromJs<decltype(types.rootRect)>(rt, value.getProperty(rt, "rootRect"), jsInvoker),
+      bridging::fromJs<decltype(types.intersectionRect)>(rt, value.getProperty(rt, "intersectionRect"), jsInvoker),
+      bridging::fromJs<decltype(types.isIntersectingAboveThresholds)>(rt, value.getProperty(rt, "isIntersectingAboveThresholds"), jsInvoker),
+      bridging::fromJs<decltype(types.time)>(rt, value.getProperty(rt, "time"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double intersectionObserverIdToJs(jsi::Runtime &rt, decltype(types.intersectionObserverId) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Value targetInstanceHandleToJs(jsi::Runtime &rt, decltype(types.targetInstanceHandle) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array targetRectToJs(jsi::Runtime &rt, decltype(types.targetRect) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array rootRectToJs(jsi::Runtime &rt, decltype(types.rootRect) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::Array> intersectionRectToJs(jsi::Runtime &rt, decltype(types.intersectionRect) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool isIntersectingAboveThresholdsToJs(jsi::Runtime &rt, decltype(types.isIntersectingAboveThresholds) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double timeToJs(jsi::Runtime &rt, decltype(types.time) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "intersectionObserverId", bridging::toJs(rt, value.intersectionObserverId, jsInvoker));
+    result.setProperty(rt, "targetInstanceHandle", bridging::toJs(rt, value.targetInstanceHandle, jsInvoker));
+    result.setProperty(rt, "targetRect", bridging::toJs(rt, value.targetRect, jsInvoker));
+    result.setProperty(rt, "rootRect", bridging::toJs(rt, value.rootRect, jsInvoker));
+    result.setProperty(rt, "intersectionRect", bridging::toJs(rt, value.intersectionRect, jsInvoker));
+    result.setProperty(rt, "isIntersectingAboveThresholds", bridging::toJs(rt, value.isIntersectingAboveThresholds, jsInvoker));
+    result.setProperty(rt, "time", bridging::toJs(rt, value.time, jsInvoker));
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeIntersectionObserverNativeIntersectionObserverObserveOptions
+
+template <typename P0, typename P1, typename P2, typename P3>
+struct NativeIntersectionObserverNativeIntersectionObserverObserveOptions {
+  P0 intersectionObserverId;
+  P1 targetShadowNode;
+  P2 thresholds;
+  P3 rootThresholds;
+  bool operator==(const NativeIntersectionObserverNativeIntersectionObserverObserveOptions &other) const {
+    return intersectionObserverId == other.intersectionObserverId && targetShadowNode == other.targetShadowNode && thresholds == other.thresholds && rootThresholds == other.rootThresholds;
+  }
+};
+
+template <typename T>
+struct NativeIntersectionObserverNativeIntersectionObserverObserveOptionsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.intersectionObserverId)>(rt, value.getProperty(rt, "intersectionObserverId"), jsInvoker),
+      bridging::fromJs<decltype(types.targetShadowNode)>(rt, value.getProperty(rt, "targetShadowNode"), jsInvoker),
+      bridging::fromJs<decltype(types.thresholds)>(rt, value.getProperty(rt, "thresholds"), jsInvoker),
+      bridging::fromJs<decltype(types.rootThresholds)>(rt, value.getProperty(rt, "rootThresholds"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double intersectionObserverIdToJs(jsi::Runtime &rt, decltype(types.intersectionObserverId) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Value targetShadowNodeToJs(jsi::Runtime &rt, decltype(types.targetShadowNode) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array thresholdsToJs(jsi::Runtime &rt, decltype(types.thresholds) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static std::optional<jsi::Array> rootThresholdsToJs(jsi::Runtime &rt, decltype(types.rootThresholds) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "intersectionObserverId", bridging::toJs(rt, value.intersectionObserverId, jsInvoker));
+    result.setProperty(rt, "targetShadowNode", bridging::toJs(rt, value.targetShadowNode, jsInvoker));
+    result.setProperty(rt, "thresholds", bridging::toJs(rt, value.thresholds, jsInvoker));
+    if (value.rootThresholds) {
+      result.setProperty(rt, "rootThresholds", bridging::toJs(rt, value.rootThresholds.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeIntersectionObserverCxxSpecJSI : public TurboModule {
+protected:
+  NativeIntersectionObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void observe(jsi::Runtime &rt, jsi::Object options) = 0;
+  virtual void unobserve(jsi::Runtime &rt, double intersectionObserverId, jsi::Value targetShadowNode) = 0;
+  virtual void connect(jsi::Runtime &rt, jsi::Function notifyIntersectionObserversCallback) = 0;
+  virtual void disconnect(jsi::Runtime &rt) = 0;
+  virtual jsi::Array takeRecords(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeIntersectionObserverCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativeIntersectionObserverCxx";
+
+protected:
+  NativeIntersectionObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeIntersectionObserverCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeIntersectionObserverCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeIntersectionObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void observe(jsi::Runtime &rt, jsi::Object options) override {
+      static_assert(
+          bridging::getParameterCount(&T::observe) == 2,
+          "Expected observe(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::observe, jsInvoker_, instance_, std::move(options));
+    }
+    void unobserve(jsi::Runtime &rt, double intersectionObserverId, jsi::Value targetShadowNode) override {
+      static_assert(
+          bridging::getParameterCount(&T::unobserve) == 3,
+          "Expected unobserve(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::unobserve, jsInvoker_, instance_, std::move(intersectionObserverId), std::move(targetShadowNode));
+    }
+    void connect(jsi::Runtime &rt, jsi::Function notifyIntersectionObserversCallback) override {
+      static_assert(
+          bridging::getParameterCount(&T::connect) == 2,
+          "Expected connect(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::connect, jsInvoker_, instance_, std::move(notifyIntersectionObserversCallback));
+    }
+    void disconnect(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::disconnect) == 1,
+          "Expected disconnect(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::disconnect, jsInvoker_, instance_);
+    }
+    jsi::Array takeRecords(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::takeRecords) == 1,
+          "Expected takeRecords(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::takeRecords, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeIntersectionObserverCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  class JSI_EXPORT NativeMicrotasksCxxSpecJSI : public TurboModule {
+protected:
+  NativeMicrotasksCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void queueMicrotask(jsi::Runtime &rt, jsi::Function callback) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeMicrotasksCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativeMicrotasksCxx";
+
+protected:
+  NativeMicrotasksCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeMicrotasksCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeMicrotasksCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeMicrotasksCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void queueMicrotask(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::queueMicrotask) == 2,
+          "Expected queueMicrotask(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::queueMicrotask, jsInvoker_, instance_, std::move(callback));
+    }
+
+  private:
+    friend class NativeMicrotasksCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+#pragma mark - NativeMutationObserverNativeMutationObserverObserveOptions
+
+template <typename P0, typename P1, typename P2>
+struct NativeMutationObserverNativeMutationObserverObserveOptions {
+  P0 mutationObserverId;
+  P1 targetShadowNode;
+  P2 subtree;
+  bool operator==(const NativeMutationObserverNativeMutationObserverObserveOptions &other) const {
+    return mutationObserverId == other.mutationObserverId && targetShadowNode == other.targetShadowNode && subtree == other.subtree;
+  }
+};
+
+template <typename T>
+struct NativeMutationObserverNativeMutationObserverObserveOptionsBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.mutationObserverId)>(rt, value.getProperty(rt, "mutationObserverId"), jsInvoker),
+      bridging::fromJs<decltype(types.targetShadowNode)>(rt, value.getProperty(rt, "targetShadowNode"), jsInvoker),
+      bridging::fromJs<decltype(types.subtree)>(rt, value.getProperty(rt, "subtree"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double mutationObserverIdToJs(jsi::Runtime &rt, decltype(types.mutationObserverId) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Value targetShadowNodeToJs(jsi::Runtime &rt, decltype(types.targetShadowNode) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool subtreeToJs(jsi::Runtime &rt, decltype(types.subtree) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "mutationObserverId", bridging::toJs(rt, value.mutationObserverId, jsInvoker));
+    result.setProperty(rt, "targetShadowNode", bridging::toJs(rt, value.targetShadowNode, jsInvoker));
+    result.setProperty(rt, "subtree", bridging::toJs(rt, value.subtree, jsInvoker));
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativeMutationObserverNativeMutationRecord
+
+template <typename P0, typename P1, typename P2, typename P3>
+struct NativeMutationObserverNativeMutationRecord {
+  P0 mutationObserverId;
+  P1 target;
+  P2 addedNodes;
+  P3 removedNodes;
+  bool operator==(const NativeMutationObserverNativeMutationRecord &other) const {
+    return mutationObserverId == other.mutationObserverId && target == other.target && addedNodes == other.addedNodes && removedNodes == other.removedNodes;
+  }
+};
+
+template <typename T>
+struct NativeMutationObserverNativeMutationRecordBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.mutationObserverId)>(rt, value.getProperty(rt, "mutationObserverId"), jsInvoker),
+      bridging::fromJs<decltype(types.target)>(rt, value.getProperty(rt, "target"), jsInvoker),
+      bridging::fromJs<decltype(types.addedNodes)>(rt, value.getProperty(rt, "addedNodes"), jsInvoker),
+      bridging::fromJs<decltype(types.removedNodes)>(rt, value.getProperty(rt, "removedNodes"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static double mutationObserverIdToJs(jsi::Runtime &rt, decltype(types.mutationObserverId) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Value targetToJs(jsi::Runtime &rt, decltype(types.target) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array addedNodesToJs(jsi::Runtime &rt, decltype(types.addedNodes) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static jsi::Array removedNodesToJs(jsi::Runtime &rt, decltype(types.removedNodes) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "mutationObserverId", bridging::toJs(rt, value.mutationObserverId, jsInvoker));
+    result.setProperty(rt, "target", bridging::toJs(rt, value.target, jsInvoker));
+    result.setProperty(rt, "addedNodes", bridging::toJs(rt, value.addedNodes, jsInvoker));
+    result.setProperty(rt, "removedNodes", bridging::toJs(rt, value.removedNodes, jsInvoker));
+    return result;
+  }
+};
+
+class JSI_EXPORT NativeMutationObserverCxxSpecJSI : public TurboModule {
+protected:
+  NativeMutationObserverCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual void observe(jsi::Runtime &rt, jsi::Object options) = 0;
+  virtual void unobserve(jsi::Runtime &rt, double mutationObserverId, jsi::Value targetShadowNode) = 0;
+  virtual void connect(jsi::Runtime &rt, jsi::Function notifyMutationObservers, jsi::Function getPublicInstanceFromInstanceHandle) = 0;
+  virtual void disconnect(jsi::Runtime &rt) = 0;
+  virtual jsi::Array takeRecords(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativeMutationObserverCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativeMutationObserverCxx";
+
+protected:
+  NativeMutationObserverCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativeMutationObserverCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativeMutationObserverCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativeMutationObserverCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    void observe(jsi::Runtime &rt, jsi::Object options) override {
+      static_assert(
+          bridging::getParameterCount(&T::observe) == 2,
+          "Expected observe(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::observe, jsInvoker_, instance_, std::move(options));
+    }
+    void unobserve(jsi::Runtime &rt, double mutationObserverId, jsi::Value targetShadowNode) override {
+      static_assert(
+          bridging::getParameterCount(&T::unobserve) == 3,
+          "Expected unobserve(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::unobserve, jsInvoker_, instance_, std::move(mutationObserverId), std::move(targetShadowNode));
+    }
+    void connect(jsi::Runtime &rt, jsi::Function notifyMutationObservers, jsi::Function getPublicInstanceFromInstanceHandle) override {
+      static_assert(
+          bridging::getParameterCount(&T::connect) == 3,
+          "Expected connect(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::connect, jsInvoker_, instance_, std::move(notifyMutationObservers), std::move(getPublicInstanceFromInstanceHandle));
+    }
+    void disconnect(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::disconnect) == 1,
+          "Expected disconnect(...) to have 1 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::disconnect, jsInvoker_, instance_);
+    }
+    jsi::Array takeRecords(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::takeRecords) == 1,
+          "Expected takeRecords(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::takeRecords, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativeMutationObserverCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+
+  
+
+#pragma mark - NativePerformancePerformanceObserverInit
+
+template <typename P0, typename P1, typename P2, typename P3>
+struct NativePerformancePerformanceObserverInit {
+  P0 entryTypes;
+  P1 type;
+  P2 buffered;
+  P3 durationThreshold;
+  bool operator==(const NativePerformancePerformanceObserverInit &other) const {
+    return entryTypes == other.entryTypes && type == other.type && buffered == other.buffered && durationThreshold == other.durationThreshold;
+  }
+};
+
+template <typename T>
+struct NativePerformancePerformanceObserverInitBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.entryTypes)>(rt, value.getProperty(rt, "entryTypes"), jsInvoker),
+      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
+      bridging::fromJs<decltype(types.buffered)>(rt, value.getProperty(rt, "buffered"), jsInvoker),
+      bridging::fromJs<decltype(types.durationThreshold)>(rt, value.getProperty(rt, "durationThreshold"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::Array entryTypesToJs(jsi::Runtime &rt, decltype(types.entryTypes) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static bool bufferedToJs(jsi::Runtime &rt, decltype(types.buffered) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double durationThresholdToJs(jsi::Runtime &rt, decltype(types.durationThreshold) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    if (value.entryTypes) {
+      result.setProperty(rt, "entryTypes", bridging::toJs(rt, value.entryTypes.value(), jsInvoker));
+    }
+    if (value.type) {
+      result.setProperty(rt, "type", bridging::toJs(rt, value.type.value(), jsInvoker));
+    }
+    if (value.buffered) {
+      result.setProperty(rt, "buffered", bridging::toJs(rt, value.buffered.value(), jsInvoker));
+    }
+    if (value.durationThreshold) {
+      result.setProperty(rt, "durationThreshold", bridging::toJs(rt, value.durationThreshold.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+
+#pragma mark - NativePerformanceRawPerformanceEntry
+
+template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13>
+struct NativePerformanceRawPerformanceEntry {
+  P0 name;
+  P1 entryType;
+  P2 startTime;
+  P3 duration;
+  P4 processingStart;
+  P5 processingEnd;
+  P6 interactionId;
+  P7 fetchStart;
+  P8 requestStart;
+  P9 connectStart;
+  P10 connectEnd;
+  P11 responseStart;
+  P12 responseEnd;
+  P13 responseStatus;
+  bool operator==(const NativePerformanceRawPerformanceEntry &other) const {
+    return name == other.name && entryType == other.entryType && startTime == other.startTime && duration == other.duration && processingStart == other.processingStart && processingEnd == other.processingEnd && interactionId == other.interactionId && fetchStart == other.fetchStart && requestStart == other.requestStart && connectStart == other.connectStart && connectEnd == other.connectEnd && responseStart == other.responseStart && responseEnd == other.responseEnd && responseStatus == other.responseStatus;
+  }
+};
+
+template <typename T>
+struct NativePerformanceRawPerformanceEntryBridging {
+  static T types;
+
+  static T fromJs(
+      jsi::Runtime &rt,
+      const jsi::Object &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    T result{
+      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
+      bridging::fromJs<decltype(types.entryType)>(rt, value.getProperty(rt, "entryType"), jsInvoker),
+      bridging::fromJs<decltype(types.startTime)>(rt, value.getProperty(rt, "startTime"), jsInvoker),
+      bridging::fromJs<decltype(types.duration)>(rt, value.getProperty(rt, "duration"), jsInvoker),
+      bridging::fromJs<decltype(types.processingStart)>(rt, value.getProperty(rt, "processingStart"), jsInvoker),
+      bridging::fromJs<decltype(types.processingEnd)>(rt, value.getProperty(rt, "processingEnd"), jsInvoker),
+      bridging::fromJs<decltype(types.interactionId)>(rt, value.getProperty(rt, "interactionId"), jsInvoker),
+      bridging::fromJs<decltype(types.fetchStart)>(rt, value.getProperty(rt, "fetchStart"), jsInvoker),
+      bridging::fromJs<decltype(types.requestStart)>(rt, value.getProperty(rt, "requestStart"), jsInvoker),
+      bridging::fromJs<decltype(types.connectStart)>(rt, value.getProperty(rt, "connectStart"), jsInvoker),
+      bridging::fromJs<decltype(types.connectEnd)>(rt, value.getProperty(rt, "connectEnd"), jsInvoker),
+      bridging::fromJs<decltype(types.responseStart)>(rt, value.getProperty(rt, "responseStart"), jsInvoker),
+      bridging::fromJs<decltype(types.responseEnd)>(rt, value.getProperty(rt, "responseEnd"), jsInvoker),
+      bridging::fromJs<decltype(types.responseStatus)>(rt, value.getProperty(rt, "responseStatus"), jsInvoker)};
+    return result;
+  }
+
+#ifdef DEBUG
+  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double entryTypeToJs(jsi::Runtime &rt, decltype(types.entryType) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double startTimeToJs(jsi::Runtime &rt, decltype(types.startTime) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double durationToJs(jsi::Runtime &rt, decltype(types.duration) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double processingStartToJs(jsi::Runtime &rt, decltype(types.processingStart) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double processingEndToJs(jsi::Runtime &rt, decltype(types.processingEnd) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double interactionIdToJs(jsi::Runtime &rt, decltype(types.interactionId) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double fetchStartToJs(jsi::Runtime &rt, decltype(types.fetchStart) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double requestStartToJs(jsi::Runtime &rt, decltype(types.requestStart) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double connectStartToJs(jsi::Runtime &rt, decltype(types.connectStart) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double connectEndToJs(jsi::Runtime &rt, decltype(types.connectEnd) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double responseStartToJs(jsi::Runtime &rt, decltype(types.responseStart) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double responseEndToJs(jsi::Runtime &rt, decltype(types.responseEnd) value) {
+    return bridging::toJs(rt, value);
+  }
+
+  static double responseStatusToJs(jsi::Runtime &rt, decltype(types.responseStatus) value) {
+    return bridging::toJs(rt, value);
+  }
+#endif
+
+  static jsi::Object toJs(
+      jsi::Runtime &rt,
+      const T &value,
+      const std::shared_ptr<CallInvoker> &jsInvoker) {
+    auto result = facebook::jsi::Object(rt);
+    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
+    result.setProperty(rt, "entryType", bridging::toJs(rt, value.entryType, jsInvoker));
+    result.setProperty(rt, "startTime", bridging::toJs(rt, value.startTime, jsInvoker));
+    result.setProperty(rt, "duration", bridging::toJs(rt, value.duration, jsInvoker));
+    if (value.processingStart) {
+      result.setProperty(rt, "processingStart", bridging::toJs(rt, value.processingStart.value(), jsInvoker));
+    }
+    if (value.processingEnd) {
+      result.setProperty(rt, "processingEnd", bridging::toJs(rt, value.processingEnd.value(), jsInvoker));
+    }
+    if (value.interactionId) {
+      result.setProperty(rt, "interactionId", bridging::toJs(rt, value.interactionId.value(), jsInvoker));
+    }
+    if (value.fetchStart) {
+      result.setProperty(rt, "fetchStart", bridging::toJs(rt, value.fetchStart.value(), jsInvoker));
+    }
+    if (value.requestStart) {
+      result.setProperty(rt, "requestStart", bridging::toJs(rt, value.requestStart.value(), jsInvoker));
+    }
+    if (value.connectStart) {
+      result.setProperty(rt, "connectStart", bridging::toJs(rt, value.connectStart.value(), jsInvoker));
+    }
+    if (value.connectEnd) {
+      result.setProperty(rt, "connectEnd", bridging::toJs(rt, value.connectEnd.value(), jsInvoker));
+    }
+    if (value.responseStart) {
+      result.setProperty(rt, "responseStart", bridging::toJs(rt, value.responseStart.value(), jsInvoker));
+    }
+    if (value.responseEnd) {
+      result.setProperty(rt, "responseEnd", bridging::toJs(rt, value.responseEnd.value(), jsInvoker));
+    }
+    if (value.responseStatus) {
+      result.setProperty(rt, "responseStatus", bridging::toJs(rt, value.responseStatus.value(), jsInvoker));
+    }
+    return result;
+  }
+};
+
+
+class JSI_EXPORT NativePerformanceCxxSpecJSI : public TurboModule {
+protected:
+  NativePerformanceCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);
+
+public:
+  virtual double now(jsi::Runtime &rt) = 0;
+  virtual double markWithResult(jsi::Runtime &rt, jsi::String name, std::optional<double> startTime) = 0;
+  virtual jsi::Array measureWithResult(jsi::Runtime &rt, jsi::String name, double startTime, double endTime, std::optional<double> duration, std::optional<jsi::String> startMark, std::optional<jsi::String> endMark) = 0;
+  virtual void clearMarks(jsi::Runtime &rt, std::optional<jsi::String> entryName) = 0;
+  virtual void clearMeasures(jsi::Runtime &rt, std::optional<jsi::String> entryName) = 0;
+  virtual jsi::Array getEntries(jsi::Runtime &rt) = 0;
+  virtual jsi::Array getEntriesByName(jsi::Runtime &rt, jsi::String entryName, std::optional<double> entryType) = 0;
+  virtual jsi::Array getEntriesByType(jsi::Runtime &rt, double entryType) = 0;
+  virtual jsi::Array getEventCounts(jsi::Runtime &rt) = 0;
+  virtual jsi::Object getSimpleMemoryInfo(jsi::Runtime &rt) = 0;
+  virtual jsi::Object getReactNativeStartupTiming(jsi::Runtime &rt) = 0;
+  virtual jsi::Value createObserver(jsi::Runtime &rt, jsi::Function callback) = 0;
+  virtual double getDroppedEntriesCount(jsi::Runtime &rt, jsi::Value observer) = 0;
+  virtual void observe(jsi::Runtime &rt, jsi::Value observer, jsi::Object options) = 0;
+  virtual void disconnect(jsi::Runtime &rt, jsi::Value observer) = 0;
+  virtual jsi::Array takeRecords(jsi::Runtime &rt, jsi::Value observer, bool sort) = 0;
+  virtual jsi::Array getSupportedPerformanceEntryTypes(jsi::Runtime &rt) = 0;
+
+};
+
+template <typename T>
+class JSI_EXPORT NativePerformanceCxxSpec : public TurboModule {
+public:
+  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
+    return delegate_.create(rt, propName);
+  }
+
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
+    return delegate_.getPropertyNames(runtime);
+  }
+
+  static constexpr std::string_view kModuleName = "NativePerformanceCxx";
+
+protected:
+  NativePerformanceCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
+    : TurboModule(std::string{NativePerformanceCxxSpec::kModuleName}, jsInvoker),
+      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}
+
+
+private:
+  class Delegate : public NativePerformanceCxxSpecJSI {
+  public:
+    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
+      NativePerformanceCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
+
+    }
+
+    double now(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::now) == 1,
+          "Expected now(...) to have 1 parameters");
+
+      return bridging::callFromJs<double>(
+          rt, &T::now, jsInvoker_, instance_);
+    }
+    double markWithResult(jsi::Runtime &rt, jsi::String name, std::optional<double> startTime) override {
+      static_assert(
+          bridging::getParameterCount(&T::markWithResult) == 3,
+          "Expected markWithResult(...) to have 3 parameters");
+
+      return bridging::callFromJs<double>(
+          rt, &T::markWithResult, jsInvoker_, instance_, std::move(name), std::move(startTime));
+    }
+    jsi::Array measureWithResult(jsi::Runtime &rt, jsi::String name, double startTime, double endTime, std::optional<double> duration, std::optional<jsi::String> startMark, std::optional<jsi::String> endMark) override {
+      static_assert(
+          bridging::getParameterCount(&T::measureWithResult) == 7,
+          "Expected measureWithResult(...) to have 7 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::measureWithResult, jsInvoker_, instance_, std::move(name), std::move(startTime), std::move(endTime), std::move(duration), std::move(startMark), std::move(endMark));
+    }
+    void clearMarks(jsi::Runtime &rt, std::optional<jsi::String> entryName) override {
+      static_assert(
+          bridging::getParameterCount(&T::clearMarks) == 2,
+          "Expected clearMarks(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::clearMarks, jsInvoker_, instance_, std::move(entryName));
+    }
+    void clearMeasures(jsi::Runtime &rt, std::optional<jsi::String> entryName) override {
+      static_assert(
+          bridging::getParameterCount(&T::clearMeasures) == 2,
+          "Expected clearMeasures(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::clearMeasures, jsInvoker_, instance_, std::move(entryName));
+    }
+    jsi::Array getEntries(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getEntries) == 1,
+          "Expected getEntries(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getEntries, jsInvoker_, instance_);
+    }
+    jsi::Array getEntriesByName(jsi::Runtime &rt, jsi::String entryName, std::optional<double> entryType) override {
+      static_assert(
+          bridging::getParameterCount(&T::getEntriesByName) == 3,
+          "Expected getEntriesByName(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getEntriesByName, jsInvoker_, instance_, std::move(entryName), std::move(entryType));
+    }
+    jsi::Array getEntriesByType(jsi::Runtime &rt, double entryType) override {
+      static_assert(
+          bridging::getParameterCount(&T::getEntriesByType) == 2,
+          "Expected getEntriesByType(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getEntriesByType, jsInvoker_, instance_, std::move(entryType));
+    }
+    jsi::Array getEventCounts(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getEventCounts) == 1,
+          "Expected getEventCounts(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getEventCounts, jsInvoker_, instance_);
+    }
+    jsi::Object getSimpleMemoryInfo(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSimpleMemoryInfo) == 1,
+          "Expected getSimpleMemoryInfo(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getSimpleMemoryInfo, jsInvoker_, instance_);
+    }
+    jsi::Object getReactNativeStartupTiming(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getReactNativeStartupTiming) == 1,
+          "Expected getReactNativeStartupTiming(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Object>(
+          rt, &T::getReactNativeStartupTiming, jsInvoker_, instance_);
+    }
+    jsi::Value createObserver(jsi::Runtime &rt, jsi::Function callback) override {
+      static_assert(
+          bridging::getParameterCount(&T::createObserver) == 2,
+          "Expected createObserver(...) to have 2 parameters");
+
+      return bridging::callFromJs<jsi::Value>(
+          rt, &T::createObserver, jsInvoker_, instance_, std::move(callback));
+    }
+    double getDroppedEntriesCount(jsi::Runtime &rt, jsi::Value observer) override {
+      static_assert(
+          bridging::getParameterCount(&T::getDroppedEntriesCount) == 2,
+          "Expected getDroppedEntriesCount(...) to have 2 parameters");
+
+      return bridging::callFromJs<double>(
+          rt, &T::getDroppedEntriesCount, jsInvoker_, instance_, std::move(observer));
+    }
+    void observe(jsi::Runtime &rt, jsi::Value observer, jsi::Object options) override {
+      static_assert(
+          bridging::getParameterCount(&T::observe) == 3,
+          "Expected observe(...) to have 3 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::observe, jsInvoker_, instance_, std::move(observer), std::move(options));
+    }
+    void disconnect(jsi::Runtime &rt, jsi::Value observer) override {
+      static_assert(
+          bridging::getParameterCount(&T::disconnect) == 2,
+          "Expected disconnect(...) to have 2 parameters");
+
+      return bridging::callFromJs<void>(
+          rt, &T::disconnect, jsInvoker_, instance_, std::move(observer));
+    }
+    jsi::Array takeRecords(jsi::Runtime &rt, jsi::Value observer, bool sort) override {
+      static_assert(
+          bridging::getParameterCount(&T::takeRecords) == 3,
+          "Expected takeRecords(...) to have 3 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::takeRecords, jsInvoker_, instance_, std::move(observer), std::move(sort));
+    }
+    jsi::Array getSupportedPerformanceEntryTypes(jsi::Runtime &rt) override {
+      static_assert(
+          bridging::getParameterCount(&T::getSupportedPerformanceEntryTypes) == 1,
+          "Expected getSupportedPerformanceEntryTypes(...) to have 1 parameters");
+
+      return bridging::callFromJs<jsi::Array>(
+          rt, &T::getSupportedPerformanceEntryTypes, jsInvoker_, instance_);
+    }
+
+  private:
+    friend class NativePerformanceCxxSpec;
+    T *instance_;
+  };
+
+  Delegate delegate_;
+};
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ComponentDescriptors.cpp b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ComponentDescriptors.cpp
new file mode 100644
index 0000000..43894d2
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ComponentDescriptors.cpp
@@ -0,0 +1,28 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorCpp.js
+ */
+
+#include <react/renderer/components/rncore/ComponentDescriptors.h>
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+void rncore_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry) {
+registry->add(concreteComponentDescriptorProvider<ActivityIndicatorViewComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<AndroidDrawerLayoutComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<AndroidSwipeRefreshLayoutComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<DebuggingOverlayComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<PullToRefreshViewComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<SwitchComponentDescriptor>());
+registry->add(concreteComponentDescriptorProvider<UnimplementedNativeViewComponentDescriptor>());
+}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ComponentDescriptors.h b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ComponentDescriptors.h
new file mode 100644
index 0000000..ca5da78
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ComponentDescriptors.h
@@ -0,0 +1,30 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateComponentDescriptorH.js
+ */
+
+#pragma once
+
+#include <react/renderer/components/rncore/ShadowNodes.h>
+#include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>
+
+namespace facebook::react {
+
+using ActivityIndicatorViewComponentDescriptor = ConcreteComponentDescriptor<ActivityIndicatorViewShadowNode>;
+using AndroidDrawerLayoutComponentDescriptor = ConcreteComponentDescriptor<AndroidDrawerLayoutShadowNode>;
+using AndroidSwipeRefreshLayoutComponentDescriptor = ConcreteComponentDescriptor<AndroidSwipeRefreshLayoutShadowNode>;
+using DebuggingOverlayComponentDescriptor = ConcreteComponentDescriptor<DebuggingOverlayShadowNode>;
+using PullToRefreshViewComponentDescriptor = ConcreteComponentDescriptor<PullToRefreshViewShadowNode>;
+using SwitchComponentDescriptor = ConcreteComponentDescriptor<SwitchShadowNode>;
+using UnimplementedNativeViewComponentDescriptor = ConcreteComponentDescriptor<UnimplementedNativeViewShadowNode>;
+
+void rncore_registerComponentDescriptorsFromCodegen(
+  std::shared_ptr<const ComponentDescriptorProviderRegistry> registry);
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/EventEmitters.cpp b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/EventEmitters.cpp
new file mode 100644
index 0000000..a4f46f8
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/EventEmitters.cpp
@@ -0,0 +1,132 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterCpp.js
+ */
+
+#include <react/renderer/components/rncore/EventEmitters.h>
+
+
+namespace facebook::react {
+
+
+void AndroidDrawerLayoutEventEmitter::onDrawerSlide(OnDrawerSlide event) const {
+  dispatchEvent("drawerSlide", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "offset", event.offset);
+    return payload;
+  });
+}
+
+
+void AndroidDrawerLayoutEventEmitter::onDrawerStateChanged(OnDrawerStateChanged event) const {
+  dispatchEvent("drawerStateChanged", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "drawerState", event.drawerState);
+    return payload;
+  });
+}
+
+
+void AndroidDrawerLayoutEventEmitter::onDrawerOpen(OnDrawerOpen event) const {
+  dispatchEvent("drawerOpen", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void AndroidDrawerLayoutEventEmitter::onDrawerClose(OnDrawerClose event) const {
+  dispatchEvent("drawerClose", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+
+void AndroidSwipeRefreshLayoutEventEmitter::onRefresh(OnRefresh event) const {
+  dispatchEvent("refresh", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void AndroidSwitchEventEmitter::onChange(OnChange event) const {
+  dispatchEvent("change", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "value", event.value);
+payload.setProperty(runtime, "target", event.target);
+    return payload;
+  });
+}
+
+
+
+
+void PullToRefreshViewEventEmitter::onRefresh(OnRefresh event) const {
+  dispatchEvent("refresh", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+
+void ModalHostViewEventEmitter::onRequestClose(OnRequestClose event) const {
+  dispatchEvent("requestClose", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void ModalHostViewEventEmitter::onShow(OnShow event) const {
+  dispatchEvent("show", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void ModalHostViewEventEmitter::onDismiss(OnDismiss event) const {
+  dispatchEvent("dismiss", [](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    
+    return payload;
+  });
+}
+
+
+void ModalHostViewEventEmitter::onOrientationChange(OnOrientationChange event) const {
+  dispatchEvent("orientationChange", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "orientation", toString(event.orientation));
+    return payload;
+  });
+}
+
+
+
+void SwitchEventEmitter::onChange(OnChange event) const {
+  dispatchEvent("change", [event=std::move(event)](jsi::Runtime &runtime) {
+    auto payload = jsi::Object(runtime);
+    payload.setProperty(runtime, "value", event.value);
+payload.setProperty(runtime, "target", event.target);
+    return payload;
+  });
+}
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/EventEmitters.h b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/EventEmitters.h
new file mode 100644
index 0000000..0c3bce4
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/EventEmitters.h
@@ -0,0 +1,169 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateEventEmitterH.js
+ */
+#pragma once
+
+#include <react/renderer/components/view/ViewEventEmitter.h>
+
+
+namespace facebook::react {
+class ActivityIndicatorViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class AndroidDrawerLayoutEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnDrawerSlide {
+      Float offset;
+    };
+
+  struct OnDrawerStateChanged {
+      int drawerState;
+    };
+
+  struct OnDrawerOpen {
+      
+    };
+
+  struct OnDrawerClose {
+      
+    };
+  void onDrawerSlide(OnDrawerSlide value) const;
+
+  void onDrawerStateChanged(OnDrawerStateChanged value) const;
+
+  void onDrawerOpen(OnDrawerOpen value) const;
+
+  void onDrawerClose(OnDrawerClose value) const;
+};
+class AndroidHorizontalScrollContentViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class AndroidSwipeRefreshLayoutEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnRefresh {
+      
+    };
+  void onRefresh(OnRefresh value) const;
+};
+class AndroidSwitchEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnChange {
+      bool value;
+    int target;
+    };
+  void onChange(OnChange value) const;
+};
+class DebuggingOverlayEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class AndroidProgressBarEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class PullToRefreshViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnRefresh {
+      
+    };
+  void onRefresh(OnRefresh value) const;
+};
+class InputAccessoryEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class ModalHostViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnRequestClose {
+      
+    };
+
+  struct OnShow {
+      
+    };
+
+  struct OnDismiss {
+      
+    };
+
+  enum class OnOrientationChangeOrientation {
+    Portrait,
+    Landscape
+  };
+
+  static char const *toString(const OnOrientationChangeOrientation value) {
+    switch (value) {
+      case OnOrientationChangeOrientation::Portrait: return "portrait";
+      case OnOrientationChangeOrientation::Landscape: return "landscape";
+    }
+  }
+
+  struct OnOrientationChange {
+      OnOrientationChangeOrientation orientation;
+    };
+  void onRequestClose(OnRequestClose value) const;
+
+  void onShow(OnShow value) const;
+
+  void onDismiss(OnDismiss value) const;
+
+  void onOrientationChange(OnOrientationChange value) const;
+};
+class SafeAreaViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+class SwitchEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  struct OnChange {
+      bool value;
+    int target;
+    };
+  void onChange(OnChange value) const;
+};
+class UnimplementedNativeViewEventEmitter : public ViewEventEmitter {
+ public:
+  using ViewEventEmitter::ViewEventEmitter;
+
+  
+  
+};
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/Props.cpp b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/Props.cpp
new file mode 100644
index 0000000..2f1c07f
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/Props.cpp
@@ -0,0 +1,156 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsCpp.js
+ */
+
+#include <react/renderer/components/rncore/Props.h>
+#include <react/renderer/core/PropsParserContext.h>
+#include <react/renderer/core/propsConversions.h>
+
+namespace facebook::react {
+
+ActivityIndicatorViewProps::ActivityIndicatorViewProps(
+    const PropsParserContext &context,
+    const ActivityIndicatorViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    hidesWhenStopped(convertRawProp(context, rawProps, "hidesWhenStopped", sourceProps.hidesWhenStopped, {true})),
+    animating(convertRawProp(context, rawProps, "animating", sourceProps.animating, {true})),
+    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
+    size(convertRawProp(context, rawProps, "size", sourceProps.size, {ActivityIndicatorViewSize::Small}))
+      {}
+AndroidDrawerLayoutProps::AndroidDrawerLayoutProps(
+    const PropsParserContext &context,
+    const AndroidDrawerLayoutProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    keyboardDismissMode(convertRawProp(context, rawProps, "keyboardDismissMode", sourceProps.keyboardDismissMode, {AndroidDrawerLayoutKeyboardDismissMode::None})),
+    drawerBackgroundColor(convertRawProp(context, rawProps, "drawerBackgroundColor", sourceProps.drawerBackgroundColor, {})),
+    drawerPosition(convertRawProp(context, rawProps, "drawerPosition", sourceProps.drawerPosition, {AndroidDrawerLayoutDrawerPosition::Left})),
+    drawerWidth(convertRawProp(context, rawProps, "drawerWidth", sourceProps.drawerWidth, {})),
+    drawerLockMode(convertRawProp(context, rawProps, "drawerLockMode", sourceProps.drawerLockMode, {AndroidDrawerLayoutDrawerLockMode::Unlocked})),
+    statusBarBackgroundColor(convertRawProp(context, rawProps, "statusBarBackgroundColor", sourceProps.statusBarBackgroundColor, {}))
+      {}
+AndroidHorizontalScrollContentViewProps::AndroidHorizontalScrollContentViewProps(
+    const PropsParserContext &context,
+    const AndroidHorizontalScrollContentViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    removeClippedSubviews(convertRawProp(context, rawProps, "removeClippedSubviews", sourceProps.removeClippedSubviews, {false}))
+      {}
+AndroidSwipeRefreshLayoutProps::AndroidSwipeRefreshLayoutProps(
+    const PropsParserContext &context,
+    const AndroidSwipeRefreshLayoutProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    enabled(convertRawProp(context, rawProps, "enabled", sourceProps.enabled, {true})),
+    colors(convertRawProp(context, rawProps, "colors", sourceProps.colors, {})),
+    progressBackgroundColor(convertRawProp(context, rawProps, "progressBackgroundColor", sourceProps.progressBackgroundColor, {})),
+    size(convertRawProp(context, rawProps, "size", sourceProps.size, {AndroidSwipeRefreshLayoutSize::Default})),
+    progressViewOffset(convertRawProp(context, rawProps, "progressViewOffset", sourceProps.progressViewOffset, {0.0})),
+    refreshing(convertRawProp(context, rawProps, "refreshing", sourceProps.refreshing, {false}))
+      {}
+AndroidSwitchProps::AndroidSwitchProps(
+    const PropsParserContext &context,
+    const AndroidSwitchProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    disabled(convertRawProp(context, rawProps, "disabled", sourceProps.disabled, {false})),
+    enabled(convertRawProp(context, rawProps, "enabled", sourceProps.enabled, {true})),
+    thumbColor(convertRawProp(context, rawProps, "thumbColor", sourceProps.thumbColor, {})),
+    trackColorForFalse(convertRawProp(context, rawProps, "trackColorForFalse", sourceProps.trackColorForFalse, {})),
+    trackColorForTrue(convertRawProp(context, rawProps, "trackColorForTrue", sourceProps.trackColorForTrue, {})),
+    value(convertRawProp(context, rawProps, "value", sourceProps.value, {false})),
+    on(convertRawProp(context, rawProps, "on", sourceProps.on, {false})),
+    thumbTintColor(convertRawProp(context, rawProps, "thumbTintColor", sourceProps.thumbTintColor, {})),
+    trackTintColor(convertRawProp(context, rawProps, "trackTintColor", sourceProps.trackTintColor, {}))
+      {}
+DebuggingOverlayProps::DebuggingOverlayProps(
+    const PropsParserContext &context,
+    const DebuggingOverlayProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps)
+
+    
+      {}
+AndroidProgressBarProps::AndroidProgressBarProps(
+    const PropsParserContext &context,
+    const AndroidProgressBarProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    styleAttr(convertRawProp(context, rawProps, "styleAttr", sourceProps.styleAttr, {})),
+    typeAttr(convertRawProp(context, rawProps, "typeAttr", sourceProps.typeAttr, {})),
+    indeterminate(convertRawProp(context, rawProps, "indeterminate", sourceProps.indeterminate, {false})),
+    progress(convertRawProp(context, rawProps, "progress", sourceProps.progress, {0.0})),
+    animating(convertRawProp(context, rawProps, "animating", sourceProps.animating, {true})),
+    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
+    testID(convertRawProp(context, rawProps, "testID", sourceProps.testID, {""}))
+      {}
+PullToRefreshViewProps::PullToRefreshViewProps(
+    const PropsParserContext &context,
+    const PullToRefreshViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    tintColor(convertRawProp(context, rawProps, "tintColor", sourceProps.tintColor, {})),
+    titleColor(convertRawProp(context, rawProps, "titleColor", sourceProps.titleColor, {})),
+    title(convertRawProp(context, rawProps, "title", sourceProps.title, {})),
+    progressViewOffset(convertRawProp(context, rawProps, "progressViewOffset", sourceProps.progressViewOffset, {0.0})),
+    refreshing(convertRawProp(context, rawProps, "refreshing", sourceProps.refreshing, {false}))
+      {}
+InputAccessoryProps::InputAccessoryProps(
+    const PropsParserContext &context,
+    const InputAccessoryProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    backgroundColor(convertRawProp(context, rawProps, "backgroundColor", sourceProps.backgroundColor, {}))
+      {}
+ModalHostViewProps::ModalHostViewProps(
+    const PropsParserContext &context,
+    const ModalHostViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    animationType(convertRawProp(context, rawProps, "animationType", sourceProps.animationType, {ModalHostViewAnimationType::None})),
+    presentationStyle(convertRawProp(context, rawProps, "presentationStyle", sourceProps.presentationStyle, {ModalHostViewPresentationStyle::FullScreen})),
+    transparent(convertRawProp(context, rawProps, "transparent", sourceProps.transparent, {false})),
+    statusBarTranslucent(convertRawProp(context, rawProps, "statusBarTranslucent", sourceProps.statusBarTranslucent, {false})),
+    navigationBarTranslucent(convertRawProp(context, rawProps, "navigationBarTranslucent", sourceProps.navigationBarTranslucent, {false})),
+    hardwareAccelerated(convertRawProp(context, rawProps, "hardwareAccelerated", sourceProps.hardwareAccelerated, {false})),
+    visible(convertRawProp(context, rawProps, "visible", sourceProps.visible, {false})),
+    animated(convertRawProp(context, rawProps, "animated", sourceProps.animated, {false})),
+    supportedOrientations(convertRawProp(context, rawProps, "supportedOrientations", ModalHostViewSupportedOrientationsMaskWrapped{ .value = sourceProps.supportedOrientations }, {static_cast<ModalHostViewSupportedOrientationsMask>(ModalHostViewSupportedOrientations::Portrait)}).value),
+    identifier(convertRawProp(context, rawProps, "identifier", sourceProps.identifier, {0}))
+      {}
+SafeAreaViewProps::SafeAreaViewProps(
+    const PropsParserContext &context,
+    const SafeAreaViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps)
+
+    
+      {}
+SwitchProps::SwitchProps(
+    const PropsParserContext &context,
+    const SwitchProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    disabled(convertRawProp(context, rawProps, "disabled", sourceProps.disabled, {false})),
+    value(convertRawProp(context, rawProps, "value", sourceProps.value, {false})),
+    tintColor(convertRawProp(context, rawProps, "tintColor", sourceProps.tintColor, {})),
+    onTintColor(convertRawProp(context, rawProps, "onTintColor", sourceProps.onTintColor, {})),
+    thumbTintColor(convertRawProp(context, rawProps, "thumbTintColor", sourceProps.thumbTintColor, {})),
+    thumbColor(convertRawProp(context, rawProps, "thumbColor", sourceProps.thumbColor, {})),
+    trackColorForFalse(convertRawProp(context, rawProps, "trackColorForFalse", sourceProps.trackColorForFalse, {})),
+    trackColorForTrue(convertRawProp(context, rawProps, "trackColorForTrue", sourceProps.trackColorForTrue, {}))
+      {}
+UnimplementedNativeViewProps::UnimplementedNativeViewProps(
+    const PropsParserContext &context,
+    const UnimplementedNativeViewProps &sourceProps,
+    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),
+
+    name(convertRawProp(context, rawProps, "name", sourceProps.name, {""}))
+      {}
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/Props.h b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/Props.h
new file mode 100644
index 0000000..8290990
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/Props.h
@@ -0,0 +1,397 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GeneratePropsH.js
+ */
+#pragma once
+
+#include <cinttypes>
+#include <react/renderer/components/view/ViewProps.h>
+#include <react/renderer/core/PropsParserContext.h>
+#include <react/renderer/graphics/Color.h>
+#include <vector>
+
+namespace facebook::react {
+
+enum class ActivityIndicatorViewSize { Small, Large };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ActivityIndicatorViewSize &result) {
+  auto string = (std::string)value;
+  if (string == "small") { result = ActivityIndicatorViewSize::Small; return; }
+  if (string == "large") { result = ActivityIndicatorViewSize::Large; return; }
+  abort();
+}
+
+static inline std::string toString(const ActivityIndicatorViewSize &value) {
+  switch (value) {
+    case ActivityIndicatorViewSize::Small: return "small";
+    case ActivityIndicatorViewSize::Large: return "large";
+  }
+}
+
+class ActivityIndicatorViewProps final : public ViewProps {
+ public:
+  ActivityIndicatorViewProps() = default;
+  ActivityIndicatorViewProps(const PropsParserContext& context, const ActivityIndicatorViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  bool hidesWhenStopped{true};
+  bool animating{true};
+  SharedColor color{};
+  ActivityIndicatorViewSize size{ActivityIndicatorViewSize::Small};
+};
+
+enum class AndroidDrawerLayoutKeyboardDismissMode { None, OnDrag };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, AndroidDrawerLayoutKeyboardDismissMode &result) {
+  auto string = (std::string)value;
+  if (string == "none") { result = AndroidDrawerLayoutKeyboardDismissMode::None; return; }
+  if (string == "on-drag") { result = AndroidDrawerLayoutKeyboardDismissMode::OnDrag; return; }
+  abort();
+}
+
+static inline std::string toString(const AndroidDrawerLayoutKeyboardDismissMode &value) {
+  switch (value) {
+    case AndroidDrawerLayoutKeyboardDismissMode::None: return "none";
+    case AndroidDrawerLayoutKeyboardDismissMode::OnDrag: return "on-drag";
+  }
+}
+enum class AndroidDrawerLayoutDrawerPosition { Left, Right };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, AndroidDrawerLayoutDrawerPosition &result) {
+  auto string = (std::string)value;
+  if (string == "left") { result = AndroidDrawerLayoutDrawerPosition::Left; return; }
+  if (string == "right") { result = AndroidDrawerLayoutDrawerPosition::Right; return; }
+  abort();
+}
+
+static inline std::string toString(const AndroidDrawerLayoutDrawerPosition &value) {
+  switch (value) {
+    case AndroidDrawerLayoutDrawerPosition::Left: return "left";
+    case AndroidDrawerLayoutDrawerPosition::Right: return "right";
+  }
+}
+enum class AndroidDrawerLayoutDrawerLockMode { Unlocked, LockedClosed, LockedOpen };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, AndroidDrawerLayoutDrawerLockMode &result) {
+  auto string = (std::string)value;
+  if (string == "unlocked") { result = AndroidDrawerLayoutDrawerLockMode::Unlocked; return; }
+  if (string == "locked-closed") { result = AndroidDrawerLayoutDrawerLockMode::LockedClosed; return; }
+  if (string == "locked-open") { result = AndroidDrawerLayoutDrawerLockMode::LockedOpen; return; }
+  abort();
+}
+
+static inline std::string toString(const AndroidDrawerLayoutDrawerLockMode &value) {
+  switch (value) {
+    case AndroidDrawerLayoutDrawerLockMode::Unlocked: return "unlocked";
+    case AndroidDrawerLayoutDrawerLockMode::LockedClosed: return "locked-closed";
+    case AndroidDrawerLayoutDrawerLockMode::LockedOpen: return "locked-open";
+  }
+}
+
+class AndroidDrawerLayoutProps final : public ViewProps {
+ public:
+  AndroidDrawerLayoutProps() = default;
+  AndroidDrawerLayoutProps(const PropsParserContext& context, const AndroidDrawerLayoutProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  AndroidDrawerLayoutKeyboardDismissMode keyboardDismissMode{AndroidDrawerLayoutKeyboardDismissMode::None};
+  SharedColor drawerBackgroundColor{};
+  AndroidDrawerLayoutDrawerPosition drawerPosition{AndroidDrawerLayoutDrawerPosition::Left};
+  Float drawerWidth{};
+  AndroidDrawerLayoutDrawerLockMode drawerLockMode{AndroidDrawerLayoutDrawerLockMode::Unlocked};
+  SharedColor statusBarBackgroundColor{};
+};
+
+class AndroidHorizontalScrollContentViewProps final : public ViewProps {
+ public:
+  AndroidHorizontalScrollContentViewProps() = default;
+  AndroidHorizontalScrollContentViewProps(const PropsParserContext& context, const AndroidHorizontalScrollContentViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  bool removeClippedSubviews{false};
+};
+
+enum class AndroidSwipeRefreshLayoutSize { Default, Large };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, AndroidSwipeRefreshLayoutSize &result) {
+  auto string = (std::string)value;
+  if (string == "default") { result = AndroidSwipeRefreshLayoutSize::Default; return; }
+  if (string == "large") { result = AndroidSwipeRefreshLayoutSize::Large; return; }
+  abort();
+}
+
+static inline std::string toString(const AndroidSwipeRefreshLayoutSize &value) {
+  switch (value) {
+    case AndroidSwipeRefreshLayoutSize::Default: return "default";
+    case AndroidSwipeRefreshLayoutSize::Large: return "large";
+  }
+}
+
+class AndroidSwipeRefreshLayoutProps final : public ViewProps {
+ public:
+  AndroidSwipeRefreshLayoutProps() = default;
+  AndroidSwipeRefreshLayoutProps(const PropsParserContext& context, const AndroidSwipeRefreshLayoutProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  bool enabled{true};
+  std::vector<SharedColor> colors{};
+  SharedColor progressBackgroundColor{};
+  AndroidSwipeRefreshLayoutSize size{AndroidSwipeRefreshLayoutSize::Default};
+  Float progressViewOffset{0.0};
+  bool refreshing{false};
+};
+
+class AndroidSwitchProps final : public ViewProps {
+ public:
+  AndroidSwitchProps() = default;
+  AndroidSwitchProps(const PropsParserContext& context, const AndroidSwitchProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  bool disabled{false};
+  bool enabled{true};
+  SharedColor thumbColor{};
+  SharedColor trackColorForFalse{};
+  SharedColor trackColorForTrue{};
+  bool value{false};
+  bool on{false};
+  SharedColor thumbTintColor{};
+  SharedColor trackTintColor{};
+};
+
+class DebuggingOverlayProps final : public ViewProps {
+ public:
+  DebuggingOverlayProps() = default;
+  DebuggingOverlayProps(const PropsParserContext& context, const DebuggingOverlayProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  
+};
+
+class AndroidProgressBarProps final : public ViewProps {
+ public:
+  AndroidProgressBarProps() = default;
+  AndroidProgressBarProps(const PropsParserContext& context, const AndroidProgressBarProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  std::string styleAttr{};
+  std::string typeAttr{};
+  bool indeterminate{false};
+  double progress{0.0};
+  bool animating{true};
+  SharedColor color{};
+  std::string testID{""};
+};
+
+class PullToRefreshViewProps final : public ViewProps {
+ public:
+  PullToRefreshViewProps() = default;
+  PullToRefreshViewProps(const PropsParserContext& context, const PullToRefreshViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  SharedColor tintColor{};
+  SharedColor titleColor{};
+  std::string title{};
+  Float progressViewOffset{0.0};
+  bool refreshing{false};
+};
+
+class InputAccessoryProps final : public ViewProps {
+ public:
+  InputAccessoryProps() = default;
+  InputAccessoryProps(const PropsParserContext& context, const InputAccessoryProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  SharedColor backgroundColor{};
+};
+
+enum class ModalHostViewAnimationType { None, Slide, Fade };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ModalHostViewAnimationType &result) {
+  auto string = (std::string)value;
+  if (string == "none") { result = ModalHostViewAnimationType::None; return; }
+  if (string == "slide") { result = ModalHostViewAnimationType::Slide; return; }
+  if (string == "fade") { result = ModalHostViewAnimationType::Fade; return; }
+  abort();
+}
+
+static inline std::string toString(const ModalHostViewAnimationType &value) {
+  switch (value) {
+    case ModalHostViewAnimationType::None: return "none";
+    case ModalHostViewAnimationType::Slide: return "slide";
+    case ModalHostViewAnimationType::Fade: return "fade";
+  }
+}
+enum class ModalHostViewPresentationStyle { FullScreen, PageSheet, FormSheet, OverFullScreen };
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ModalHostViewPresentationStyle &result) {
+  auto string = (std::string)value;
+  if (string == "fullScreen") { result = ModalHostViewPresentationStyle::FullScreen; return; }
+  if (string == "pageSheet") { result = ModalHostViewPresentationStyle::PageSheet; return; }
+  if (string == "formSheet") { result = ModalHostViewPresentationStyle::FormSheet; return; }
+  if (string == "overFullScreen") { result = ModalHostViewPresentationStyle::OverFullScreen; return; }
+  abort();
+}
+
+static inline std::string toString(const ModalHostViewPresentationStyle &value) {
+  switch (value) {
+    case ModalHostViewPresentationStyle::FullScreen: return "fullScreen";
+    case ModalHostViewPresentationStyle::PageSheet: return "pageSheet";
+    case ModalHostViewPresentationStyle::FormSheet: return "formSheet";
+    case ModalHostViewPresentationStyle::OverFullScreen: return "overFullScreen";
+  }
+}
+using ModalHostViewSupportedOrientationsMask = uint32_t;
+
+struct ModalHostViewSupportedOrientationsMaskWrapped {
+  ModalHostViewSupportedOrientationsMask value;
+};
+
+enum class ModalHostViewSupportedOrientations: ModalHostViewSupportedOrientationsMask {
+  Portrait = 1 << 0,
+  PortraitUpsideDown = 1 << 1,
+  Landscape = 1 << 2,
+  LandscapeLeft = 1 << 3,
+  LandscapeRight = 1 << 4
+};
+
+constexpr bool operator&(
+  ModalHostViewSupportedOrientationsMask const lhs,
+  enum ModalHostViewSupportedOrientations const rhs) {
+  return lhs & static_cast<ModalHostViewSupportedOrientationsMask>(rhs);
+}
+
+constexpr ModalHostViewSupportedOrientationsMask operator|(
+  ModalHostViewSupportedOrientationsMask const lhs,
+  enum ModalHostViewSupportedOrientations const rhs) {
+  return lhs | static_cast<ModalHostViewSupportedOrientationsMask>(rhs);
+}
+
+constexpr void operator|=(
+  ModalHostViewSupportedOrientationsMask &lhs,
+  enum ModalHostViewSupportedOrientations const rhs) {
+  lhs = lhs | static_cast<ModalHostViewSupportedOrientationsMask>(rhs);
+}
+
+static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, ModalHostViewSupportedOrientationsMaskWrapped &wrapped) {
+  auto items = std::vector<std::string>{value};
+  for (const auto &item : items) {
+    if (item == "portrait") {
+      wrapped.value |= ModalHostViewSupportedOrientations::Portrait;
+      continue;
+    }
+    if (item == "portrait-upside-down") {
+      wrapped.value |= ModalHostViewSupportedOrientations::PortraitUpsideDown;
+      continue;
+    }
+    if (item == "landscape") {
+      wrapped.value |= ModalHostViewSupportedOrientations::Landscape;
+      continue;
+    }
+    if (item == "landscape-left") {
+      wrapped.value |= ModalHostViewSupportedOrientations::LandscapeLeft;
+      continue;
+    }
+    if (item == "landscape-right") {
+      wrapped.value |= ModalHostViewSupportedOrientations::LandscapeRight;
+      continue;
+    }
+    abort();
+  }
+}
+
+static inline std::string toString(const ModalHostViewSupportedOrientationsMaskWrapped &wrapped) {
+    auto result = std::string{};
+    auto separator = std::string{", "};
+
+    if (wrapped.value & ModalHostViewSupportedOrientations::Portrait) {
+      result += "portrait" + separator;
+    }
+    if (wrapped.value & ModalHostViewSupportedOrientations::PortraitUpsideDown) {
+      result += "portrait-upside-down" + separator;
+    }
+    if (wrapped.value & ModalHostViewSupportedOrientations::Landscape) {
+      result += "landscape" + separator;
+    }
+    if (wrapped.value & ModalHostViewSupportedOrientations::LandscapeLeft) {
+      result += "landscape-left" + separator;
+    }
+    if (wrapped.value & ModalHostViewSupportedOrientations::LandscapeRight) {
+      result += "landscape-right" + separator;
+    }
+    if (!result.empty()) {
+      result.erase(result.length() - separator.length());
+    }
+    return result;
+}
+
+class ModalHostViewProps final : public ViewProps {
+ public:
+  ModalHostViewProps() = default;
+  ModalHostViewProps(const PropsParserContext& context, const ModalHostViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  ModalHostViewAnimationType animationType{ModalHostViewAnimationType::None};
+  ModalHostViewPresentationStyle presentationStyle{ModalHostViewPresentationStyle::FullScreen};
+  bool transparent{false};
+  bool statusBarTranslucent{false};
+  bool navigationBarTranslucent{false};
+  bool hardwareAccelerated{false};
+  bool visible{false};
+  bool animated{false};
+  ModalHostViewSupportedOrientationsMask supportedOrientations{static_cast<ModalHostViewSupportedOrientationsMask>(ModalHostViewSupportedOrientations::Portrait)};
+  int identifier{0};
+};
+
+class SafeAreaViewProps final : public ViewProps {
+ public:
+  SafeAreaViewProps() = default;
+  SafeAreaViewProps(const PropsParserContext& context, const SafeAreaViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  
+};
+
+class SwitchProps final : public ViewProps {
+ public:
+  SwitchProps() = default;
+  SwitchProps(const PropsParserContext& context, const SwitchProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  bool disabled{false};
+  bool value{false};
+  SharedColor tintColor{};
+  SharedColor onTintColor{};
+  SharedColor thumbTintColor{};
+  SharedColor thumbColor{};
+  SharedColor trackColorForFalse{};
+  SharedColor trackColorForTrue{};
+};
+
+class UnimplementedNativeViewProps final : public ViewProps {
+ public:
+  UnimplementedNativeViewProps() = default;
+  UnimplementedNativeViewProps(const PropsParserContext& context, const UnimplementedNativeViewProps &sourceProps, const RawProps &rawProps);
+
+#pragma mark - Props
+
+  std::string name{""};
+};
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ShadowNodes.cpp b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ShadowNodes.cpp
new file mode 100644
index 0000000..8eb1b82
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ShadowNodes.cpp
@@ -0,0 +1,23 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeCpp.js
+ */
+
+#include <react/renderer/components/rncore/ShadowNodes.h>
+
+namespace facebook::react {
+
+extern const char ActivityIndicatorViewComponentName[] = "ActivityIndicatorView";
+extern const char AndroidDrawerLayoutComponentName[] = "AndroidDrawerLayout";
+extern const char AndroidSwipeRefreshLayoutComponentName[] = "AndroidSwipeRefreshLayout";
+extern const char DebuggingOverlayComponentName[] = "DebuggingOverlay";
+extern const char PullToRefreshViewComponentName[] = "PullToRefreshView";
+extern const char SwitchComponentName[] = "Switch";
+extern const char UnimplementedNativeViewComponentName[] = "UnimplementedNativeView";
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ShadowNodes.h b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ShadowNodes.h
new file mode 100644
index 0000000..6240f24
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/ShadowNodes.h
@@ -0,0 +1,98 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateShadowNodeH.js
+ */
+
+#pragma once
+
+#include <react/renderer/components/rncore/EventEmitters.h>
+#include <react/renderer/components/rncore/Props.h>
+#include <react/renderer/components/rncore/States.h>
+#include <react/renderer/components/view/ConcreteViewShadowNode.h>
+#include <jsi/jsi.h>
+
+namespace facebook::react {
+
+JSI_EXPORT extern const char ActivityIndicatorViewComponentName[];
+
+/*
+ * `ShadowNode` for <ActivityIndicatorView> component.
+ */
+using ActivityIndicatorViewShadowNode = ConcreteViewShadowNode<
+    ActivityIndicatorViewComponentName,
+    ActivityIndicatorViewProps,
+    ActivityIndicatorViewEventEmitter,
+    ActivityIndicatorViewState>;
+
+JSI_EXPORT extern const char AndroidDrawerLayoutComponentName[];
+
+/*
+ * `ShadowNode` for <AndroidDrawerLayout> component.
+ */
+using AndroidDrawerLayoutShadowNode = ConcreteViewShadowNode<
+    AndroidDrawerLayoutComponentName,
+    AndroidDrawerLayoutProps,
+    AndroidDrawerLayoutEventEmitter,
+    AndroidDrawerLayoutState>;
+
+JSI_EXPORT extern const char AndroidSwipeRefreshLayoutComponentName[];
+
+/*
+ * `ShadowNode` for <AndroidSwipeRefreshLayout> component.
+ */
+using AndroidSwipeRefreshLayoutShadowNode = ConcreteViewShadowNode<
+    AndroidSwipeRefreshLayoutComponentName,
+    AndroidSwipeRefreshLayoutProps,
+    AndroidSwipeRefreshLayoutEventEmitter,
+    AndroidSwipeRefreshLayoutState>;
+
+JSI_EXPORT extern const char DebuggingOverlayComponentName[];
+
+/*
+ * `ShadowNode` for <DebuggingOverlay> component.
+ */
+using DebuggingOverlayShadowNode = ConcreteViewShadowNode<
+    DebuggingOverlayComponentName,
+    DebuggingOverlayProps,
+    DebuggingOverlayEventEmitter,
+    DebuggingOverlayState>;
+
+JSI_EXPORT extern const char PullToRefreshViewComponentName[];
+
+/*
+ * `ShadowNode` for <PullToRefreshView> component.
+ */
+using PullToRefreshViewShadowNode = ConcreteViewShadowNode<
+    PullToRefreshViewComponentName,
+    PullToRefreshViewProps,
+    PullToRefreshViewEventEmitter,
+    PullToRefreshViewState>;
+
+JSI_EXPORT extern const char SwitchComponentName[];
+
+/*
+ * `ShadowNode` for <Switch> component.
+ */
+using SwitchShadowNode = ConcreteViewShadowNode<
+    SwitchComponentName,
+    SwitchProps,
+    SwitchEventEmitter,
+    SwitchState>;
+
+JSI_EXPORT extern const char UnimplementedNativeViewComponentName[];
+
+/*
+ * `ShadowNode` for <UnimplementedNativeView> component.
+ */
+using UnimplementedNativeViewShadowNode = ConcreteViewShadowNode<
+    UnimplementedNativeViewComponentName,
+    UnimplementedNativeViewProps,
+    UnimplementedNativeViewEventEmitter,
+    UnimplementedNativeViewState>;
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/States.cpp b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/States.cpp
new file mode 100644
index 0000000..9762c3c
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/States.cpp
@@ -0,0 +1,16 @@
+
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateCpp.js
+ */
+#include <react/renderer/components/rncore/States.h>
+
+namespace facebook::react {
+
+
+
+} // namespace facebook::react
diff --git a/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/States.h b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/States.h
new file mode 100644
index 0000000..df8b9e5
--- /dev/null
+++ b/node_modules/react-native/ReactAndroid/build/generated/source/codegen/jni/react/renderer/components/rncore/States.h
@@ -0,0 +1,101 @@
+/**
+ * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
+ *
+ * Do not edit this file as changes may cause incorrect behavior and will be lost
+ * once the code is regenerated.
+ *
+ * @generated by codegen project: GenerateStateH.js
+ */
+#pragma once
+
+#ifdef ANDROID
+#include <folly/dynamic.h>
+#endif
+
+namespace facebook::react {
+
+class ActivityIndicatorViewState {
+public:
+  ActivityIndicatorViewState() = default;
+
+#ifdef ANDROID
+  ActivityIndicatorViewState(ActivityIndicatorViewState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class AndroidDrawerLayoutState {
+public:
+  AndroidDrawerLayoutState() = default;
+
+#ifdef ANDROID
+  AndroidDrawerLayoutState(AndroidDrawerLayoutState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class AndroidSwipeRefreshLayoutState {
+public:
+  AndroidSwipeRefreshLayoutState() = default;
+
+#ifdef ANDROID
+  AndroidSwipeRefreshLayoutState(AndroidSwipeRefreshLayoutState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class DebuggingOverlayState {
+public:
+  DebuggingOverlayState() = default;
+
+#ifdef ANDROID
+  DebuggingOverlayState(DebuggingOverlayState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class PullToRefreshViewState {
+public:
+  PullToRefreshViewState() = default;
+
+#ifdef ANDROID
+  PullToRefreshViewState(PullToRefreshViewState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class SwitchState {
+public:
+  SwitchState() = default;
+
+#ifdef ANDROID
+  SwitchState(SwitchState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+class UnimplementedNativeViewState {
+public:
+  UnimplementedNativeViewState() = default;
+
+#ifdef ANDROID
+  UnimplementedNativeViewState(UnimplementedNativeViewState const &previousState, folly::dynamic data){};
+  folly::dynamic getDynamic() const {
+    return {};
+  };
+#endif
+};
+
+} // namespace facebook::react
\ No newline at end of file
diff --git a/node_modules/react-native/ReactAndroid/cmake-utils/ReactNative-application.cmake b/node_modules/react-native/ReactAndroid/cmake-utils/ReactNative-application.cmake
index d6881a5..c9dec6d 100644
--- a/node_modules/react-native/ReactAndroid/cmake-utils/ReactNative-application.cmake
+++ b/node_modules/react-native/ReactAndroid/cmake-utils/ReactNative-application.cmake
@@ -100,7 +100,9 @@ endif()
 
 # If project is running codegen at the app level, we want to link and build the generated library.
 if(EXISTS ${PROJECT_BUILD_DIR}/generated/source/codegen/jni/CMakeLists.txt)
-        add_subdirectory(${PROJECT_BUILD_DIR}/generated/source/codegen/jni/ codegen_app_build)
+        if(EXISTS "${PROJECT_BUILD_DIR}/generated/source/codegen/jni/")
+          add_subdirectory(${PROJECT_BUILD_DIR}/generated/source/codegen/jni/ codegen_app_build)
+        endif()
         get_property(APP_CODEGEN_TARGET DIRECTORY ${PROJECT_BUILD_DIR}/generated/source/codegen/jni/ PROPERTY BUILDSYSTEM_TARGETS)
         target_link_libraries(${CMAKE_PROJECT_NAME} ${APP_CODEGEN_TARGET})
         target_link_libraries(${APP_CODEGEN_TARGET} common_flags)
